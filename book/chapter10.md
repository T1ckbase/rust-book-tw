<!-- DO NOT EDIT THIS FILE.

This file is periodically generated from the content in the `/src/`
directory, so all fixes need to be made in `/src/`.
-->

[TOC]

# 泛型型別、Trait 與 Lifetime

每種程式語言都有有效處理概念重複的工具。在 Rust 中，其中一個工具是 _generics_：抽象地替代具體型別或其他屬性。我們可以在不知道編譯和執行程式碼時會用什麼來替代的情況下，表達 generics 的行為，或它們如何與其他 generics 相關。

函式可以接受某個泛型型別的參數，而不是像 `i32` 或 `String` 這樣的具體型別，就像函式接受未知值的參數一樣，以便在多個具體值上執行相同的程式碼。事實上，我們在第六章已經使用過 `Option<T>`，在第八章使用過 `Vec<T>` 和 `HashMap<K, V>`，在第九章使用過 `Result<T, E>`。在本章中，你將探索如何用 generics 定義你自己的型別、函式和方法！

首先，我們將回顧如何提取函式以減少程式碼重複。接著，我們將使用相同的技巧，從兩個僅參數型別不同的函式中建立一個泛型函式。我們也會解釋如何在 struct 和 enum 定義中使用泛型型別。

然後，你將學習如何使用 _traits_ 以泛型的方式定義行為。你可以將 traits 與泛型型別結合，將泛型型別限制為只接受那些具有特定行為的型別，而不是任何型別。

最後，我們將討論 _lifetimes_：一種 generics，它給予編譯器關於參照之間如何關聯的資訊。Lifetimes 讓我們能提供足夠的關於借用值的資訊給編譯器，使其能夠確保參照在更多情況下都是有效的，這超出了沒有我們幫助時它能做到的範圍。

## 透過提取函式來移除重複

Generics 讓我們能用一個代表多種型別的佔位符來取代特定型別，以消除程式碼的重複。在深入了解 generics 的語法之前，讓我們先看看如何透過提取一個函式來移除重複，這種方式不涉及泛型型別，而是用一個代表多個值的佔位符取代特定值。然後，我們將應用相同的技巧來提取一個泛型函式！透過學習如何辨識可以提取到函式中的重複程式碼，你將開始能夠辨識出可以使用 generics 的重複程式碼。

我們將從清單 10-1 über 一個簡短的程式開始，這個程式會找出列表中的最大數字。

src/main.rs

```rust
fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = &number_list[0];

    for number in &number_list {
        if number > largest {
            largest = number;
        }
    }

    println!("The largest number is {largest}");
}
```

清單 10-1：在數字列表中尋找最大數字

我們將一個整數列表儲存在變數 `number_list` 中，並將列表中第一個數字的參照放在一個名為 `largest` 的變數中。然後我們遍歷列表中的所有數字，如果當前數字大於儲存在 `largest` 中的數字，我們就替換該變數中的參照。然而，如果當前數字小於或等於目前為止看到的最大數字，該變數就不會改變，程式碼會繼續處理列表中的下一個數字。在考慮了列表中的所有數字之後，`largest` 應該會參照到最大的數字，在本例中是 100。

我們現在的任務是在兩個不同的數字列表中找到最大的數字。為此，我們可以選擇複製清單 10-1 的程式碼，並在程式的兩個不同地方使用相同的邏輯，如清單 10-2 所示。

src/main.rs

```rust
fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = &number_list[0];

    for number in &number_list {
        if number > largest {
            largest = number;
        }
    }

    println!("The largest number is {largest}");

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let mut largest = &number_list[0];

    for number in &number_list {
        if number > largest {
            largest = number;
        }
    }

    println!("The largest number is {largest}");
}
```

清單 10-2：在*兩個*數字列表中尋找最大數字的程式碼

雖然這段程式碼可以運作，但重複程式碼既乏味又容易出錯。當我們想要更改程式碼時，還必須記得在多個地方更新。

為了消除這種重複，我們將透過定義一個函式來建立一個抽象，這個函式可以操作任何傳入作為參數的整數列表。這個解決方案使我們的程式碼更清晰，並讓我們能以抽象的方式表達尋找列表中最大數字的概念。

在清單 10-3 中，我們將尋找最大數字的程式碼提取到一個名為 `largest` 的函式中。然後我們呼叫這個函式來尋找清單 10-2 中兩個列表的最大數字。我們也可以在未來可能擁有的任何其他 `i32` 值列表上使用這個函式。

src/main.rs

```rust
fn largest(list: &[i32]) -> &i32 {
    let mut largest = &list[0];

    for item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&number_list);
    println!("The largest number is {result}");

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let result = largest(&number_list);
    println!("The largest number is {result}");
}
```

清單 10-3：尋找兩個列表中最大數字的抽象化程式碼

`largest` 函式有一個名為 `list` 的參數，它代表我們可能傳入函式的任何具體 `i32` 值 slice。因此，當我們呼叫函式時，程式碼會在我們傳入的特定值上執行。

總結來說，以下是我們將程式碼從清單 10-2 改為清單 10-3 的步驟：

1. 辨識重複的程式碼。
2. 將重複的程式碼提取到函式的主體中，並在函式簽名中指定該程式碼的輸入和回傳值。
3. 更新兩個重複程式碼的實例，改為呼叫該函式。

接下來，我們將使用這些相同的步驟與 generics 來減少程式碼重複。就像函式主體可以在抽象的 `list` 上操作而不是特定值一樣，generics 允許程式碼在抽象的型別上操作。

例如，假設我們有兩個函式：一個在 `i32` 值的 slice 中尋找最大項目，另一個在 `char` 值的 slice 中尋找最大項目。我們該如何消除這種重複呢？讓我們來看看！

## 泛型資料型別

我們使用 generics 來為函式簽名或 struct 等項目建立定義，然後我們可以將這些定義用於許多不同的具體資料型別。讓我們首先看看如何使用 generics 來定義函式、struct、enum 和方法。然後我們將討論 generics 如何影響程式碼的效能。

### 在函式定義中

在定義使用 generics 的函式時，我們將 generics 放在函式簽名中，通常我們會在那裡指定參數和回傳值的資料型別。這樣做可以讓我們的程式碼更具彈性，為函式的呼叫者提供更多功能，同時避免程式碼重複。

繼續我們的 `largest` 函式，清單 10-4 顯示了兩個都在 slice 中尋找最大值的函式。我們稍後會將它們合併成一個使用 generics 的單一函式。

src/main.rs

```rust
fn largest_i32(list: &[i32]) -> &i32 {
    let mut largest = &list[0];

    for item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn largest_char(list: &[char]) -> &char {
    let mut largest = &list[0];

    for item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest_i32(&number_list);
    println!("The largest number is {result}");

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest_char(&char_list);
    println!("The largest char is {result}");
}
```

清單 10-4：兩個僅在名稱和簽名中型別不同的函式

`largest_i32` 函式是我們在清單 10-3 中提取的那個，用來在 slice 中尋找最大的 `i32`。`largest_char` 函式則在 slice 中尋找最大的 `char`。函式主體有著相同的程式碼，所以讓我們透過在單一函式中引入泛型型別參數來消除重複。

為了在新的一個函式中參數化型別，我們需要為型別參數命名，就像我們為函式的值參數命名一樣。你可以使用任何識別碼作為型別參數的名稱。但我們將使用 `T`，因為依照慣例，Rust 中的型別參數名稱很短，通常只有一個字母，而且 Rust 的型別命名慣例是駝峰式命名法 (CamelCase)。`T` 是 _type_ 的縮寫，是大多數 Rust 程式設計師的預設選擇。

當我們在函式主體中使用一個參數時，我們必須在簽名中宣告參數名稱，這樣編譯器才知道那個名稱代表什麼。同樣地，當我們在函式簽名中使用型別參數名稱時，我們必須在使用它之前宣告型別參數名稱。為了定義泛型的 `largest` 函式，我們將型別名稱宣告放在函式名稱和參數列表之間的角括號 `<>` 內，像這樣：

```rust
fn largest<T>(list: &[T]) -> &T {
```

我們將這個定義讀作：函式 `largest` 對於某個型別 `T` 是泛型的。這個函式有一個名為 `list` 的參數，它是一個型別為 `T` 的值的 slice。`largest` 函式將回傳一個相同型別 `T` 的值的參照。

清單 10-5 顯示了合併後的 `largest` 函式定義，在其簽名中使用了泛型資料型別。該清單也顯示了我們如何用 `i32` 值或 `char` 值的 slice 來呼叫這個函式。請注意，這段程式碼目前還無法編譯。

src/main.rs

```rust
fn largest<T>(list: &[T]) -> &T {
    let mut largest = &list[0];

    for item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&number_list);
    println!("The largest number is {result}");

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&char_list);
    println!("The largest char is {result}");
}
```

清單 10-5：使用泛型型別參數的 `largest` 函式；這段程式碼還不能編譯

如果我們現在編譯這段程式碼，會得到這個錯誤：

```
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0369]: binary operation `>` cannot be applied to type `&T`
 --> src/main.rs:5:17
  |
5 |         if item > largest {
  |            ---- ^ ------- &T
  |            |
  |            &T
  |
help: consider restricting type parameter `T` with trait `PartialOrd`
  |
1 | fn largest<T: std::cmp::PartialOrd>(list: &[T]) -> &T {
  |             ++++++++++++++++++++++

For more information about this error, try `rustc --explain E0369`.
error: could not compile `chapter10` (bin "chapter10") due to 1 previous error
```

輔助文字提到了 `std::cmp::PartialOrd`，這是一個 _trait_，我們將在下一節討論 traits。目前，只需知道這個錯誤說明 `largest` 的主體並不能對所有可能的 `T` 型別都有效。因為我們想在主體中比較 `T` 型別的值，所以我們只能使用那些值可以被排序的型別。為了啟用比較，標準函式庫有 `std::cmp::PartialOrd` trait，你可以在型別上實作它（關於這個 trait 的更多資訊，請參見附錄 C）。要修正清單 10-5，我們可以遵循輔助文字的建議，將 `T` 的有效型別限制為只實作了 `PartialOrd` 的那些型別。這樣清單就會編譯成功，因為標準函式庫在 `i32` 和 `char` 上都實作了 `PartialOrd`。

### 在 Struct 定義中

我們也可以定義 struct，使其在一個或多個欄位中使用泛型型別參數，使用 `<>` 語法。清單 10-6 定義了一個 `Point<T>` struct，用來存放任何型別的 `x` 和 `y` 座標值。

src/main.rs

```rust
struct Point<T> {
    x: T,
    y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
}
```

清單 10-6：一個 `Point<T>` struct，持有 `T` 型別的 `x` 和 `y` 值

在 struct 定義中使用 generics 的語法與在函式定義中使用的相似。首先，我們在 struct 名稱之後的角括號內宣告型別參數的名稱。然後，我們在 struct 定義中，原本會指定具體資料型別的地方使用這個泛型型別。

請注意，因為我們只用了一個泛型型別來定義 `Point<T>`，這個定義表示 `Point<T>` struct 對於某個型別 `T` 是泛型的，而且欄位 `x` 和 `y` *都是*相同的型別，無論那個型別是什麼。如果我們建立一個 `Point<T>` 的實例，而其值具有不同型別，如清單 10-7 所示，我們的程式碼將無法編譯。

src/main.rs

```rust
struct Point<T> {
    x: T,
    y: T,
}

fn main() {
    let wont_work = Point { x: 5, y: 4.0 };
}
```

清單 10-7：欄位 `x` 和 `y` 必須是相同型別，因為它們都具有相同的泛型資料型別 `T`。

在這個例子中，當我們將整數值 `5` 賦給 `x` 時，我們讓編譯器知道這個 `Point<T>` 實例的泛型 `T` 將會是整數。然後，當我們為 `y` 指定 `4.0`，而我們已定義 `y` 和 `x` 具有相同型別時，就會得到一個型別不匹配的錯誤，像這樣：

```
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0308]: mismatched types
 --> src/main.rs:7:38
  |
7 |     let wont_work = Point { x: 5, y: 4.0 };
  |                                      ^^^ expected integer, found floating-point number

For more information about this error, try `rustc --explain E0308`.
error: could not compile `chapter10` (bin "chapter10") due to 1 previous error
```

要定義一個 `Point` struct，其中 `x` 和 `y` 都是泛型但可以有不同型別，我們可以使用多個泛型型別參數。例如，在清單 10-8 中，我們將 `Point` 的定義改為對型別 `T` 和 `U` 泛型，其中 `x` 是 `T` 型別，`y` 是 `U` 型別。

src/main.rs

```rust
struct Point<T, U> {
    x: T,
    y: U,
}

fn main() {
    let both_integer = Point { x: 5, y: 10 };
    let both_float = Point { x: 1.0, y: 4.0 };
    let integer_and_float = Point { x: 5, y: 4.0 };
}
```

清單 10-8：一個對兩個型別泛型的 `Point<T, U>`，使得 `x` 和 `y` 可以是不同型別的值

現在，所有顯示的 `Point` 實例都是允許的了！你可以在一個定義中使用任意數量的泛型型別參數，但使用超過幾個會讓你的程式碼難以閱讀。如果你發現你的程式碼中需要很多泛型型別，這可能表示你的程式碼需要重構成更小的部分。

### 在 Enum 定義中

如同 struct，我們也可以定義 enum，讓其變體持有泛型資料型別。讓我們再看一下標準函式庫提供的 `Option<T>` enum，我們在第六章用過它：

```rust
enum Option<T> {
    Some(T),
    None,
}
```

這個定義現在對你來說應該更有意義了。如你所見，`Option<T>` enum 對型別 `T` 是泛型的，並且有兩個變體：`Some`，它持有一個 `T` 型別的值，和一個不持有任何值的 `None` 變體。透過使用 `Option<T>` enum，我們可以表達一個可選值的抽象概念，而且因為 `Option<T>` 是泛型的，我們可以不論可選值的型別為何，都使用這個抽象。

Enums 也可以使用多個泛型型別。我們在第九章用過的 `Result` enum 的定義就是一個例子：

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

`Result` enum 對兩個型別 `T` 和 `E` 是泛型的，並且有兩個變體：`Ok`，它持有一個 `T` 型別的值，和 `Err`，它持有一個 `E` 型別的值。這個定義使得在任何可能有成功（回傳某個 `T` 型別的值）或失敗（回傳某個 `E` 型別的錯誤）的操作中，使用 `Result` enum 都很方便。事實上，這就是我們在清單 9-3 中用來開啟檔案的方式，其中 `T` 在檔案成功開啟時被填入 `std::fs::File` 型別，而 `E` 在開啟檔案有問題時被填入 `std::io::Error` 型別。

當你在程式碼中辨識出多個 struct 或 enum 定義，它們之間僅僅是所持有的值的型別不同時，你可以使用泛型型別來避免重複。

### 在方法定義中

我們可以在 struct 和 enum 上實作方法（就像我們在第五章做的那樣），並在其定義中使用泛型型別。清單 10-9 顯示了我們在清單 10-6 中定義的 `Point<T>` struct，並在其上實作了一個名為 `x` 的方法。

src/main.rs

```rust
struct Point<T> {
    x: T,
    y: T,
}

impl<T> Point<T> {
    fn x(&self) -> &T {
        &self.x
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };

    println!("p.x = {}", p.x());
}
```

清單 10-9：在 `Point<T>` struct 上實作一個名為 `x` 的方法，該方法將回傳一個對 `T` 型別 `x` 欄位的參照

在這裡，我們在 `Point<T>` 上定義了一個名為 `x` 的方法，它回傳一個對欄位 `x` 中資料的參照。

請注意，我們必須在 `impl` 之後馬上宣告 `T`，這樣我們才能使用 `T` 來指定我們正在為 `Point<T>` 型別實作方法。透過在 `impl` 之後將 `T` 宣告為泛型型別，Rust 能夠辨識出 `Point` 角括號中的型別是一個泛型型別，而不是一個具體型別。我們可以為這個泛型參數選擇一個與 struct 定義中宣告的泛型參數不同的名稱，但使用相同的名稱是慣例。如果你在一個宣告泛型型別的 `impl` 中撰寫一個方法，該方法將會被定義在該型別的任何實例上，不論最終取代泛型型別的具體型別是什麼。

我們也可以在為型別定義方法時，對泛型型別指定約束。例如，我們可以只在 `Point<f32>` 實例上實作方法，而不是在任何泛型型別的 `Point<T>` 實例上。在清單 10-10 中，我們使用具體型別 `f32`，這表示我們在 `impl` 之後不宣告任何型別。

src/main.rs

```rust
impl Point<f32> {
    fn distance_from_origin(&self) -> f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
```

清單 10-10：一個只適用於泛型型別參數 `T` 為特定具體型別的 struct 的 `impl` 區塊

這段程式碼意味著 `Point<f32>` 型別將會有一個 `distance_from_origin` 方法；而 `T` 不是 `f32` 型別的其他 `Point<T>` 實例則不會定義這個方法。這個方法測量我們的點距離座標 (0.0, 0.0) 的點有多遠，並使用僅適用於浮點數型別的數學運算。

一個 struct 定義中的泛型型別參數不一定總是和你在同一個 struct 的方法簽名中使用的那些相同。清單 10-11 使用泛型型別 `X1` 和 `Y1` 來定義 `Point` struct，並使用 `X2` 和 `Y2` 來定義 `mixup` 方法的簽名，以使範例更清晰。這個方法會建立一個新的 `Point` 實例，其 `x` 值來自 `self` `Point`（型別為 `X1`），而 `y` 值則來自傳入的 `Point`（型別為 `Y2`）。

src/main.rs

```rust
struct Point<X1, Y1> {
    x: X1,
    y: Y1,
}

impl<X1, Y1> Point<X1, Y1> {
    fn mixup<X2, Y2>(self, other: Point<X2, Y2>) -> Point<X1, Y2> {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: "Hello", y: 'c' };

    let p3 = p1.mixup(p2);

    println!("p3.x = {}, p3.y = {}", p3.x, p3.y);
}
```

清單 10-11：一個使用與其 struct 定義不同泛型型別的方法

在 `main` 中，我們定義了一個 `Point`，它的 `x` 是 `i32`（值為 `5`），`y` 是 `f64`（值為 `10.4`）。變數 `p2` 是一個 `Point` struct，它的 `x` 是字串 slice（值為 `"Hello"`），`y` 是 `char`（值為 `c`）。在 `p1` 上呼叫 `mixup` 並傳入 `p2` 作為參數，我們會得到 `p3`，它的 `x` 會是 `i32`，因為 `x` 來自 `p1`。變數 `p3` 的 `y` 會是 `char`，因為 `y` 來自 `p2`。`println!` 巨集呼叫將會印出 `p3.x = 5, p3.y = c`。

這個範例的目的是展示一種情況，其中一些泛型參數是與 `impl` 一起宣告的，而另一些是與方法定義一起宣告的。在這裡，泛型參數 `X1` 和 `Y1` 是在 `impl` 之後宣告的，因為它們與 struct 定義相關。泛型參數 `X2` 和 `Y2` 是在 `fn mixup` 之後宣告的，因為它們只與該方法相關。

### 使用 Generics 的程式碼效能

你可能會好奇，使用泛型型別參數是否會有執行時成本。好消息是，使用泛型型別不會讓你的程式執行得比使用具體型別慢。

Rust 透過在編譯時期對使用 generics 的程式碼進行單態化 (monomorphization) 來達成這一點。_Monomorphization_ 是將泛型程式碼轉換為特定程式碼的過程，方法是填入編譯時使用的具體型別。在這個過程中，編譯器做的與我們在清單 10-5 中建立泛型函式的步驟相反：編譯器查看所有呼叫泛型程式碼的地方，並為呼叫泛型程式碼時使用的具體型別產生程式碼。

讓我們透過使用標準函式庫的泛型 `Option<T>` enum 來看看這是如何運作的：

```rust
let integer = Some(5);
let float = Some(5.0);
```

當 Rust 編譯這段程式碼時，它會進行 monomorphization。在這個過程中，編譯器會讀取在 `Option<T>` 實例中使用過的值，並辨識出兩種 `Option<T>`：一種是 `i32`，另一種是 `f64`。因此，它會將 `Option<T>` 的泛型定義展開為兩個專門針對 `i32` 和 `f64` 的定義，從而用具體的定義取代泛型的定義。

單態化後的程式碼版本看起來類似於下面這樣（編譯器會使用與我們這裡用於說明的不同的名稱）：

src/main.rs

```rust
enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let integer = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
}
```

泛型的 `Option<T>` 被編譯器建立的特定定義所取代。因為 Rust 將泛型程式碼編譯成在每個實例中都指定型別的程式碼，所以我們使用 generics 不會產生執行時成本。當程式碼執行時，它的表現就如同我們手動複製每個定義一樣。monomorphization 的過程使得 Rust 的 generics 在執行時期非常有效率。

## Traits：定義共享行為

一個 _trait_ 定義了某個特定型別所擁有且可以與其他型別共享的功能。我們可以使用 traits 以抽象的方式定義共享行為。我們可以使用 _trait bounds_ 來指定一個泛型型別可以是任何具有特定行為的型別。

> 注意：Traits 類似於其他語言中常稱為 _interfaces_ 的功能，儘管有一些差異。

### 定義一個 Trait

一個型別的行為由我們可以在該型別上呼叫的方法組成。如果我們可以在所有這些型別上呼叫相同的方法，那麼不同的型別就共享相同的行為。Trait 定義是將方法簽名組合在一起，以定義完成某些目的所需的一組行為的方式。

例如，假設我們有多個 struct，它們持有各種種類和數量的文本：一個 `NewsArticle` struct 持有在特定地點歸檔的新聞故事，以及一個 `SocialPost`，最多可以有 280 個字元，並帶有元數據，指出它是新貼文、轉貼文還是對另一篇貼文的回覆。

我們想要製作一個名為 `aggregator` 的媒體聚合器 library crate，它可以顯示可能儲存在 `NewsArticle` 或 `SocialPost` 實例中的資料摘要。為此，我們需要從每種類型中獲取一個摘要，我們將透過在實例上呼叫 `summarize` 方法來請求這個摘要。清單 10-12 顯示了一個公開的 `Summary` trait 的定義，它表達了這種行為。

src/lib.rs

```rust
pub trait Summary {
    fn summarize(&self) -> String;
}
```

清單 10-12：一個由 `summarize` 方法提供的行為組成的 `Summary` trait

在這裡，我們使用 `trait` 關鍵字來宣告一個 trait，然後是 trait 的名稱，在這裡是 `Summary`。我們也將 trait 宣告為 `pub`，這樣依賴於這個 crate 的其他 crate 也可以使用這個 trait，我們將在幾個例子中看到。在花括號內，我們宣告了描述實作此 trait 的型別行為的方法簽名，在此例中是 `fn summarize(&self) -> String`。

在方法簽名之後，我們使用分號，而不是在花括號內提供實作。每個實作此 trait 的型別都必須為方法的主體提供自己的客製化行為。編譯器將強制任何擁有 `Summary` trait 的型別都必須定義一個與此簽名完全相同的 `summarize` 方法。

一個 trait 的主體中可以有多個方法：方法簽名每行列出一個，每行以分號結束。

### 在型別上實作 Trait

既然我們已經定義了 `Summary` trait 方法所期望的簽名，我們就可以在我們的媒體聚合器中的型別上實作它。清單 10-13 顯示了在 `NewsArticle` struct 上實作 `Summary` trait 的範例，它使用標題、作者和地點來建立 `summarize` 的回傳值。對於 `SocialPost` struct，我們將 `summarize` 定義為使用者名稱後跟貼文的全部文本，假設貼文內容已經限制在 280 個字元以內。

src/lib.rs

```rust
pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {
    fn summarize(&self) -> String {
        format!("{}, by {} ({})", self.headline, self.author, self.location)
    }
}

pub struct SocialPost {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub repost: bool,
}

impl Summary for SocialPost {
    fn summarize(&self) -> String {
        format!("{}: {}", self.username, self.content)
    }
}
```

清單 10-13：在 `NewsArticle` 和 `SocialPost` 型別上實作 `Summary` trait

在型別上實作 trait 類似於實作一般方法。不同之處在於，在 `impl` 之後，我們放上想要實作的 trait 名稱，然後使用 `for` 關鍵字，再指定我們想要為其時做 trait 的型別名稱。在 `impl` 區塊內，我們放上 trait 定義所定義的方法簽名。我們不用在每個簽名後加上分號，而是使用花括號，並用我們希望 trait 的方法對特定型別具有的具體行為來填寫方法主體。

現在這個 library 已經在 `NewsArticle` 和 `SocialPost` 上實作了 `Summary` trait，這個 crate 的使用者可以在 `NewsArticle` 和 `SocialPost` 的實例上呼叫 trait 的方法，就像我們呼叫一般方法一樣。唯一的不同是，使用者必須將 trait 和型別都引入作用域。以下是一個 binary crate 如何使用我們的 `aggregator` library crate 的範例：

```rust
use aggregator::{SocialPost, Summary};

fn main() {
    let post = SocialPost {
        username: String::from("horse_ebooks"),
        content: String::from(
            "of course, as you probably already know, people",
        ),
        reply: false,
        repost: false,
    };

    println!("1 new post: {}", post.summarize());
}
```

這段程式碼會印出 `1 new post: horse_ebooks: of course, as you probably already know, people`。

其他依賴於 `aggregator` crate 的 crate 也可以將 `Summary` trait 引入作用域，以便在自己的型別上實作 `Summary`。需要注意的一個限制是，我們只能在 trait 或型別，或兩者都位於我們 crate 本地的情況下，在型別上實作 trait。例如，我們可以將標準函式庫的 `Display` 這樣的 trait 實作在像 `SocialPost` 這樣的自訂型別上，作為我們 `aggregator` crate 功能的一部分，因為 `SocialPost` 型別是我們 `aggregator` crate 的本地型別。我們也可以在我們的 `aggregator` crate 中為 `Vec<T>` 實作 `Summary`，因為 `Summary` trait 是我們 `aggregator` crate 的本地 trait。

但是我們不能在外部型別上實作外部 trait。例如，我們不能在我們的 `aggregator` crate 中為 `Vec<T>` 實作 `Display` trait，因為 `Display` 和 `Vec<T>` 都是在標準函式庫中定義的，不是我們 `aggregator` crate 的本地型別。這個限制是一種稱為 _coherence_ 的特性的一部分，更具體地說是 _orphan rule_，之所以這樣命名是因為父型別不存在。這個規則確保其他人的程式碼不會破壞你的程式碼，反之亦然。沒有這個規則，兩個 crate 可能會為同一個型別實作同一個 trait，而 Rust 不知道該使用哪個實作。

### 預設實作

有時候，為 trait 中的部分或全部方法提供預設行為是很有用的，而不是要求每種類型都必須為所有方法提供實作。這樣，當我們在特定型別上實作 trait 時，可以保留或覆寫每個方法的預設行為。

在清單 10-14 中，我們為 `Summary` trait 的 `summarize` 方法指定了一個預設字串，而不是像清單 10-12 那樣只定義方法簽名。

src/lib.rs

```rust
pub trait Summary {
    fn summarize(&self) -> String {
        String::from("(Read more...)")
    }
}
```

清單 10-14：定義一個帶有 `summarize` 方法預設實作的 `Summary` trait

要使用預設實作來摘要 `NewsArticle` 的實例，我們指定一個空的 `impl` 區塊：`impl Summary for NewsArticle {}`。

儘管我們不再直接在 `NewsArticle` 上定義 `summarize` 方法，但我們提供了一個預設實作，並指定 `NewsArticle` 實作了 `Summary` trait。因此，我們仍然可以在 `NewsArticle` 的實例上呼叫 `summarize` 方法，像這樣：

```rust
    let article = NewsArticle {
        headline: String::from("Penguins win the Stanley Cup Championship!"),
        location: String::from("Pittsburgh, PA, USA"),
        author: String::from("Iceburgh"),
        content: String::from(
            "The Pittsburgh Penguins once again are the best \
             hockey team in the NHL.",
        ),
    };

    println!("New article available! {}", article.summarize());
```

這段程式碼會印出 `New article available! (Read more...)`。

建立一個預設實作不需要我們對清單 10-13 中 `SocialPost` 上 `Summary` 的實作做任何改變。原因是覆寫預設實作的語法與實作一個沒有預設實作的 trait 方法的語法是相同的。

預設實作可以呼叫同一個 trait 中的其他方法，即使那些其他方法沒有預設實作。透過這種方式，一個 trait 可以提供許多有用的功能，而只要求實作者指定其中一小部分。例如，我們可以定義 `Summary` trait 有一個 `summarize_author` 方法，其時做是必須的，然後定義一個 `summarize` 方法，它有一個呼叫 `summarize_author` 方法的預設實作：

```rust
pub trait Summary {
    fn summarize_author(&self) -> String;

    fn summarize(&self) -> String {
        format!("(Read more from {}...)", self.summarize_author())
    }
}
```

要使用這個版本的 `Summary`，我們只需要在型別上實作 trait 時定義 `summarize_author`：

```rust
impl Summary for SocialPost {
    fn summarize_author(&self) -> String {
        format!("@{}", self.username)
    }
}
```

在我們定義 `summarize_author` 之後，我們可以在 `SocialPost` struct 的實例上呼叫 `summarize`，而 `summarize` 的預設實作將會呼叫我們所提供的 `summarize_author` 的定義。因為我們已經實作了 `summarize_author`，所以 `Summary` trait 讓我們擁有了 `summarize` 方法的行為，而不需要我們撰寫任何更多的程式碼。看起來像這樣：

```rust
    let post = SocialPost {
        username: String::from("horse_ebooks"),
        content: String::from(
            "of course, as you probably already know, people",
        ),
        reply: false,
        repost: false,
    };

    println!("1 new post: {}", post.summarize());
```

這段程式碼會印出 `1 new post: (Read more from @horse_ebooks...)`。

請注意，無法從覆寫同一個方法的實作中呼叫該方法的預設實作。

### Trait 作為參數

現在你已經知道如何定義和實作 traits，我們可以探索如何使用 traits 來定義接受多種不同型別的函式。我們將使用我們在清單 10-13 中為 `NewsArticle` 和 `SocialPost` 型別實作的 `Summary` trait 來定義一個 `notify` 函式，它會在其 `item` 參數上呼叫 `summarize` 方法，這個參數是某個實作 `Summary` trait 的型別。為此，我們使用 `impl Trait` 語法，像這樣：

```rust
pub fn notify(item: &impl Summary) {
    println!("Breaking news! {}", item.summarize());
}
```

我們不為 `item` 參數指定具體型別，而是指定 `impl` 關鍵字和 trait 名稱。這個參數接受任何實作了指定 trait 的型別。在 `notify` 的主體中，我們可以對 `item` 呼叫任何來自 `Summary` trait 的方法，例如 `summarize`。我們可以呼叫 `notify` 並傳入任何 `NewsArticle` 或 `SocialPost` 的實例。用任何其他型別（例如 `String` 或 `i32`）呼叫此函式的程式碼將無法編譯，因為那些型別沒有實作 `Summary`。

<!-- Old headings. Do not remove or links may break. -->

<a id="fixing-the-largest-function-with-trait-bounds"></a>

#### Trait Bound 語法

`impl Trait` 語法適用於簡單直接的情況，但它實際上是一種更長形式的語法糖，稱為 _trait bound_；它看起來像這樣：

```rust
pub fn notify<T: Summary>(item: &T) {
    println!("Breaking news! {}", item.summarize());
}
```

這種較長的形式與上一節的範例等效，但更為冗長。我們將 trait bounds 放在泛型型別參數宣告之後，用冒號隔開，並放在角括號內。

`impl Trait` 語法在簡單情況下很方便，能讓程式碼更簡潔，而更完整的 trait bound 語法可以在其他情況下表達更複雜的內容。例如，我們可以有兩個實作 `Summary` 的參數。使用 `impl Trait` 語法看起來像這樣：

```rust
pub fn notify(item1: &impl Summary, item2: &impl Summary) {
```

如果我們希望這個函式允許 `item1` 和 `item2` 有不同的型別（只要這兩種型別都實作 `Summary`），那麼使用 `impl Trait` 是合適的。然而，如果我們想強制兩個參數都必須是相同的型別，我們就必須使用 trait bound，像這樣：

```rust
pub fn notify<T: Summary>(item1: &T, item2: &T) {
```

泛型型別 `T` 被指定為 `item1` 和 `item2` 參數的型別，這限制了函式，使得作為 `item1` 和 `item2` 參數傳入的值的具體型別必須相同。

#### 使用 + 語法指定多個 Trait Bounds

我們也可以指定多個 trait bound。假設我們希望 `notify` 在 `item` 上同時使用顯示格式化和 `summarize`：我們在 `notify` 的定義中指定 `item` 必須同時實作 `Display` 和 `Summary`。我們可以使用 `+` 語法來做到這一點：

```rust
pub fn notify(item: &(impl Summary + Display)) {
```

`+` 語法也適用於泛型型別的 trait bounds：

```rust
pub fn notify<T: Summary + Display>(item: &T) {
```

指定了這兩個 trait bounds 之後，`notify` 的主體就可以呼叫 `summarize` 並使用 `{}` 來格式化 `item`。

#### 使用 where 子句讓 Trait Bounds 更清晰

使用太多的 trait bounds 也有其缺點。每個泛型都有自己的 trait bounds，所以帶有多個泛型型別參數的函式可能會在函式名稱和參數列表之間包含大量的 trait bound 資訊，使得函式簽名難以閱讀。因此，Rust 提供了另一種語法，可以在函式簽名後的 `where` 子句中指定 trait bounds。所以，我們可以不用這樣寫：

```rust
fn some_function<T: Display + Clone, U: Clone + Debug>(t: &T, u: &U) -> i32 {
```

而是可以使用 `where` 子句，像這樣：

```rust
fn some_function<T, U>(t: &T, u: &U) -> i32
where
    T: Display + Clone,
    U: Clone + Debug,
{
```

這個函式的簽名就比較不那麼雜亂：函式名稱、參數列表和回傳型別都靠得很近，類似於一個沒有很多 trait bounds 的函式。

### 回傳實作 Trait 的型別

我們也可以在回傳位置使用 `impl Trait` 語法，以回傳一個實作了某個 trait 的型別的值，如下所示：

```rust
fn returns_summarizable() -> impl Summary {
    SocialPost {
        username: String::from("horse_ebooks"),
        content: String::from(
            "of course, as you probably already know, people",
        ),
        reply: false,
        repost: false,
    }
}
```

透過使用 `impl Summary` 作為回傳型別，我們指定 `returns_summarizable` 函式回傳某個實作 `Summary` trait 的型別，而不需要指明具體的型別。在這種情況下，`returns_summarizable` 回傳一個 `SocialPost`，但呼叫這個函式的程式碼不需要知道這一點。

只透過它所實作的 trait 來指定回傳型別的能力，在 closures 和 iterators 的上下文中特別有用，我們將在第 13 章中介紹。Closures 和 iterators 建立的型別只有編譯器知道，或是指定起來非常冗長的型別。`impl Trait` 語法讓你能夠簡潔地指定一個函式回傳某個實作 `Iterator` trait 的型別，而不需要寫出一個非常長的型別。

然而，你只能在回傳單一型別時使用 `impl Trait`。例如，下面這段程式碼回傳 `NewsArticle` 或 `SocialPost`，並將回傳型別指定為 `impl Summary`，這樣是行不通的：

```rust
fn returns_summarizable(switch: bool) -> impl Summary {
    if switch {
        NewsArticle {
            headline: String::from(
                "Penguins win the Stanley Cup Championship!",
            ),
            location: String::from("Pittsburgh, PA, USA"),
            author: String::from("Iceburgh"),
            content: String::from(
                "The Pittsburgh Penguins once again are the best \
                 hockey team in the NHL.",
            ),
        }
    } else {
        SocialPost {
            username: String::from("horse_ebooks"),
            content: String::from(
                "of course, as you probably already know, people",
            ),
            reply: false,
            repost: false,
        }
    }
}
```

由於編譯器中 `impl Trait` 語法的實作方式的限制，回傳 `NewsArticle` 或 `SocialPost` 都是不被允許的。我們將在第 18 章的「使用 Trait Objects 允許不同型別的值」一節中，介紹如何撰寫具有此行為的函式。

### 使用 Trait Bounds 來條件式地實作方法

透過在一個使用泛型型別參數的 `impl` 區塊中使用 trait bound，我們可以為那些實作了指定 traits 的型別有條件地實作方法。例如，清單 10-15 中的 `Pair<T>` 型別總是實作 `new` 函式來回傳一個新的 `Pair<T>` 實例（回想一下第 5 章「定義方法」一節，`Self` 是 `impl` 區塊型別的別名，在此例中是 `Pair<T>`）。但在下一個 `impl` 區塊中，`Pair<T>` 只有在其內部型別 `T` 實作了允許比較的 `PartialOrd` trait _以及_ 允許列印的 `Display` trait 時，才會實作 `cmp_display` 方法。

src/lib.rs

```rust
use std::fmt::Display;

struct Pair<T> {
    x: T,
    y: T,
}

impl<T> Pair<T> {
    fn new(x: T, y: T) -> Self {
        Self { x, y }
    }
}

impl<T: Display + PartialOrd> Pair<T> {
    fn cmp_display(&self) {
        if self.x >= self.y {
            println!("The largest member is x = {}", self.x);
        } else {
            println!("The largest member is y = {}", self.y);
        }
    }
}
```

清單 10-15：根據 trait bounds 在泛型型別上條件式地實作方法

我們也可以為任何實作了另一個 trait 的型別有條件地實作一個 trait。在任何滿足 trait bounds 的型別上實作一個 trait 稱為 _blanket implementations_，這在 Rust 標準函式庫中被廣泛使用。例如，標準函式庫在任何實作了 `Display` trait 的型別上實作 `ToString` trait。標準函式庫中的 `impl` 區塊看起來類似於這段程式碼：

```rust
impl<T: Display> ToString for T {
    // --snip--
}
```

因為標準函式庫有這個 blanket implementation，我們可以在任何實作 `Display` trait 的型別上呼叫由 `ToString` trait 定義的 `to_string` 方法。例如，我們可以將整數轉換成它們對應的 `String` 值，就像這樣，因為整數實作了 `Display`：

```rust
let s = 3.to_string();
```

Blanket implementations 會出現在 trait 文件中的「Implementors」部分。

Traits 和 trait bounds 讓我們能夠撰寫使用泛型型別參數的程式碼以減少重複，同時也能向編譯器指定我們希望泛型型別具有特定的行為。編譯器然後可以使用 trait bound 資訊來檢查我們程式碼中使用的所有具體型別是否提供了正確的行為。在動態型別語言中，如果我們在一個沒有定義某個方法的型別上呼叫該方法，我們會在執行時期得到一個錯誤。但 Rust 將這些錯誤移至編譯時期，所以我們被迫在程式碼能夠執行之前就修正這些問題。此外，我們不需要撰寫在執行時期檢查行為的程式碼，因為我們已經在編譯時期檢查過了。這樣做可以在不犧牲 generics 彈性的情況下提升效能。

## 使用 Lifetimes 驗證參照

Lifetimes 是我們已經在使用過的另一種泛型。Lifetimes 不是確保一個型別具有我們想要的行為，而是確保參照在我們需要它們的期間內都是有效的。

我們在第四章「參照與借用」一節中沒有討論到的一個細節是，Rust 中的每個參照都有一個 _lifetime_，也就是該參照有效的範圍。大多數時候，lifetimes 是隱含和推斷的，就像大多數時候，型別是被推斷的一樣。我們只有在多種型別可能時才需要註記型別。類似地，當參照的 lifetimes 可能以幾種不同方式關聯時，我們才需要註記 lifetimes。Rust 要求我們使用泛型 lifetime 參數來註記這些關係，以確保在執行時期實際使用的參照絕對是有效的。

註記 lifetimes 甚至不是大多數其他程式語言所擁有的概念，所以這會讓人感到陌生。雖然我們在本章中不會完整地涵蓋 lifetimes，但我們會討論你可能遇到的常見 lifetime 語法，讓你能夠熟悉這個概念。

### 使用 Lifetimes 防止懸置參照 (Dangling References)

lifetimes 的主要目標是防止 _dangling references_，它會導致程式參照到非預期的資料。考慮清單 10-16 中的程式，它有一個外部作用域和一個內部作用域。

```rust
fn main() {
    let r;

    {
        let x = 5;
        r = &x;
    }

    println!("r: {r}");
}
```

清單 10-16：試圖使用一個其值已經離開作用域的參照

> 注意：清單 10-16、10-17 和 10-23 中的範例宣告變數時沒有給它們初始值，所以變數名稱存在於外部作用域。乍看之下，這似乎與 Rust 沒有 null 值相衝突。然而，如果我們在給變數賦值之前嘗試使用它，我們會得到一個編譯時期錯誤，這顯示 Rust 確實不允許 null 值。

外部作用域宣告了一個名為 `r` 的變數，沒有初始值，而內部作用域宣告了一個名為 `x` 的變數，初始值為 `5`。在內部作用域中，我們試圖將 `r` 的值設定為 `x` 的參照。然後內部作用域結束，我們試圖印出 `r` 中的值。這段程式碼無法編譯，因為 `r` 所參照的值在我們嘗試使用它之前就已經離開了作用域。這是錯誤訊息：

```
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0597]: `x` does not live long enough
 --> src/main.rs:6:13
  |
5 |         let x = 5;
  |             - binding `x` declared here
6 |         r = &x;
  |             ^^ borrowed value does not live long enough
7 |     }
  |     - `x` dropped here while still borrowed
8 |
9 |     println!("r: {r}");
  |                  --- borrow later used here

For more information about this error, try `rustc --explain E0597`.
error: could not compile `chapter10` (bin "chapter10") due to 1 previous error
```

錯誤訊息說變數 `x`「活得不夠久」。原因是在第 7 行內部作用域結束時，`x` 將會離開作用域。但是 `r` 對於外部作用域仍然是有效的；因為它的作用域更大，我們說它「活得更久」。如果 Rust 允許這段程式碼運作，`r` 將會參照到 `x` 離開作用域時被釋放的記憶體，而我們對 `r` 做的任何事情都將無法正常運作。那麼 Rust 是如何判斷這段程式碼是無效的呢？它使用 borrow checker。

### Borrow Checker

Rust 編譯器有一個 _borrow checker_，它會比較作用域來判斷所有的借用是否都有效。清單 10-17 顯示了與清單 10-16 相同的程式碼，但加上了顯示變數 lifetimes 的註釋。

```rust
fn main() {
    let r;                // ---------+-- 'a
                          //          |
    {                     //          |
        let x = 5;        // -+-- 'b  |
        r = &x;           //  |       |
    }                     // -+       |
                          //          |
    println!("r: {r}");   //          |
}                         // ---------+
```

清單 10-17：`r` 和 `x` 的 lifetimes 註釋，分別命名為 `'a` 和 `'b`

在這裡，我們用 `'a` 標註了 `r` 的 lifetime，用 `'b` 標註了 `x` 的 lifetime。如你所見，內部的 `'b` 區塊比外部的 `'a` lifetime 區塊小得多。在編譯時期，Rust 比較這兩個 lifetimes 的大小，發現 `r` 的 lifetime 是 `'a`，但它參照的記憶體 lifetime 是 `'b`。程式被拒絕，因為 `'b` 比 `'a` 短：參照的對象活得沒有參照本身久。

清單 10-18 修正了程式碼，使其沒有 dangling reference，並且可以無誤地編譯。

```rust
fn main() {
    let x = 5;            // ----------+-- 'b
                          //           |
    let r = &x;           // --+-- 'a  |
                          //   |       |
    println!("r: {r}");   //   |       |
                          // --+       |
}                         // ----------+
```

清單 10-18：一個有效的參照，因為資料的 lifetime 比參照長

在這裡，`x` 的 lifetime 是 `'b`，在這個例子中它比 `'a` 大。這意味著 `r` 可以參照 `x`，因為 Rust 知道在 `x` 有效的期間，`r` 中的參照將永遠是有效的。

現在你已經知道參照的 lifetimes 在哪裡，以及 Rust 如何分析 lifetimes 以確保參照永遠有效，讓我們在函式的上下文中探討參數和回傳值的泛型 lifetimes。

### 函式中的泛型 Lifetimes

我們將寫一個函式，回傳兩個字串 slice 中較長的那一個。這個函式會接收兩個字串 slice 並回傳一個字串 slice。在我們實作 `longest` 函式之後，清單 10-19 中的程式碼應該會印出 `The longest string is abcd`。

src/main.rs

```rust
fn main() {
    let string1 = String::from("abcd");
    let string2 = "xyz";

    let result = longest(string1.as_str(), string2);
    println!("The longest string is {result}");
}
```

清單 10-19：一個呼叫 `longest` 函式來找出兩個字串 slice 中較長者的 `main` 函式

請注意，我們希望函式接受字串 slice（它們是參照），而不是字串，因為我們不希望 `longest` 函式取得其參數的 ownership。關於為什麼我們在清單 10-19 中使用的參數是我們想要的，請參考第四章的「字串 Slices 作為參數」一節以獲得更多討論。

如果我們嘗試像清單 10-20 那樣實作 `longest` 函式，它將無法編譯。

src/main.rs

```rust
fn longest(x: &str, y: &str) -> &str {
    if x.len() > y.len() { x } else { y }
}
```

清單 10-20：一個 `longest` 函式的實作，它回傳兩個字串 slice 中較長的一個，但還無法編譯

相反地，我們會得到以下關於 lifetimes 的錯誤：

```
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0106]: missing lifetime specifier
 --> src/main.rs:9:33
  |
9 | fn longest(x: &str, y: &str) -> &str {
  |               ----     ----     ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`
help: consider introducing a named lifetime parameter
  |
9 | fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
  |           ++++     ++          ++          ++

For more information about this error, try `rustc --explain E0106`.
error: could not compile `chapter10` (bin "chapter10") due to 1 previous error
```

輔助文字揭示了回傳型別需要一個泛型 lifetime 參數，因為 Rust 無法判斷回傳的參照是指向 `x` 還是 `y`。事實上，我們也不知道，因為這個函式主體中的 `if` 區塊回傳 `x` 的參照，而 `else` 區塊回傳 `y` 的參照！

當我們定義這個函式時，我們不知道會傳入這個函式的具體值，所以我們不知道 `if` 情況或 `else` 情況會執行。我們也不知道將傳入的參照的具體 lifetimes，所以我們無法像在清單 10-17 和 10-18 中那樣查看作用域來判斷我們回傳的參照是否總是有效的。borrow checker 也無法判斷這一點，因為它不知道 `x` 和 `y` 的 lifetimes 與回傳值的 lifetime 之間有什麼關係。為了解決這個錯誤，我們將添加泛型 lifetime 參數來定義參照之間的關係，這樣 borrow checker 就可以進行其分析。

### Lifetime 註記語法

Lifetime 註記不會改變任何參照的存活時間。相反地，它們描述了多個參照的 lifetimes 之間的關係，而不影響 lifetimes 本身。就像函式在簽名中指定泛型型別參數時可以接受任何型別一樣，函式可以透過指定泛型 lifetime 參數來接受任何 lifetime 的參照。

Lifetime 註記的語法有點不尋常：lifetime 參數的名稱必須以單引號（`'`）開頭，通常都是小寫且非常短，就像泛型型別一樣。大多數人使用 `'a` 作為第一個 lifetime 註記的名稱。我們將 lifetime 參數註記放在參照的 `&` 之後，用一個空格將註記與參照的型別分開。

這裡有一些例子：一個沒有 lifetime 參數的 `i32` 參照，一個帶有名為 `'a` 的 lifetime 參數的 `i32` 參照，以及一個同樣帶有 lifetime `'a` 的可變 `i32` 參照。

```
&i32        // 一個參照
&'a i32     // 一個帶有明確 lifetime 的參照
&'a mut i32 // 一個帶有明確 lifetime 的可變參照
```

單獨一個 lifetime 註記沒有太大意義，因為註記的目的是告訴 Rust 多個參照的泛型 lifetime 參數之間如何關聯。讓我們在 `longest` 函式的上下文中檢視 lifetime 註記如何相互關聯。

### 函式簽名中的 Lifetime 註記

要在函式簽名中使用 lifetime 註記，我們需要在函式名稱和參數列表之間的角括號內宣告泛型 _lifetime_ 參數，就像我們對泛型 _type_ 參數所做的那樣。

我們希望簽名能夠表達以下約束：回傳的參照只要兩個參數都有效，它就有效。這就是參數和回傳值的 lifetimes 之間的關係。我們將 lifetime 命名為 `'a`，然後將它添加到每個參照中，如清單 10-21 所示。

src/main.rs

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() { x } else { y }
}
```

清單 10-21：`longest` 函式定義，指定簽名中的所有參照都必須具有相同的 lifetime `'a`

這段程式碼應該可以編譯，並且當我們在清單 10-19 的 `main` 函式中使用它時，會產生我們想要的結果。

函式簽名現在告訴 Rust，對於某個 lifetime `'a`，函式接受兩個參數，它們都是至少活得和 lifetime `'a` 一樣長的字串 slice。函式簽名也告訴 Rust，從函式回傳的字串 slice 將至少活得和 lifetime `'a` 一樣長。實際上，這意味著 `longest` 函式回傳的參照的 lifetime 與函式參數所參照的值中較短的 lifetime 相同。這些關係是我們希望 Rust 在分析這段程式碼時使用的。

記住，當我們在這個函式簽名中指定 lifetime 參數時，我們並沒有改變任何傳入或回傳值的 lifetimes。相反地，我們是指定 borrow checker 應該拒絕任何不遵守這些約束的值。請注意，`longest` 函式不需要確切知道 `x` 和 `y` 會活多久，只需要知道某個作用域可以被代入 `'a`，並且會滿足這個簽名。

在函式中註記 lifetimes 時，註記是放在函式簽名中，而不是函式主體中。lifetime 註記成為函式契約的一部分，就像簽名中的型別一樣。讓函式簽名包含 lifetime 契約意味著 Rust 編譯器所做的分析可以更簡單。如果函式的註記方式或呼叫方式有問題，編譯器錯誤可以更精確地指向我們程式碼的部分和約束。如果 Rust 編譯器對我們意圖的 lifetimes 關係做出更多推斷，編譯器可能只能指向離問題根源很遠的程式碼使用處。

當我們將具體的參照傳遞給 `longest` 時，被替換為 `'a` 的具體 lifetime 是 `x` 的作用域與 `y` 的作用域重疊的部分。換句話說，泛型 lifetime `'a` 將會得到等於 `x` 和 `y` lifetimes 中較短者的具體 lifetime。因為我們已經用相同的 lifetime 參數 `'a` 註記了回傳的參照，所以回傳的參照也將在 `x` 和 `y` lifetimes 中較短的那個長度內有效。

讓我們透過傳入具有不同具體 lifetimes 的參照，來看看 lifetime 註記如何限制 `longest` 函式。清單 10-22 是一個直接的例子。

src/main.rs

```rust
fn main() {
    let string1 = String::from("long string is long");

    {
        let string2 = String::from("xyz");
        let result = longest(string1.as_str(), string2.as_str());
        println!("The longest string is {result}");
    }
}
```

清單 10-22：使用 `longest` 函式，其參照的 `String` 值具有不同的具體 lifetimes

在這個例子中，`string1` 在外部作用域結束前都是有效的，`string2` 在內部作用域結束前都是有效的，而 `result` 參照的東西在內部作用域結束前都是有效的。執行這段程式碼，你會看到 borrow checker 會批准它；它會編譯並印出 `The longest string is long string is long`。

接下來，讓我們試一個例子，顯示 `result` 中參照的 lifetime 必須是兩個參數中較短的那個 lifetime。我們將 `result` 變數的宣告移到內部作用域之外，但將值的賦值保留在有 `string2` 的作用域內。然後我們將使用 `result` 的 `println!` 移到內部作用域之外，在內部作用域結束之後。清單 10-23 的程式碼將無法編譯。

src/main.rs

```rust
fn main() {
    let string1 = String::from("long string is long");
    let result;
    {
        let string2 = String::from("xyz");
        result = longest(string1.as_str(), string2.as_str());
    }
    println!("The longest string is {result}");
}
```

清單 10-23：試圖在 `string2` 離開作用域後使用 `result`

當我們嘗試編譯這段程式碼時，會得到這個錯誤：

```
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0597]: `string2` does not live long enough
 --> src/main.rs:6:44
  |
5 |         let string2 = String::from("xyz");
  |             ------- binding `string2` declared here
6 |         result = longest(string1.as_str(), string2.as_str());
  |                                            ^^^^^^^ borrowed value does not live long enough
7 |     }
  |     - `string2` dropped here while still borrowed
8 |     println!("The longest string is {result}");
  |                                     -------- borrow later used here

For more information about this error, try `rustc --explain E0597`.
error: could not compile `chapter10` (bin "chapter10") due to 1 previous error
```

錯誤顯示，為了讓 `result` 在 `println!` 敘述中有效，`string2` 需要在外部作用域結束前都有效。Rust 知道這一點，因為我們用相同的 lifetime 參數 `'a` 註記了函式參數和回傳值的 lifetimes。

作為人類，我們可以看著這段程式碼，看到 `string1` 比 `string2` 長，因此 `result` 將包含一個對 `string1` 的參照。因為 `string1` 還沒有離開作用域，所以對 `string1` 的參照對於 `println!` 敘述仍然是有效的。然而，編譯器在這種情況下無法看到參照是有效的。我們已經告訴 Rust，`longest` 函式回傳的參照的 lifetime 與傳入的參照中較短的 lifetime 相同。因此，borrow checker 不允許清單 10-23 中的程式碼，因為它可能含有無效的參照。

試著設計更多實驗，改變傳入 `longest` 函式的參照的值和 lifetimes，以及回傳的參照是如何被使用的。在你編譯之前，先對你的實驗是否能通過 borrow checker 做出假設；然後檢查你是否猜對了！

### 從 Lifetimes 的角度思考

你需要指定 lifetime 參數的方式取決於你的函式在做什麼。例如，如果我們將 `longest` 函式的實作改為總是回傳第一個參數而不是最長的字串 slice，我們就不需要在 `y` 參數上指定 lifetime。下面的程式碼可以編譯：

src/main.rs

```rust
fn longest<'a>(x: &'a str, y: &str) -> &'a str {
    x
}
```

我們為參數 `x` 和回傳型別指定了 lifetime 參數 `'a`，但沒有為參數 `y` 指定，因為 `y` 的 lifetime 與 `x` 或回傳值的 lifetime 沒有任何關係。

當從函式回傳一個參照時，回傳型別的 lifetime 參數需要與其中一個參數的 lifetime 參數相匹配。如果回傳的參照*不*參照任何一個參數，它就必須參照一個在這個函式內部建立的值。然而，這將會是一個 dangling reference，因為這個值會在函式結束時離開作用域。考慮這個 `longest` 函式的嘗試實作，它將無法編譯：

src/main.rs

```rust
fn longest<'a>(x: &str, y: &str) -> &'a str {
    let result = String::from("really long string");
    result.as_str()
}
```

在這裡，即使我們為回傳型別指定了 lifetime 參數 `'a`，這個實作也將無法編譯，因為回傳值的 lifetime 與參數的 lifetime 完全無關。這是我們得到的錯誤訊息：

```
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0515]: cannot return value referencing local variable `result`
  --> src/main.rs:11:5
   |
11 |     result.as_str()
   |     ------^^^^^^^^^
   |     |
   |     returns a value referencing data owned by the current function
   |     `result` is borrowed here

For more information about this error, try `rustc --explain E0515`.
error: could not compile `chapter10` (bin "chapter10") due to 1 previous error
```

問題在於 `result` 在 `longest` 函式結束時會離開作用域並被清理掉。我們也試圖從函式回傳一個對 `result` 的參照。我們沒有辦法指定 lifetime 參數來改變這個 dangling reference，而 Rust 不會讓我們建立一個 dangling reference。在這種情況下，最好的修正是回傳一個擁有的資料型別而不是一個參照，這樣呼叫函式就負責清理這個值。

總而言之，lifetime 語法是關於連結函式的各種參數和回傳值的 lifetimes。一旦它們被連結起來，Rust 就有足夠的資訊來允許記憶體安全的操作，並禁止會產生 dangling pointers 或以其他方式違反記憶體安全的操作。

### Struct 定義中的 Lifetime 註記

到目前為止，我們定義的 struct 都持有擁有的型別。我們可以定義 struct 來持有參照，但在那種情況下，我們需要在 struct 定義中的每個參照上添加 lifetime 註記。清單 10-24 有一個名為 `ImportantExcerpt` 的 struct，它持有一個字串 slice。

src/main.rs

```rust
struct ImportantExcerpt<'a> {
    part: &'a str,
}

fn main() {
    let novel = String::from("Call me Ishmael. Some years ago...");
    let first_sentence = novel.split('.').next().unwrap();
    let i = ImportantExcerpt {
        part: first_sentence,
    };
}
```

清單 10-24：一個持有參照的 struct，需要 lifetime 註記

這個 struct 有一個單一欄位 `part`，它持有一個字串 slice，也就是一個參照。如同泛型資料型別，我們在 struct 名稱後的角括號內宣告泛型 lifetime 參數的名稱，這樣我們就可以在 struct 定義的主體中使用這個 lifetime 參數。這個註記意味著 `ImportantExcerpt` 的實例不能比它在 `part` 欄位中持有的參照活得更久。

這裡的 `main` 函式建立了一個 `ImportantExcerpt` struct 的實例，它持有一個對 `novel` 變數所擁有的 `String` 的第一句話的參照。`novel` 中的資料在 `ImportantExcerpt` 實例被建立之前就存在。此外，`novel` 在 `ImportantExcerpt` 離開作用域之後才會離開作用域，所以 `ImportantExcerpt` 實例中的參照是有效的。

### Lifetime 省略

你已經學到每個參照都有一個 lifetime，並且你需要為使用參照的函式或 struct 指定 lifetime 參數。然而，我們在清單 4-9 中有一個函式，再次顯示在清單 10-25 中，它在沒有 lifetime 註記的情況下編譯成功了。

src/lib.rs

```rust
fn first_word(s: &str) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..]
}
```

清單 10-25：我們在清單 4-9 中定義的一個函式，即使參數和回傳型別都是參照，也能在沒有 lifetime 註記的情況下編譯成功

這個函式能夠在沒有 lifetime 註記的情況下編譯是有歷史原因的：在 Rust 的早期版本（1.0 之前），這段程式碼是無法編譯的，因為每個參照都需要一個明確的 lifetime。在那個時候，函式簽名會被寫成這樣：

```rust
fn first_word<'a>(s: &'a str) -> &'a str {
```

在撰寫了大量的 Rust 程式碼之後，Rust 團隊發現 Rust 程式設計師在特定情況下會一再地輸入相同的 lifetime 註記。這些情況是可預測的，並且遵循一些確定的模式。開發者將這些模式編寫到編譯器的程式碼中，這樣 borrow checker 就可以在這些情況下推斷 lifetimes，而不需要明確的註記。

這段 Rust 的歷史是相關的，因為未來可能會出現更多確定的模式並被加入到編譯器中。未來，可能需要更少的 lifetime 註記。

被編寫到 Rust 參照分析中的模式稱為 _lifetime elision rules_（lifetime 省略規則）。這些不是程式設計師要遵守的規則；它們是編譯器會考慮的一組特定情況，如果你的程式碼符合這些情況，你就不需要明確地寫出 lifetimes。

省略規則並不提供完全的推斷。如果在 Rust 應用這些規則之後，對於參照的 lifetimes 仍然存在歧義，編譯器不會去猜測剩餘參照的 lifetime 應該是什麼。編譯器不會去猜測，而是會給你一個錯誤，你可以透過添加 lifetime 註記來解決。

函式或方法參數上的 lifetimes 稱為 _input lifetimes_，而回傳值上的 lifetimes 稱為 _output lifetimes_。

編譯器使用三條規則來找出在沒有明確註記時參照的 lifetimes。第一條規則適用於 input lifetimes，第二和第三條規則適用於 output lifetimes。如果編譯器執行完這三條規則後，仍然有無法確定 lifetimes 的參照，編譯器將會停止並報告錯誤。這些規則適用於 `fn` 定義以及 `impl` 區塊。

第一條規則是，編譯器為每個是參照的參數分配一個 lifetime 參數。換句話說，一個帶有一個參數的函式得到一個 lifetime 參數：`fn foo<'a>(x: &'a i32)`；一個帶有兩個參數的函式得到兩個獨立的 lifetime 參數：`fn foo<'a, 'b>(x: &'a i32, y: &'b i32)`；以此類推。

第二條規則是，如果恰好只有一個 input lifetime 參數，那個 lifetime 會被分配給所有 output lifetime 參數：`fn foo<'a>(x: &'a i32) -> &'a i32`。

第三條規則是，如果有多個 input lifetime 參數，但其中一個是 `&self` 或 `&mut self` 因為這是一個方法，`self` 的 lifetime 會被分配給所有 output lifetime 參數。第三條規則使得方法更容易閱讀和撰寫，因為需要的符號更少。

讓我們假裝我們是編譯器。我們將應用這些規則來找出清單 10-25 中 `first_word` 函式簽名中參照的 lifetimes。簽名開始時，參照沒有任何關聯的 lifetimes：

```rust
fn first_word(s: &str) -> &str {
```

然後編譯器應用第一條規則，該規則指定每個參數都有自己的 lifetime。我們照慣例稱之為 `'a`，所以現在簽名是這樣：

```rust
fn first_word<'a>(s: &'a str) -> &str {
```

第二條規則適用，因為恰好只有一個 input lifetime。第二條規則指定一個輸入參數的 lifetime 會被分配給 output lifetime，所以現在簽名是這樣：

```rust
fn first_word<'a>(s: &'a str) -> &'a str {
```

現在這個函式簽名中的所有參照都有了 lifetimes，編譯器可以繼續其分析，而不需要程式設計師在這個函式簽名中註記 lifetimes。

讓我們看另一個例子，這次使用 `longest` 函式，當我們在清單 10-20 中開始處理它時，它沒有 lifetime 參數：

```rust
fn longest(x: &str, y: &str) -> &str {
```

讓我們應用第一條規則：每個參數都有自己的 lifetime。這次我們有兩個參數而不是一個，所以我們有兩個 lifetimes：

```rust
fn longest<'a, 'b>(x: &'a str, y: &'b str) -> &str {
```

你可以看到第二條規則不適用，因為有多個 input lifetime。第三條規則也不適用，因為 `longest` 是一個函式而不是一個方法，所以沒有任何參數是 `self`。在處理完所有三條規則後，我們仍然沒有弄清楚回傳型別的 lifetime 是什麼。這就是為什麼我們在嘗試編譯清單 10-20 的程式碼時會得到一個錯誤：編譯器處理了 lifetime 省略規則，但仍然無法找出簽名中所有參照的 lifetimes。

因為第三條規則實際上只適用於方法簽名，我們接下來將在那個上下文中看 lifetimes，以了解為什麼第三條規則意味著我們不常需要在方法簽名中註記 lifetimes。

### 方法定義中的 Lifetime 註記

當我們在帶有 lifetimes 的 struct 上實作方法時，我們使用的語法與泛型型別參數的語法相同，如清單 10-11 所示。我們在哪裡宣告和使用 lifetime 參數，取決於它們是與 struct 欄位相關，還是與方法參數和回傳值相關。

struct 欄位的 lifetime 名稱總是需要在 `impl` 關鍵字之後宣告，然後在 struct 名稱之後使用，因為那些 lifetimes 是 struct 型別的一部分。

在 `impl` 區塊內的方法簽名中，參照可能與 struct 欄位中參照的 lifetime 相關，也可能是獨立的。此外，lifetime 省略規則常常使得方法簽名中不需要 lifetime 註記。讓我們看一些使用我們在清單 10-24 中定義的 `ImportantExcerpt` struct 的例子。

首先，我們將使用一個名為 `level` 的方法，它唯一的參數是對 `self` 的參照，回傳值是 `i32`，它不是任何東西的參照：

```rust
impl<'a> ImportantExcerpt<'a> {
    fn level(&self) -> i32 {
        3
    }
}
```

`impl` 後的 lifetime 參數宣告及其在型別名稱後的使用是必需的，但由於第一個省略規則，我們不需要註記對 `self` 的參照的 lifetime。

這裡是一個應用第三條 lifetime 省略規則的例子：

```rust
impl<'a> ImportantExcerpt<'a> {
    fn announce_and_return_part(&self, announcement: &str) -> &str {
        println!("Attention please: {announcement}");
        self.part
    }
}
```

有兩個 input lifetimes，所以 Rust 應用第一條 lifetime 省略規則，並給 `&self` 和 `announcement` 各自的 lifetimes。然後，因為其中一個參數是 `&self`，回傳型別會得到 `&self` 的 lifetime，這樣所有的 lifetimes 都被考慮到了。

### 'static Lifetime

我們需要討論一個特殊的 lifetime，那就是 `'static`，它表示受影響的參照*可以*存活於整個程式的執行期間。所有的字串字面值都具有 `'static` lifetime，我們可以這樣註記：

```rust
let s: &'static str = "I have a static lifetime.";
```

這個字串的文本直接儲存在程式的二進位檔中，它總是可用的。因此，所有字串字面值的 lifetime 都是 `'static`。

你可能會在錯誤訊息中看到使用 `'static` lifetime 的建議。但在為一個參照指定 `'static` 作為 lifetime 之前，請思考你所擁有的參照是否真的存活於你的程式的整個 lifetime，以及你是否希望它這樣。大多數時候，建議使用 `'static` lifetime 的錯誤訊息是因為試圖建立一個 dangling reference 或可用的 lifetimes 不匹配所導致的。在這種情況下，解決方案是修正那些問題，而不是指定 `'static` lifetime。

## 泛型型別參數、Trait Bounds 與 Lifetimes 的結合

讓我們簡要地看一下在一個函式中同時指定泛型型別參數、trait bounds 和 lifetimes 的語法！

```rust
use std::fmt::Display;

fn longest_with_an_announcement<'a, T>(
    x: &'a str,
    y: &'a str,
    ann: T,
) -> &'a str
where
    T: Display,
{
    println!("Announcement! {ann}");
    if x.len() > y.len() { x } else { y }
}
```

這是來自清單 10-21 的 `longest` 函式，它回傳兩個字串 slice 中較長的一個。但現在它有一個額外的參數 `ann`，其泛型型別為 `T`，可以由任何實作 `Display` trait 的型別填入，如 `where` 子句所指定。這個額外的參數將使用 `{}` 來印出，這就是為什麼 `Display` trait bound 是必要的。因為 lifetimes 是一種泛型，所以 lifetime 參數 `'a` 和泛型型別參數 `T` 的宣告都放在函式名稱後面的角括號內的同一個列表中。

## 總結

我們在本章中涵蓋了很多內容！現在你已經了解了泛型型別參數、traits 和 trait bounds，以及泛型 lifetime 參數，你已經準備好撰寫沒有重複且能在多種不同情況下運作的程式碼了。泛型型別參數讓你可以將程式碼應用於不同的型別。Traits 和 trait bounds 確保即使型別是泛型的，它們也會有程式碼所需的行為。你學會了如何使用 lifetime 註記來確保這種彈性的程式碼不會有任何 dangling references。而所有這些分析都在編譯時期進行，不會影響執行時期的效能！

信不信由你，我們在本章討論的主題還有更多可以學習的：第 18 章討論 trait objects，這是使用 traits 的另一種方式。還有一些更複雜的涉及 lifetime 註記的情境，你只會在非常進階的情境中需要；對於那些，你應該閱讀位於 <https://doc.rust-lang.org/reference/index.html> 的 Rust Reference。但接下來，你將學習如何在 Rust 中撰寫測試，這樣你就可以確保你的程式碼如預期般運作。
