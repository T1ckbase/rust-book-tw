<!-- DO NOT EDIT THIS FILE.

This file is periodically generated from the content in the `/src/`
directory, so all fixes need to be made in `/src/`.
-->

[TOC]

# 泛型型別、Trait 與生命週期

每種程式語言都備有工具可以有效率地處理概念上的重複。在 Rust 中，其中一種工具就是 _泛型 (generics)_：具體型別或其他屬性的抽象替代品。我們可以表達泛型的行為，或是它們與其他泛型之間的關係，而無須知道在編譯和執行程式碼時會填入什麼。

函數可以接受某些泛型型別的參數，而不是像 `i32` 或 `String` 這樣的具體型別，就像它們接受帶有未知值的參數一樣，以便在多個具體值上執行相同的程式碼。事實上，我們在第 6 章已經使用過 `Option<T>`、在第 8 章使用過 `Vec<T>` 和 `HashMap<K, V>`，以及在第 9 章使用過 `Result<T, E>`。在本章中，你將探索如何定義自己的帶有泛型的型別、函數和方法！

首先，我們將回顧如何提取函數以減少程式碼重複。然後，我們將使用相同的技術，從兩個僅在參數型別上有所不同的函數中，建立一個泛型函數。我們還將解釋如何在 struct 和 enum 定義中使用泛型型別。

然後你將學習如何使用 _trait_ 以泛型的方式定義行為。你可以將 trait 與泛型型別結合使用，將泛型型別限制為只接受那些具有特定行為的型別，而不是任何型別。

最後，我們將討論 _生命週期 (lifetimes)_：一種泛型，它向編譯器提供關於 reference 之間如何關聯的資訊。生命週期讓我們可以向編譯器提供足夠關於 borrowed value 的資訊，以便它可以在比沒有我們幫助的情況下，更多場景中確保 reference 是有效的。

## 透過提取函數來消除重複

泛型讓我們可以用一個代表多種型別的 placeholder 來替代特定型別，以消除程式碼重複。在深入了解泛型語法之前，讓我們先看看如何透過提取一個函數來消除重複，該函數用一個代表多個值的 placeholder 來替代特定值，這種方式不涉及泛型型別。然後我們將應用相同的技術來提取一個泛型函數！透過觀察如何識別可以提取為函數的重複程式碼，你將開始識別可以使用泛型的重複程式碼。

我們從範例 10-1 開始的簡短程式碼，它在列表中找到最大的數字。

src/main.rs

```rust
fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = &number_list[0];

    for number in &number_list {
        if number > largest {
            largest = number;
        }
    }

    println!("The largest number is {largest}");
}
```

範例 10-1：在數字列表中找到最大的數字

我們將整數列表儲存在 `number_list` 變數中，並將列表中第一個數字的 reference 放入名為 `largest` 的變數中。然後我們遍歷列表中的所有數字，如果當前數字大於儲存在 `largest` 中的數字，我們就替換該變數中的 reference。然而，如果當前數字小於或等於目前為止最大的數字，該變數就不會改變，程式碼會繼續處理列表中的下一個數字。考慮完列表中的所有數字後，`largest` 應該指向最大的數字，在本例中是 100。

現在我們被要求在兩個不同的數字列表中找到最大的數字。為此，我們可以選擇複製範例 10-1 中的程式碼，並在程式中兩個不同的地方使用相同的邏輯，如範例 10-2 所示。

src/main.rs

```rust
fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = &number_list[0];

    for number in &number_list {
        if number > largest {
            largest = number;
        }
    }

    println!("The largest number is {largest}");

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let mut largest = &number_list[0];

    for number in &number_list {
        if number > largest {
            largest = number;
        }
    }

    println!("The largest number is {largest}");
}
```

範例 10-2：用於在*兩個*數字列表中查找最大數字的程式碼

儘管這段程式碼可以運作，但重複程式碼既繁瑣又容易出錯。當我們想要更改程式碼時，還必須記住在多個地方更新它。

為了消除這種重複，我們將透過定義一個操作任何作為參數傳入的整數列表的函數來建立一個抽象。這個解決方案使我們的程式碼更清晰，並讓我們能夠抽象地表達在列表中找到最大數字的概念。

在範例 10-3 中，我們將找到最大數字的程式碼提取到一個名為 `largest` 的函數中。然後我們呼叫該函數來查找範例 10-2 中兩個列表中的最大數字。我們也可以將該函數用於將來可能有的任何其他 `i32` 值列表。

src/main.rs

```rust
fn largest(list: &[i32]) -> &i32 {
    let mut largest = &list[0];

    for item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&number_list);
    println!("The largest number is {result}");

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let result = largest(&number_list);
    println!("The largest number is {result}");
}
```

範例 10-3：抽象化程式碼以在兩個列表中找到最大的數字

`largest` 函數有一個名為 `list` 的參數，它代表我們可以傳入函數的任何具體 `i32` 值 slice。因此，當我們呼叫函數時，程式碼會在我們傳入的特定值上執行。

總結來說，我們將範例 10-2 中的程式碼更改為範例 10-3 所採取的步驟如下：

1. 識別重複程式碼。
2. 將重複程式碼提取到函數體中，並在函數簽章中指定該程式碼的輸入和返回值。
3. 將兩個重複的程式碼實例更新為呼叫該函數。

接下來，我們將使用這些相同的步驟與泛型來減少程式碼重複。就像函數體可以操作抽象的 `list` 而不是特定值一樣，泛型允許程式碼操作抽象型別。

例如，假設我們有兩個函數：一個在 `i32` 值 slice 中查找最大項目，另一個在 `char` 值 slice 中查找最大項目。我們將如何消除這種重複呢？讓我們來看看！

## 泛型資料型別

我們使用泛型來建立函數簽章或 struct 等項目的定義，然後可以將其用於許多不同的具體資料型別。讓我們先看看如何使用泛型定義函數、struct、enum 和方法。然後我們將討論泛型如何影響程式碼效能。

### 在函數定義中

在定義使用泛型的函數時，我們將泛型放置在函數簽章中，也就是我們通常指定參數和返回值資料型別的地方。這樣做使我們的程式碼更加靈活，並為我們函數的呼叫者提供更多功能，同時防止程式碼重複。

繼續我們的 `largest` 函數，範例 10-4 顯示了兩個函數，它們都用於在 slice 中查找最大值。然後我們將這些函數組合成一個使用泛型的單一函數。

src/main.rs

```rust
fn largest_i32(list: &[i32]) -> &i32 {
    let mut largest = &list[0];

    for item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn largest_char(list: &[char]) -> &char {
    let mut largest = &list[0];

    for item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest_i32(&number_list);
    println!("The largest number is {result}");

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest_char(&char_list);
    println!("The largest char is {result}");
}
```

範例 10-4：僅名稱和簽章中型別不同的兩個函數

`largest_i32` 函數是我們在範例 10-3 中提取的函數，它在 slice 中查找最大的 `i32`。`largest_char` 函數在 slice 中查找最大的 `char`。函數體有相同的程式碼，所以我們透過在單一函數中引入泛型型別參數來消除重複。

為了在新的單一函數中參數化型別，我們需要命名型別參數，就像我們為函數的值參數所做的那樣。你可以使用任何識別碼作為型別參數名稱。但我們將使用 `T`，因為根據慣例，Rust 中的型別參數名稱很短，通常只有一個字母，而且 Rust 的型別命名慣例是 CamelCase。`T` 是 _type_ 的縮寫，是大多數 Rust 程式設計師的預設選擇。

當我們在函數體中使用參數時，我們必須在簽章中宣告參數名稱，以便編譯器知道該名稱的含義。同樣，當我們在函數簽章中使用型別參數名稱時，我們必須在使用它之前宣告型別參數名稱。為了定義泛型 `largest` 函數，我們將型別名稱宣告放在函數名稱和參數列表之間的角括號 `<>` 內，如下所示：

```rust
fn largest<T>(list: &[T]) -> &T {
```

我們將此定義讀作：函數 `largest` 對某些型別 `T` 來說是泛型的。這個函數有一個名為 `list` 的參數，它是 `T` 型別值的 slice。`largest` 函數將返回一個相同 `T` 型別值的 reference。

範例 10-5 顯示了使用泛型資料型別在簽章中結合 `largest` 函數的定義。此範例還顯示了我們如何使用 `i32` 值或 `char` 值 slice 呼叫該函數。請注意，此程式碼尚無法編譯。

src/main.rs

```rust
fn largest<T>(list: &[T]) -> &T {
    let mut largest = &list[0];

    for item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&number_list);
    println!("The largest number is {result}");

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&char_list);
    println!("The largest char is {result}");
}
```

範例 10-5：使用泛型型別參數的 `largest` 函數；這還不能編譯

如果我們現在編譯此程式碼，我們將得到此錯誤：

```
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0369]: binary operation `>` cannot be applied to type `&T`
 --> src/main.rs:5:17
  |
5 |         if item > largest {
  |            ---- ^ ------- &T
  |            |
  |            &T
  |
help: consider restricting type parameter `T` with trait `PartialOrd`
  |
1 | fn largest<T: std::cmp::PartialOrd>(list: &[T]) -> &T {
  |             ++++++++++++++++++++++

For more information about this error, try `rustc --explain E0369`.
error: could not compile `chapter10` (bin "chapter10") due to 1 previous error
```

幫助文字提到了 `std::cmp::PartialOrd`，這是一個 _trait_，我們將在下一節中討論 trait。現在，要知道這個錯誤表示 `largest` 的函數體不適用於 `T` 可能的任何型別。因為我們想在函數體中比較 `T` 型別的值，我們只能使用其值可以排序的型別。為了啟用比較，標準函式庫提供了 `std::cmp::PartialOrd` trait，你可以在型別上實作它（有關此 trait 的更多資訊，請參閱附錄 C）。為了修正範例 10-5，我們可以遵循幫助文字的建議，將 `T` 的有效型別限制為僅實作 `PartialOrd` 的型別。然後該範例將會編譯，因為標準函式庫在 `i32` 和 `char` 上都實作了 `PartialOrd`。

### 在 Struct 定義中

我們也可以使用 `<>` 語法在一個或多個欄位中定義 struct 以使用泛型型別參數。範例 10-6 定義了一個 `Point<T>` struct 來儲存任何型別的 `x` 和 `y` 座標值。

src/main.rs

```rust
struct Point<T> {
    x: T,
    y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
}
```

範例 10-6：一個 `Point<T>` struct 儲存 `T` 型別的 `x` 和 `y` 值

在 struct 定義中使用泛型的語法與函數定義中使用的語法類似。首先，我們在 struct 名稱之後的角括號內宣告型別參數的名稱。然後我們在 struct 定義中使用泛型型別，否則我們會指定具體資料型別。

請注意，因為我們只使用一個泛型型別來定義 `Point<T>`，所以這個定義表示 `Point<T>` struct 對某個型別 `T` 是泛型的，並且 `x` 和 `y` 欄位*都是*該相同的型別，無論該型別是什麼。如果我們建立一個 `Point<T>` 實例，其值型別不同，如範例 10-7 所示，我們的程式碼將無法編譯。

src/main.rs

```rust
struct Point<T> {
    x: T,
    y: T,
}

fn main() {
    let wont_work = Point { x: 5, y: 4.0 };
}
```

範例 10-7：欄位 `x` 和 `y` 必須是相同型別，因為兩者都具有相同的泛型資料型別 `T`。

在這個範例中，當我們將整數值 `5` 賦值給 `x` 時，我們讓編譯器知道對於這個 `Point<T>` 實例，泛型型別 `T` 將是一個整數。然後當我們為 `y` 指定 `4.0` 時，我們已將其定義為與 `x` 相同的型別，我們將得到一個型別不匹配錯誤，如下所示：

```
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0308]: mismatched types
 --> src/main.rs:7:38
  |
7 |     let wont_work = Point { x: 5, y: 4.0 };
  |                                      ^^^ expected integer, found floating-point number

For more information about this error, try `rustc --explain E0308`.
error: could not compile `chapter10` (bin "chapter10") due to 1 previous error
```

為了定義一個 `Point` struct，其中 `x` 和 `y` 都是泛型但可以具有不同的型別，我們可以使用多個泛型型別參數。例如，在範例 10-8 中，我們將 `Point` 的定義更改為對型別 `T` 和 `U` 泛型，其中 `x` 是型別 `T`，`y` 是型別 `U`。

src/main.rs

```rust
struct Point<T, U> {
    x: T,
    y: U,
}

fn main() {
    let both_integer = Point { x: 5, y: 10 };
    let both_float = Point { x: 1.0, y: 4.0 };
    let integer_and_float = Point { x: 5, y: 4.0 };
}
```

範例 10-8：一個 `Point<T, U>` 對兩種型別泛型，因此 `x` 和 `y` 可以是不同型別的值

現在所有顯示的 `Point` 實例都允許了！你可以根據需要，在定義中使用任意數量的泛型型別參數，但使用超過幾個會使你的程式碼難以閱讀。如果你發現你的程式碼需要大量的泛型型別，這可能表示你的程式碼需要重構為更小的片段。

### 在 Enum 定義中

如同 struct 一樣，我們可以定義 enum 以在其 variant 中包含泛型資料型別。讓我們再次看看標準函式庫提供的 `Option<T>` enum，我們在第 6 章使用過它：

```rust
enum Option<T> {
    Some(T),
    None,
}
```

這個定義現在對你來說應該更有意義了。如你所見，`Option<T>` enum 是對型別 `T` 泛型的，它有兩個 variant：`Some`，它包含一個 `T` 型別的值；以及 `None` variant，它不包含任何值。透過使用 `Option<T>` enum，我們可以表達選擇性值的抽象概念，而且因為 `Option<T>` 是泛型的，無論選擇性值的型別是什麼，我們都可以使用這個抽象。

Enum 也可以使用多個泛型型別。我們在第 9 章使用過的 `Result` enum 的定義就是一個例子：

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

`Result` enum 對兩種型別 `T` 和 `E` 來說是泛型的，它有兩個 variant：`Ok`，它包含一個 `T` 型別的值；以及 `Err`，它包含一個 `E` 型別的值。這個定義使得在任何可能成功（返回某種型別 `T` 的值）或失敗（返回某種型別 `E` 的錯誤）的操作中使用 `Result` enum 都很方便。事實上，這正是我們在範例 9-3 中用於開啟檔案的內容，其中當檔案成功開啟時 `T` 被填入了 `std::fs::File` 型別，而當開啟檔案出現問題時 `E` 被填入了 `std::io::Error` 型別。

當你識別出程式碼中有多個 struct 或 enum 定義僅在它們所包含的值型別上有所不同時，你可以透過使用泛型型別來避免重複。

### 在方法定義中

我們可以為 struct 和 enum 實作方法（如我們在第 5 章所做的），並在其定義中也使用泛型型別。範例 10-9 顯示了我們在範例 10-6 中定義的 `Point<T>` struct，並實作了一個名為 `x` 的方法。

src/main.rs

```rust
struct Point<T> {
    x: T,
    y: T,
}

impl<T> Point<T> {
    fn x(&self) -> &T {
        &self.x
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };

    println!("p.x = {}", p.x());
}
```

範例 10-9：在 `Point<T>` struct 上實作一個名為 `x` 的方法，它將返回 `T` 型別的 `x` 欄位的 reference

在這裡，我們在 `Point<T>` 上定義了一個名為 `x` 的方法，該方法返回對欄位 `x` 中資料的 reference。

請注意，我們必須在 `impl` 之後宣告 `T`，這樣我們才能使用 `T` 來指定我們正在為 `Point<T>` 型別實作方法。透過在 `impl` 之後將 `T` 宣告為泛型型別，Rust 可以識別出 `Point` 中角括號內的型別是一個泛型型別，而不是一個具體型別。我們本來可以為這個泛型參數選擇與 struct 定義中宣告的泛型參數不同的名稱，但使用相同的名稱是慣例。如果你在 `impl` 中編寫一個宣告泛型型別的方法，該方法將在該型別的任何實例上定義，無論最終替換泛型型別的是什麼具體型別。

我們也可以在定義型別上的方法時對泛型型別施加限制。例如，我們只能在 `Point<f32>` 實例上實作方法，而不是在具有任何泛型型別的 `Point<T>` 實例上。在範例 10-10 中，我們使用具體型別 `f32`，這表示我們不在 `impl` 之後宣告任何型別。

src/main.rs

```rust
impl Point<f32> {
    fn distance_from_origin(&self) -> f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
```

範例 10-10：一個 `impl` 區塊，僅適用於其泛型型別參數 `T` 具有特定具體型別的 struct

這段程式碼表示 `Point<f32>` 型別將具有 `distance_from_origin` 方法；其他 `Point<T>` 實例（其中 `T` 不是 `f32` 型別）將不定義此方法。該方法測量我們的點與坐標 (0.0, 0.0) 處的點之間的距離，並使用僅適用於浮點型別的數學運算。

struct 定義中的泛型型別參數與你在同一 struct 的方法簽章中使用的泛型型別參數並不總是相同。範例 10-11 使用泛型型別 `X1` 和 `Y1` 用於 `Point` struct，並使用 `X2` `Y2` 用於 `mixup` 方法簽章，以使範例更清晰。該方法創建一個新的 `Point` 實例，其中 `x` 值來自 `self` `Point`（型別 `X1`），`y` 值來自傳入的 `Point`（型別 `Y2`）。

src/main.rs

```rust
struct Point<X1, Y1> {
    x: X1,
    y: Y1,
}

impl<X1, Y1> Point<X1, Y1> {
    fn mixup<X2, Y2>(self, other: Point<X2, Y2>) -> Point<X1, Y2> {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: "Hello", y: 'c' };

    let p3 = p1.mixup(p2);

    println!("p3.x = {}, p3.y = {}", p3.x, p3.y);
}
```

範例 10-11：一個使用與其 struct 定義不同的泛型型別的方法

在 `main` 函數中，我們定義了一個 `Point`，其 `x` 是一個 `i32`（值為 `5`），`y` 是一個 `f64`（值為 `10.4`）。`p2` 變數是一個 `Point` struct，其 `x` 是一個字串 slice（值為 `"Hello"`），`y` 是一個 `char`（值為 `c`）。在 `p1` 上呼叫 `mixup` 並傳入 `p2` 作為參數，我們得到了 `p3`，其 `x` 將是一個 `i32`，因為 `x` 來自 `p1`。`p3` 變數的 `y` 將是一個 `char`，因為 `y` 來自 `p2`。`println!` 巨集呼叫將會印出 `p3.x = 5, p3.y = c`。

這個範例的目的是展示一種情況，其中一些泛型參數在 `impl` 中宣告，而另一些則在方法定義中宣告。在這裡，泛型參數 `X1` 和 `Y1` 在 `impl` 之後宣告，因為它們與 struct 定義相關。泛型參數 `X2` 和 `Y2` 在 `fn mixup` 之後宣告，因為它們僅與該方法相關。

### 使用泛型的程式碼效能

你可能想知道使用泛型型別參數是否有執行時成本。好消息是，使用泛型型別不會讓你的程式碼比使用具體型別運行得更慢。

Rust 透過在編譯時對使用泛型的程式碼執行單態化 (monomorphization) 來實現這一點。_單態化_ 是將泛型程式碼轉換為特定程式碼的過程，方法是在編譯時填入所使用的具體型別。在此過程中，編譯器執行與我們在範例 10-5 中建立泛型函數所使用的步驟相反的操作：編譯器查看所有呼叫泛型程式碼的地方，並為呼叫泛型程式碼的具體型別產生程式碼。

讓我們看看這是如何運作的，使用標準函式庫的泛型 `Option<T>` enum：

```rust
let integer = Some(5);
let float = Some(5.0);
```

當 Rust 編譯這段程式碼時，它會執行單態化。在這個過程中，編譯器會讀取 `Option<T>` 實例中使用的值，並識別出兩種 `Option<T>`：一種是 `i32`，另一種是 `f64`。因此，它會將 `Option<T>` 的泛型定義展開成兩個專門針對 `i32` 和 `f64` 的定義，從而用具體的定義替換泛型定義。

程式碼的單態化版本看起來與以下類似（編譯器使用的名稱與我們這裡為說明目的使用的不同）：

src/main.rs

```rust
enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let integer = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
}
```

泛型 `Option<T>` 被編譯器建立的具體定義取代。由於 Rust 將泛型程式碼編譯成在每個實例中指定型別的程式碼，因此我們使用泛型沒有執行時成本。當程式碼執行時，它的效能就像我們手動複製每個定義一樣。單態化的過程使 Rust 的泛型在執行時非常高效。

## Trait：定義共享行為

_trait_ 定義了特定型別所擁有的功能，並且可以與其他型別共享。我們可以使用 trait 以抽象的方式定義共享行為。我們可以使用 _trait bound_ 來指定泛型型別可以是任何具有特定行為的型別。

> 注意：Trait 類似於其他語言中常稱為 _interface_ 的功能，儘管有一些差異。

### 定義 Trait

型別的行為由我們可以對該型別呼叫的方法組成。如果我們可以對所有這些型別呼叫相同的方法，那麼不同的型別就共享相同的行為。Trait 定義是一種將方法簽章組合在一起，以定義完成某個目的所需的一組行為的方式。

例如，假設我們有多個 struct 包含不同種類和數量的文字：一個 `NewsArticle` struct，它包含在特定位置提交的新聞故事；以及一個 `SocialPost`，它最多可以有 280 個字元以及指示它是新貼文、轉發還是回覆其他貼文的 metadata。

我們想要建立一個名為 `aggregator` 的媒體聚合函式庫 crate，它可以顯示可能儲存在 `NewsArticle` 或 `SocialPost` 實例中的資料摘要。為此，我們需要從每種型別中獲取一個摘要，我們將透過呼叫實例上的 `summarize` 方法來請求該摘要。範例 10-12 顯示了一個公共 `Summary` trait 的定義，它表達了這種行為。

src/lib.rs

```rust
pub trait Summary {
    fn summarize(&self) -> String;
}
```

範例 10-12：一個由 `summarize` 方法提供的行為組成的 `Summary` trait

在這裡，我們使用 `trait` 關鍵字宣告一個 trait，然後是 trait 的名稱，在本例中是 `Summary`。我們也將 trait 宣告為 `pub`，這樣依賴此 crate 的 crate 也可以使用此 trait，我們將在幾個範例中看到。在花括號內，我們宣告了描述實作此 trait 的型別行為的方法簽章，在本例中是 `fn summarize(&self) -> String`。

在方法簽章之後，我們使用分號而不是在花括號內提供實作。每個實作此 trait 的型別都必須提供自己的自訂方法體行為。編譯器將強制任何具有 `Summary` trait 的型別都必須精確地定義帶有此簽章的 `summarize` 方法。

一個 trait 可以在其主體中有多個方法：方法簽章每行列出一個，並且每行以分號結尾。

### 在型別上實作 Trait

現在我們已經定義了 `Summary` trait 方法所需的簽章，我們可以在我們的媒體聚合器中將其實作在型別上。範例 10-13 顯示了在 `NewsArticle` struct 上實作 `Summary` trait 的範例，該實作使用標題、作者和位置來建立 `summarize` 的返回值。對於 `SocialPost` struct，我們將 `summarize` 定義為用戶名後跟貼文的全部文字，假設貼文內容已經限制為 280 個字元。

src/lib.rs

```rust
pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {
    fn summarize(&self) -> String {
        format!("{}, by {} ({})", self.headline, self.author, self.location)
    }
}

pub struct SocialPost {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub repost: bool,
}

impl Summary for SocialPost {
    fn summarize(&self) -> String {
        format!("{}: {}", self.username, self.content)
    }
}
```

範例 10-13：在 `NewsArticle` 和 `SocialPost` 型別上實作 `Summary` trait

在型別上實作 trait 類似於實作常規方法。不同之處在於，在 `impl` 之後，我們放置要實作的 trait 名稱，然後使用 `for` 關鍵字，然後指定要為其實作 trait 的型別名稱。在 `impl` 區塊內，我們放置 trait 定義已定義的方法簽章。我們不為每個簽章後加上分號，而是使用花括號並填入方法體，其中包含我們希望該 trait 的方法針對特定型別擁有的特定行為。

現在函式庫已經在 `NewsArticle` 和 `SocialPost` 上實作了 `Summary` trait，這個 crate 的使用者可以像呼叫常規方法一樣，在 `NewsArticle` 和 `SocialPost` 的實例上呼叫 trait 方法。唯一的區別是使用者必須將 trait 和型別都引入作用域。以下是一個二進位 crate 如何使用我們的 `aggregator` 函式庫 crate 的範例：

```rust
use aggregator::{SocialPost, Summary};

fn main() {
    let post = SocialPost {
        username: String::from("horse_ebooks"),
        content: String::from(
            "of course, as you probably already know, people",
        ),
        reply: false,
        repost: false,
    };

    println!("1 new post: {}", post.summarize());
}
```

這段程式碼印出 `1 new post: horse_ebooks: of course, as you probably already know, people`。

其他依賴 `aggregator` crate 的 crate 也可以將 `Summary` trait 引入作用域，以便在它們自己的型別上實作 `Summary`。需要注意的一個限制是，我們只能在 trait 或型別（或兩者）本地於我們的 crate 時，才能在型別上實作 trait。例如，我們可以在我們的 `aggregator` crate 功能中，在自訂型別（如 `SocialPost`）上實作 `Display` 等標準函式庫 trait，因為 `SocialPost` 型別本地於我們的 `aggregator` crate。我們也可以在我們的 `aggregator` crate 中為 `Vec<T>` 實作 `Summary`，因為 `Summary` trait 本地於我們的 `aggregator` crate。

但我們無法在外部型別上實作外部 trait。例如，我們無法在我們的 `aggregator` crate 中為 `Vec<T>` 實作 `Display` trait，因為 `Display` 和 `Vec<T>` 都在標準函式庫中定義，並且不本地於我們的 `aggregator` crate。此限制是稱為 _一致性 (coherence)_ 屬性的一部分，更具體地說是 _孤兒規則 (orphan rule)_，之所以這樣命名是因為父型別不存在。此規則確保其他人的程式碼不會破壞你的程式碼，反之亦然。如果沒有此規則，兩個 crate 可能會為相同的型別實作相同的 trait，而 Rust 將不知道要使用哪種實作。

### 預設實作

有時候，對 trait 中的部分或所有方法提供預設行為是很有用的，而不是要求為每個型別的所有方法都提供實作。這樣，當我們在特定型別上實作 trait 時，我們可以保留或覆寫每個方法的預設行為。

在範例 10-14 中，我們為 `Summary` trait 的 `summarize` 方法指定了一個預設字串，而不是像範例 10-12 那樣只定義方法簽章。

src/lib.rs

```rust
pub trait Summary {
    fn summarize(&self) -> String {
        String::from("(Read more...)")
    }
}
```

範例 10-14：定義一個帶有 `summarize` 方法預設實作的 `Summary` trait

為了使用預設實作來摘要 `NewsArticle` 的實例，我們使用 `impl Summary for NewsArticle {}` 指定一個空的 `impl` 區塊。

即使我們不再直接在 `NewsArticle` 上定義 `summarize` 方法，我們也提供了一個預設實作，並指定 `NewsArticle` 實作 `Summary` trait。因此，我們仍然可以在 `NewsArticle` 的實例上呼叫 `summarize` 方法，如下所示：

```rust
    let article = NewsArticle {
        headline: String::from("Penguins win the Stanley Cup Championship!"),
        location: String::from("Pittsburgh, PA, USA"),
        author: String::from("Iceburgh"),
        content: String::from(
            "The Pittsburgh Penguins once again are the best \
             hockey team in the NHL.",
        ),
    };

    println!("New article available! {}", article.summarize());
```

這段程式碼印出 `New article available! (Read more...)`。

建立預設實作不需要我們更改範例 10-13 中 `SocialPost` 上 `Summary` 實作的任何內容。原因在於覆寫預設實作的語法與實作沒有預設實作的 trait 方法的語法相同。

預設實作可以呼叫同一個 trait 中的其他方法，即使這些其他方法沒有預設實作。這樣，一個 trait 就可以提供許多有用的功能，而只要求實作者指定其中一小部分。例如，我們可以將 `Summary` trait 定義為具有一個需要實作的 `summarize_author` 方法，然後定義一個具有預設實作的 `summarize` 方法，該方法會呼叫 `summarize_author` 方法：

```rust
pub trait Summary {
    fn summarize_author(&self) -> String;

    fn summarize(&self) -> String {
        format!("(Read more from {}...)", self.summarize_author())
    }
}
```

要使用這個版本的 `Summary`，我們只需要在我們為型別實作該 trait 時定義 `summarize_author`：

```rust
impl Summary for SocialPost {
    fn summarize_author(&self) -> String {
        format!("@{}", self.username)
    }
}
```

在我們定義了 `summarize_author` 之後，我們可以在 `SocialPost` struct 的實例上呼叫 `summarize`，`summarize` 的預設實作將呼叫我們提供的 `summarize_author` 定義。因為我們已經實作了 `summarize_author`，所以 `Summary` trait 賦予了我們 `summarize` 方法的行為，而無須我們編寫任何額外的程式碼。以下是它的樣子：

```rust
    let post = SocialPost {
        username: String::from("horse_ebooks"),
        content: String::from(
            "of course, as you probably already know, people",
        ),
        reply: false,
        repost: false,
    };

    println!("1 new post: {}", post.summarize());
```

這段程式碼印出 `1 new post: (Read more from @horse_ebooks...)`。

請注意，無法從同一方法的覆寫實作中呼叫預設實作。

### 將 Trait 作為參數

現在你已經知道如何定義和實作 trait，我們可以探索如何使用 trait 來定義接受許多不同型別的函數。我們將使用我們在範例 10-13 中在 `NewsArticle` 和 `SocialPost` 型別上實作的 `Summary` trait 來定義一個 `notify` 函數，該函數在其 `item` 參數上呼叫 `summarize` 方法，`item` 參數是實作 `Summary` trait 的某種型別。為此，我們使用 `impl Trait` 語法，如下所示：

```rust
pub fn notify(item: &impl Summary) {
    println!("Breaking news! {}", item.summarize());
}
```

我們為 `item` 參數指定了 `impl` 關鍵字和 trait 名稱，而不是具體型別。此參數接受任何實作指定 trait 的型別。在 `notify` 的主體中，我們可以呼叫 `item` 上來自 `Summary` trait 的任何方法，例如 `summarize`。我們可以呼叫 `notify` 並傳入 `NewsArticle` 或 `SocialPost` 的任何實例。如果使用任何其他型別（例如 `String` 或 `i32`）呼叫該函數，則程式碼將無法編譯，因為這些型別未實作 `Summary`。

<!-- Old headings. Do not remove or links may break. -->

<a id="fixing-the-largest-function-with-trait-bounds"></a>

#### Trait Bound 語法

`impl Trait` 語法適用於直接情況，但實際上它是稱為 _trait bound_ 的較長形式的語法糖；它看起來像這樣：

```rust
pub fn notify<T: Summary>(item: &T) {
    println!("Breaking news! {}", item.summarize());
}
```

這個較長的形式與前一節的範例等效，但更冗長。我們將 trait bound 與泛型型別參數的宣告一起放置在冒號之後和角括號內。

`impl Trait` 語法方便且在簡單情況下使程式碼更簡潔，而更完整的 trait bound 語法可以在其他情況下表達更多複雜性。例如，我們可以有兩個實作 `Summary` 的參數。使用 `impl Trait` 語法看起來像這樣：

```rust
pub fn notify(item1: &impl Summary, item2: &impl Summary) {
```

如果我們希望此函數允許 `item1` 和 `item2` 具有不同的型別（只要兩種型別都實作 `Summary`），則使用 `impl Trait` 是適當的。但是，如果我們希望強制兩個參數具有相同的型別，我們必須使用 trait bound，如下所示：

```rust
pub fn notify<T: Summary>(item1: &T, item2: &T) {
```

指定為 `item1` 和 `item2` 參數型別的泛型型別 `T` 限制了函數，使得作為 `item1` 和 `item2` 參數傳遞的值的具體型別必須相同。

#### 使用 + 語法指定多個 Trait Bound

我們也可以指定多個 trait bound。假設我們希望 `notify` 在 `item` 上使用顯示格式和 `summarize`：我們在 `notify` 定義中指定 `item` 必須實作 `Display` 和 `Summary`。我們可以透過 `+` 語法來做到這一點：

```rust
pub fn notify(item: &(impl Summary + Display)) {
```

`+` 語法也適用於泛型型別上的 trait bound：

```rust
pub fn notify<T: Summary + Display>(item: &T) {
```

透過指定這兩個 trait bound，`notify` 的函數體可以呼叫 `summarize` 並使用 `{}` 來格式化 `item`。

#### 使用 where 子句讓 Trait Bound 更清晰

使用過多的 trait bound 有其缺點。每個泛型都有自己的 trait bound，因此具有多個泛型型別參數的函數可能在函數名稱和參數列表之間包含大量的 trait bound 資訊，使得函數簽章難以閱讀。因此，Rust 提供了另一種語法，用於在函數簽章後的 `where` 子句中指定 trait bound。所以，與其這樣寫：

```rust
fn some_function<T: Display + Clone, U: Clone + Debug>(t: &T, u: &U) -> i32 {
```

我們可以使用 `where` 子句，如下所示：

```rust
fn some_function<T, U>(t: &T, u: &U) -> i32
where
    T: Display + Clone,
    U: Clone + Debug,
{
```

這個函數的簽章較不雜亂：函數名稱、參數列表和回傳型別緊密排列，類似於沒有許多 trait bound 的函數。

### 回傳實作 Trait 的型別

我們也可以在回傳位置使用 `impl Trait` 語法來回傳實作 trait 的某種型別的值，如下所示：

```rust
fn returns_summarizable() -> impl Summary {
    SocialPost {
        username: String::from("horse_ebooks"),
        content: String::from(
            "of course, as you probably already know, people",
        ),
        reply: false,
        repost: false,
    }
}
```

透過對回傳型別使用 `impl Summary`，我們指定 `returns_summarizable` 函數回傳某種實作 `Summary` trait 的型別，而無需命名具體型別。在本例中，`returns_summarizable` 回傳一個 `SocialPost`，但呼叫此函數的程式碼不需要知道這一點。

僅透過其所實作的 trait 來指定回傳型別的能力在閉包 (closure) 和迭代器 (iterator) 的情境中特別有用，我們將在第 13 章中介紹這些內容。閉包和迭代器會建立只有編譯器知道的型別，或是非常長的型別。`impl Trait` 語法讓你能夠簡潔地指定函數回傳某個實作 `Iterator` trait 的型別，而無需寫出非常長的型別。

然而，你只能在回傳單一型別時使用 `impl Trait`。例如，這段程式碼回傳 `NewsArticle` 或 `SocialPost`，且回傳型別指定為 `impl Summary`，將無法運作：

```rust
fn returns_summarizable(switch: bool) -> impl Summary {
    if switch {
        NewsArticle {
            headline: String::from(
                "Penguins win the Stanley Cup Championship!",
            ),
            location: String::from("Pittsburgh, PA, USA"),
            author: String::from("Iceburgh"),
            content: String::from(
                "The Pittsburgh Penguins once again are the best \
                 hockey team in the NHL.",
            ),
        }
    } else {
        SocialPost {
            username: String::from("horse_ebooks"),
            content: String::from(
                "of course, as you probably already know, people",
            ),
            reply: false,
            repost: false,
        }
    }
}
```

由於 `impl Trait` 語法在編譯器中的實作限制，不允許回傳 `NewsArticle` 或 `SocialPost`。我們將在第 18 章的「[使用允許不同型別值的 Trait Object](https://doc.rust-lang.org/book/ch18-03-pattern-syntax.html#using-trait-objects-that-allow-for-values-of-different-types)」一節中介紹如何編寫具有此行為的函數。

### 使用 Trait Bound 有條件地實作方法

透過將 trait bound 與使用泛型型別參數的 `impl` 區塊結合使用，我們可以為實作指定 trait 的型別有條件地實作方法。例如，範例 10-15 中的型別 `Pair<T>` 總是實作 `new` 函數以回傳 `Pair<T>` 的新實例（回顧第 5 章「[定義方法](https://doc.rust-lang.org/book/ch05-03-method-syntax.html#defining-methods)」一節，`Self` 是 `impl` 區塊型別的型別別名，在本例中是 `Pair<T>`）。但在下一個 `impl` 區塊中，`Pair<T>` 僅在其內部型別 `T` 實作啟用比較的 `PartialOrd` trait *和*啟用列印的 `Display` trait 時才實作 `cmp_display` 方法。

src/lib.rs

```rust
use std::fmt::Display;

struct Pair<T> {
    x: T,
    y: T,
}

impl<T> Pair<T> {
    fn new(x: T, y: T) -> Self {
        Self { x, y }
    }
}

impl<T: Display + PartialOrd> Pair<T> {
    fn cmp_display(&self) {
        if self.x >= self.y {
            println!("The largest member is x = {}", self.x);
        } else {
            println!("The largest member is y = {}", self.y);
        }
    }
}
```

範例 10-15：根據 trait bound 有條件地實作泛型型別上的方法

我們也可以為任何實作另一個 trait 的型別有條件地實作一個 trait。在滿足 trait bound 的任何型別上實作 trait 稱為 _blanket implementation_，並在 Rust 標準函式庫中廣泛使用。例如，標準函式庫在任何實作 `Display` trait 的型別上實作 `ToString` trait。標準函式庫中的 `impl` 區塊類似於以下程式碼：

```rust
impl<T: Display> ToString for T {
    // --snip--
}
```

由於標準函式庫具有這種 blanket implementation，我們可以在任何實作 `Display` trait 的型別上呼叫由 `ToString` trait 定義的 `to_string` 方法。例如，我們可以將整數轉換為其對應的 `String` 值，如下所示，因為整數實作了 `Display`：

```rust
let s = 3.to_string();
```

Blanket implementation 會顯示在 trait 的文件中的「Implementors」一節。

Trait 和 trait bound 讓程式設計師可以編寫使用泛型型別參數的程式碼，以減少重複，同時也向編譯器指定我們希望泛型型別具有特定行為。然後編譯器可以使用 trait bound 資訊來檢查我們程式碼中使用的所有具體型別是否提供了正確的行為。在動態型別語言中，如果我們在未定義該方法的型別上呼叫該方法，我們將在執行時收到錯誤。但 Rust 將這些錯誤移至編譯時，因此我們被迫在程式碼運行之前修復問題。此外，我們不必編寫在執行時檢查行為的程式碼，因為我們已經在編譯時檢查過了。這樣做可以在不犧牲泛型靈活性的情況下提高效能。

## 使用生命週期驗證 Reference

生命週期 (lifetimes) 是我們已經在使用的一種泛型。它們不是為了確保型別具有我們想要的行為，而是為了確保 reference 在我們需要它們有效時保持有效。

我們在第 4 章「[Reference 與 Borrowing](https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html)」一節中沒有討論的一個細節是，Rust 中的每個 reference 都具有一個 _生命週期_，這是該 reference 有效的作用域。大多數時候，生命週期是隱式且推斷的，就像大多數時候型別是被推斷的一樣。我們只在有多種型別可能時才需要註解型別。類似地，當 reference 的生命週期可能以幾種不同的方式相關時，我們必須註解生命週期。Rust 要求我們使用泛型生命週期參數來註解這些關係，以確保在執行時使用的實際 reference 絕對有效。

註解生命週期甚至不是大多數其他程式語言所擁有的概念，所以這會讓人感到陌生。儘管我們不會在本章中完整涵蓋生命週期，但我們會討論你可能遇到生命週期語法的常見方式，以便你熟悉這個概念。

### 使用生命週期防止懸空 Reference

生命週期的主要目的是防止 _懸空 reference (dangling references)_，這會導致程式引用與其預期引用數據不同的數據。考慮範例 10-16 中的程式，它有一個外部作用域和一個內部作用域。

```rust
fn main() {
    let r;

    {
        let x = 5;
        r = &x;
    }

    println!("r: {r}");
}
```

範例 10-16：試圖使用其值已超出作用域的 reference

> 注意：範例 10-16、10-17 和 10-23 中的範例宣告變數時沒有給予初始值，因此變數名稱存在於外部作用域中。乍看之下，這可能與 Rust 沒有 null 值相衝突。然而，如果我們嘗試在使用變數之前沒有給予它值，我們將會得到一個編譯時錯誤，這表明 Rust 確實不允許 null 值。

外部作用域宣告了一個名為 `r` 的變數，沒有初始值，而內部作用域宣告了一個名為 `x` 的變數，初始值為 `5`。在內部作用域內，我們試圖將 `r` 的值設定為 `x` 的 reference。然後內部作用域結束，我們試圖印出 `r` 中的值。這段程式碼無法編譯，因為 `r` 引用的值在我們嘗試使用它之前就已經超出作用域了。以下是錯誤訊息：

```
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0597]: `x` does not live long enough
 --> src/main.rs:6:13
  |
5 |         let x = 5;
  |             - binding `x` declared here
6 |         r = &x;
  |             ^^ borrowed value does not live long enough
7 |     }
  |     - `x` dropped here while still borrowed
8 |
9 |     println!("r: {r}");
  |                  --- borrow later used here

For more information about this error, try `rustc --explain E0597`.
error: could not compile `chapter10` (bin "chapter10") due to 1 previous error
```

錯誤訊息說變數 `x`「壽命不夠長」。原因在於當內部作用域在第 7 行結束時，`x` 將超出作用域。但是 `r` 對於外部作用域仍然有效；因為其作用域更大，我們說它「活得更久」。如果 Rust 允許這段程式碼運作，那麼當 `x` 超出作用域時，`r` 將會引用已被釋放的記憶體，並且我們試圖用 `r` 做的任何事情都不會正確運作。那麼 Rust 如何判斷這段程式碼是無效的呢？它使用 borrow checker。

### Borrow Checker

Rust 編譯器有一個 _borrow checker_，它會比較作用域以確定所有 borrow 是否有效。範例 10-17 顯示了與範例 10-16 相同的程式碼，但帶有顯示變數生命週期的註解。

```rust
fn main() {
    let r;                // ---------+-- 'a
                          //          |
    {                     //          |
        let x = 5;        // -+-- 'b  |
        r = &x;           //  |       |
    }                     // -+       |
                          //          |
    println!("r: {r}");   //          |
}                         // ---------+
```

範例 10-17：`r` 和 `x` 的生命週期註解，分別命名為 `'a` 和 `'b`

在這裡，我們用 `'a` 註解了 `r` 的生命週期，用 `'b` 註解了 `x` 的生命週期。如你所見，內部 `'b` 區塊比外部 `'a` 生命週期區塊小得多。在編譯時，Rust 比較兩個生命週期的大小，並看到 `r` 的生命週期是 `'a`，但它引用了生命週期為 `'b` 的記憶體。程式被拒絕，因為 `'b` 比 `'a` 短：reference 的主題壽命沒有 reference 長。

範例 10-18 修正了程式碼，使其沒有懸空 reference，並且在沒有任何錯誤的情況下編譯。

```rust
fn main() {
    let x = 5;            // ----------+-- 'b
                          //           |
    let r = &x;           // --+-- 'a  |
                          //   |       |
    println!("r: {r}");   //   |       |
                          // --+       |
}                         // ----------+
```

範例 10-18：一個有效的 reference，因為資料的生命週期比 reference 長

在這裡，`x` 的生命週期是 `'b`，在本例中比 `'a` 長。這表示 `r` 可以引用 `x`，因為 Rust 知道 `r` 中的 reference 在 `x` 有效時將始終有效。

現在你已經知道 reference 的生命週期在哪裡，以及 Rust 如何分析生命週期以確保 reference 始終有效，讓我們在函數的上下文中探索參數和返回值的泛型生命週期。

### 函數中的泛型生命週期

我們將編寫一個函數，它返回兩個字串 slice 中較長的一個。這個函數將接受兩個字串 slice 並返回一個字串 slice。在我們實作 `longest` 函數後，範例 10-19 中的程式碼應該會印出 `The longest string is abcd`。

src/main.rs

```rust
fn main() {
    let string1 = String::from("abcd");
    let string2 = "xyz";

    let result = longest(string1.as_str(), string2);
    println!("The longest string is {result}");
}
```

範例 10-19：一個呼叫 `longest` 函數以查找兩個字串 slice 中較長的一個的 `main` 函數

請注意，我們希望函數接受字串 slice（它們是 reference），而不是字串，因為我們不希望 `longest` 函數取得其參數的所有權。有關範例 10-19 中使用的參數為何是我們想要的更多討論，請參閱第 4 章的「[字串 slice 作為參數](https://doc.rust-lang.org/book/ch04-03-slices.html#string-slices-as-parameters)」一節。

如果我們嘗試實作範例 10-20 中所示的 `longest` 函數，它將無法編譯。

src/main.rs

```rust
fn longest(x: &str, y: &str) -> &str {
    if x.len() > y.len() { x } else { y }
}
```

範例 10-20：`longest` 函數的一個實作，它返回兩個字串 slice 中較長的一個，但尚未編譯

相反，我們會得到以下關於生命週期的錯誤：

```
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0106]: missing lifetime specifier
 --> src/main.rs:9:33
  |
9 | fn longest(x: &str, y: &str) -> &str {
  |               ----     ----     ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`
help: consider introducing a named lifetime parameter
  |
9 | fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
  |           ++++     ++          ++          ++

For more information about this error, try `rustc --explain E0106`.
error: could not compile `chapter10` (bin "chapter10") due to 1 previous error
```

幫助文字揭示了回傳型別需要一個泛型生命週期參數，因為 Rust 無法判斷回傳的 reference 是指 `x` 還是 `y`。實際上，我們也不知道，因為這個函數體中的 `if` 區塊返回 `x` 的 reference，而 `else` 區塊返回 `y` 的 reference！

當我們定義這個函數時，我們不知道會傳入這個函數的具體值，所以我們不知道 `if` 情況還是 `else` 情況會執行。我們也不知道傳入的 reference 的具體生命週期，所以我們無法像範例 10-17 和 10-18 那樣查看作用域來判斷我們回傳的 reference 是否永遠有效。borrow checker 也無法判斷這一點，因為它不知道 `x` 和 `y` 的生命週期與回傳值的生命週期之間有何關聯。為了修正這個錯誤，我們將添加泛型生命週期參數來定義 reference 之間的關係，以便 borrow checker 可以執行其分析。

### 生命週期註解語法

生命週期註解不會改變任何 reference 的壽命長度。相反，它們描述了多個 reference 的生命週期彼此之間的關係，而不影響生命週期。就像函數可以接受任何型別一樣，當簽章指定泛型型別參數時，函數也可以透過指定泛型生命週期參數來接受具有任何生命週期的 reference。

生命週期註解的語法有點不尋常：生命週期參數的名稱必須以撇號 (`'`) 開頭，通常都是小寫且非常短，就像泛型型別一樣。大多數人將第一個生命週期註解命名為 `'a`。我們將生命週期參數註解放在 reference 的 `&` 之後，使用空格將註解與 reference 的型別分開。

以下是一些範例：不帶生命週期參數的 `i32` 的 reference，帶有生命週期參數 `'a` 的 `i32` 的 reference，以及也帶有生命週期 `'a` 的可變 `i32` 的 reference。

```rust
&i32        // a reference
&'a i32     // a reference with an explicit lifetime
&'a mut i32 // a mutable reference with an explicit lifetime
```

單獨一個生命週期註解沒有太多意義，因為這些註解旨在告訴 Rust 多個 reference 的泛型生命週期參數之間如何相關。讓我們檢查 `longest` 函數的上下文中生命週期註解如何相互關聯。

### 函數簽章中的生命週期註解

要在函數簽章中使用生命週期註解，我們需要在函數名稱和參數列表之間的角括號內宣告泛型*生命週期*參數，就像我們對泛型*型別*參數所做的那樣。

我們希望簽章表達以下限制：回傳的 reference 將在兩個參數都有效的情況下保持有效。這是參數生命週期和回傳值生命週期之間的關係。我們將生命週期命名為 `'a`，然後將其添加到每個 reference 中，如範例 10-21 所示。

src/main.rs

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() { x } else { y }
}
```

範例 10-21：`longest` 函數定義，指定簽章中的所有 reference 必須具有相同的生命週期 `'a`

當我們在範例 10-19 中將此程式碼與 `main` 函數一起使用時，它應該會編譯並產生我們想要的結果。

函數簽章現在告訴 Rust，對於某個生命週期 `'a`，該函數接受兩個參數，它們都是字串 slice，且壽命至少與生命週期 `'a` 一樣長。函數簽章還告訴 Rust，從函數返回的字串 slice 將至少與生命週期 `'a` 一樣長。實際上，這意味著 `longest` 函數返回的 reference 的生命週期與函數參數所引用的值的生命週期中較短的一個相同。這些關係是我們希望 Rust 在分析此程式碼時使用的。

請記住，當我們在此函數簽章中指定生命週期參數時，我們沒有更改傳入或返回的任何值的生命週期。相反，我們指定 borrow checker 應該拒絕任何不符合這些限制的值。請注意，`longest` 函數不需要確切知道 `x` 和 `y` 會活多久，只需要知道某些作用域可以替換為 `'a`，這將滿足此簽章。

在函數中註解生命週期時，註解位於函數簽章中，而不是函數體中。生命週期註解成為函數契約的一部分，就像簽章中的型別一樣。讓函數簽章包含生命週期契約意味著 Rust 編譯器所做的分析可以更簡單。如果函數註解方式或呼叫方式存在問題，編譯器錯誤可以更精確地指向我們程式碼的哪個部分和哪些限制。相反，如果 Rust 編譯器對我們預期生命週期關係做出更多推斷，編譯器可能只能指向離問題根源很遠的程式碼使用處。

當我們將具體 reference 傳遞給 `longest` 時，替換 `'a` 的具體生命週期是 `x` 作用域與 `y` 作用域重疊的部分。換句話說，泛型生命週期 `'a` 將獲得等於 `x` 和 `y` 生命週期中較短者的具體生命週期。因為我們已經用相同的生命週期參數 `'a` 註解了回傳的 reference，所以回傳的 reference 也將在 `x` 和 `y` 生命週期中較短者期間有效。

讓我們看看生命週期註解如何透過傳入具有不同具體生命週期的 reference 來限制 `longest` 函數。範例 10-22 是一個直接的範例。

src/main.rs

```rust
fn main() {
    let string1 = String::from("long string is long");

    {
        let string2 = String::from("xyz");
        let result = longest(string1.as_str(), string2.as_str());
        println!("The longest string is {result}");
    }
}
```

範例 10-22：使用 `longest` 函數，其 reference 指向具有不同具體生命週期的 `String` 值

在這個範例中，`string1` 在外部作用域結束前有效，`string2` 在內部作用域結束前有效，而 `result` 引用的是在內部作用域結束前有效的事物。執行這段程式碼，你會看到 borrow checker 批准了；它會編譯並印出 `The longest string is long string is long`。

接下來，我們來試一個範例，它說明 `result` 中的 reference 的生命週期必須是兩個參數中較短的生命週期。我們將 `result` 變數的宣告移到內部作用域之外，但將值賦值給 `result` 變數的程式碼留在與 `string2` 相同的內部作用域內。然後我們將使用 `result` 的 `println!` 移到內部作用域之外，在內部作用域結束之後。範例 10-23 中的程式碼將無法編譯。

src/main.rs

```rust
fn main() {
    let string1 = String::from("long string is long");
    let result;
    {
        let string2 = String::from("xyz");
        result = longest(string1.as_str(), string2.as_str());
    }
    println!("The longest string is {result}");
}
```

範例 10-23：在 `string2` 超出作用域後嘗試使用 `result`

當我們試圖編譯這段程式碼時，我們會得到以下錯誤：

```
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0597]: `string2` does not live long enough
 --> src/main.rs:6:44
  |
5 |         let string2 = String::from("xyz");
  |             ------- binding `string2` declared here
6 |         result = longest(string1.as_str(), string2.as_str());
  |                                            ^^^^^^^ borrowed value does not live long enough
7 |     }
  |     - `string2` dropped here while still borrowed
8 |     println!("The longest string is {result}");
  |                                     -------- borrow later used here

For more information about this error, try `rustc --explain E0597`.
error: could not compile `chapter10` (bin "chapter10") due to 1 previous error
```

錯誤顯示，為了讓 `result` 對 `println!` 語句有效，`string2` 需要在外部作用域結束前保持有效。Rust 知道這一點，因為我們使用相同的生命週期參數 `'a` 註解了函數參數和返回值的生命週期。

作為人類，我們可以查看這段程式碼，並發現 `string1` 比 `string2` 長，因此 `result` 將包含 `string1` 的 reference。因為 `string1` 尚未超出作用域，所以 `string1` 的 reference 對於 `println!` 語句仍然有效。然而，編譯器在這種情況下無法判斷該 reference 是否有效。我們已經告訴 Rust，`longest` 函數返回的 reference 的生命週期與傳入的 reference 中較短者的生命週期相同。因此，borrow checker 會禁止範例 10-23 中的程式碼，因為它可能包含無效 reference。

試著設計更多實驗，改變傳入 `longest` 函數的 reference 的值和生命週期，以及如何使用回傳的 reference。在編譯之前，對你的實驗是否會通過 borrow checker 做出假設；然後檢查你是否正確！

### 以生命週期思考

你需要指定生命週期參數的方式取決於你的函數在做什麼。例如，如果我們將 `longest` 函數的實作更改為總是回傳第一個參數，而不是最長的字串 slice，我們就不需要為 `y` 參數指定生命週期。以下程式碼將會編譯：

src/main.rs

```rust
fn longest<'a>(x: &'a str, y: &str) -> &'a str {
    x
}
```

我們為參數 `x` 和返回型別指定了一個生命週期參數 `'a`，但沒有為參數 `y` 指定，因為 `y` 的生命週期與 `x` 的生命週期或返回值沒有任何關係。

從函數回傳 reference 時，回傳型別的生命週期參數需要與其中一個參數的生命週期參數相匹配。如果回傳的 reference *沒有*引用其中一個參數，它必須引用在此函數中創建的值。然而，這將是一個懸空 reference，因為該值將在函數結束時超出作用域。考慮以下 `longest` 函數的嘗試實作，它將無法編譯：

src/main.rs

```rust
fn longest<'a>(x: &str, y: &str) -> &'a str {
    let result = String::from("really long string");
    result.as_str()
}
```

在這裡，即使我們已經為回傳型別指定了一個生命週期參數 `'a`，但此實作將無法編譯，因為回傳值的生命週期與參數的生命週期完全不相關。以下是我們得到的錯誤訊息：

```
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0515]: cannot return value referencing local variable `result`
  --> src/main.rs:11:5
   |
11 |     result.as_str()
   |     ------^^^^^^^^^
   |     |
   |     returns a value referencing data owned by the current function
   |     `result` is borrowed here

For more information about this error, try `rustc --explain E0515`.
error: could not compile `chapter10` (bin "chapter10") due to 1 previous error
```

問題在於 `result` 在 `longest` 函數結束時會超出作用域並被清理。我們也試圖從函數中返回 `result` 的 reference。沒有辦法指定生命週期參數來改變懸空 reference，Rust 也禁止我們創建懸空 reference。在這種情況下，最好的解決方案是返回一個 owned data type 而不是 reference，這樣呼叫函數就可以負責清理該值。

歸根究底，生命週期語法是關於連接各種參數和函數返回值的生命週期。一旦它們連接起來，Rust 就有足夠的資訊來允許記憶體安全的運算，並禁止會產生懸空指標或以其他方式違反記憶體安全的運算。

### Struct 定義中的生命週期註解

到目前為止，我們定義的 struct 都包含 owned type。我們可以定義 struct 來包含 reference，但在這種情況下，我們需要在 struct 定義中的每個 reference 上添加生命週期註解。範例 10-24 有一個名為 `ImportantExcerpt` 的 struct，它包含一個字串 slice。

src/main.rs

```rust
struct ImportantExcerpt<'a> {
    part: &'a str,
}

fn main() {
    let novel = String::from("Call me Ishmael. Some years ago...");
    let first_sentence = novel.split('.').next().unwrap();
    let i = ImportantExcerpt {
        part: first_sentence,
    };
}
```

範例 10-24：一個包含 reference 的 struct，需要生命週期註解

這個 struct 只有一個 `part` 欄位，它包含一個字串 slice，這是一個 reference。就像泛型資料型別一樣，我們在 struct 名稱後的角括號內宣告泛型生命週期參數的名稱，這樣我們就可以在 struct 定義的主體中使用生命週期參數。這個註解意味著 `ImportantExcerpt` 的實例不能比它在其 `part` 欄位中包含的 reference 活得更久。

這裡的 `main` 函數創建了一個 `ImportantExcerpt` struct 的實例，該實例包含對變數 `novel` 所擁有的 `String` 的第一個句子的 reference。`novel` 中的資料在 `ImportantExcerpt` 實例被創建之前就已存在。此外，`novel` 在 `ImportantExcerpt` 超出作用域之後才超出作用域，因此 `ImportantExcerpt` 實例中的 reference 是有效的。

### 生命週期省略

你已經知道每個 reference 都有一個生命週期，並且你需要為使用 reference 的函數或 struct 指定生命週期參數。然而，我們在範例 4-9 中有一個函數，如範例 10-25 再次所示，它在沒有生命週期註解的情況下編譯。

src/lib.rs

```rust
fn first_word(s: &str) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..]
}
```

範例 10-25：我們在範例 4-9 中定義的一個函數，即使參數和回傳型別是 reference，它也無需生命週期註解即可編譯

這個函數能在沒有生命週期註解的情況下編譯的原因是歷史性的：在 Rust 的早期版本（1.0 之前），這段程式碼將無法編譯，因為每個 reference 都需要明確的生命週期。那時，函數簽章會這樣寫：

```rust
fn first_word<'a>(s: &'a str) -> &'a str {
```

在編寫了大量的 Rust 程式碼之後，Rust 團隊發現 Rust 程式設計師在特定情況下會一遍又一遍地輸入相同的生命週期註解。這些情況是可預測的，並遵循一些確定性模式。開發人員將這些模式程式設計到編譯器的程式碼中，以便 borrow checker 可以在這些情況下推斷生命週期，而不需要明確的註解。

這段 Rust 歷史是相關的，因為未來可能會出現更多確定性模式並添加到編譯器中。未來，可能需要更少的生命週期註解。

程式設計到 Rust reference 分析中的模式稱為 _生命週期省略規則 (lifetime elision rules)_。這些規則不是供程式設計師遵循的；它們是一組編譯器會考慮的特定情況，如果你的程式碼符合這些情況，你就不需要明確地寫出生命週期。

省略規則不提供完全推斷。如果 Rust 應用這些規則後，關於 reference 的生命週期仍然存在歧義，編譯器不會猜測其餘 reference 的生命週期應該是什麼。相反，編譯器會給你一個錯誤，你可以透過添加生命週期註解來解決。

函數或方法參數上的生命週期稱為 _輸入生命週期 (input lifetimes)_，而返回值上的生命週期稱為 _輸出生命週期 (output lifetimes)_。

編譯器使用三個規則來找出 reference 的生命週期，當沒有明確註解時。第一個規則適用於輸入生命週期，第二個和第三個規則適用於輸出生命週期。如果編譯器到達三個規則的末尾，並且仍然有無法找出生命週期的 reference，編譯器將會停止並出現錯誤。這些規則適用於 `fn` 定義以及 `impl` 區塊。

第一個規則是編譯器為每個作為 reference 的參數分配一個生命週期參數。換句話說，一個帶有一個參數的函數會得到一個生命週期參數：`fn foo<'a>(x: &'a i32)`；一個帶有兩個參數的函數會得到兩個單獨的生命週期參數：`fn foo<'a, 'b>(x: &'a i32, y: &'b i32)`；依此類推。

第二個規則是，如果恰好有一個輸入生命週期參數，則該生命週期會分配給所有輸出生命週期參數：`fn foo<'a>(x: &'a i32) -> &'a i32`。

第三條規則是，如果有多個輸入生命週期參數，但其中一個是 `&self` 或 `&mut self`（因為這是一個方法），則 `self` 的生命週期會分配給所有輸出生命週期參數。這第三條規則使得方法的閱讀和編寫更加便捷，因為所需的符號更少。

讓我們假裝我們是編譯器。我們將應用這些規則來找出範例 10-25 中 `first_word` 函數簽章中 reference 的生命週期。簽章開始時，沒有任何與 reference 相關聯的生命週期：

```rust
fn first_word(s: &str) -> &str {
```

然後編譯器應用第一條規則，該規則指定每個參數都有其自己的生命週期。我們像往常一樣將其稱為 `'a`，所以現在簽章是這樣的：

```rust
fn first_word<'a>(s: &'a str) -> &str {
```

第二條規則適用，因為恰好有一個輸入生命週期。第二條規則指定將一個輸入參數的生命週期分配給輸出生命週期，所以簽章現在是這樣的：

```rust
fn first_word<'a>(s: &'a str) -> &'a str {
```

現在此函數簽章中的所有 reference 都有生命週期，編譯器可以繼續其分析，而無需程式設計師註解此函數簽章中的生命週期。

我們來看另一個範例，這次使用 `longest` 函數，當我們開始在範例 10-20 中使用它時，它沒有生命週期參數：

```rust
fn longest(x: &str, y: &str) -> &str {
```

我們應用第一條規則：每個參數都有自己的生命週期。這次我們有兩個參數而不是一個，所以我們有兩個生命週期：

```rust
fn longest<'a, 'b>(x: &'a str, y: &'b str) -> &str {
```

你可以看到第二條規則不適用，因為有多個輸入生命週期。第三條規則也不適用，因為 `longest` 是一個函數而不是方法，所以沒有任何參數是 `self`。在完成所有三條規則後，我們仍然沒有弄清楚回傳型別的生命週期是什麼。這就是為什麼我們在嘗試編譯範例 10-20 中的程式碼時會得到錯誤：編譯器經過生命週期省略規則的處理，但仍然無法找出簽章中所有 reference 的生命週期。

由於第三條規則實際上僅適用於方法簽章，我們接下來將在該上下文中查看生命週期，以了解為什麼第三條規則意味著我們不必經常註解方法簽章中的生命週期。

### 方法定義中的生命週期註解

當我們在帶有生命週期的 struct 上實作方法時，我們使用與泛型型別參數相同的語法，如範例 10-11 所示。我們宣告和使用生命週期參數的位置取決於它們是否與 struct 欄位或方法參數和返回值相關。

struct 欄位的生命週期名稱總是需要在 `impl` 關鍵字之後宣告，然後在 struct 名稱之後使用，因為這些生命週期是 struct 型別的一部分。

在 `impl` 區塊內的方法簽章中，reference 可能與 struct 欄位中的 reference 的生命週期綁定，或者它們可能是獨立的。此外，生命週期省略規則通常使得在方法簽章中不需要生命週期註解。讓我們看一些使用我們在範例 10-24 中定義的 `ImportantExcerpt` struct 的範例。

首先，我們將使用一個名為 `level` 的方法，其唯一參數是對 `self` 的 reference，其回傳值是一個 `i32`，它不是對任何東西的 reference：

```rust
impl<'a> ImportantExcerpt<'a> {
    fn level(&self) -> i32 {
        3
    }
}
```

在 `impl` 之後宣告生命週期參數及其在型別名稱之後的使用是必需的，但由於第一個省略規則，我們不需要註解 `self` 的 reference 的生命週期。

以下是第三個生命週期省略規則適用的範例：

```rust
impl<'a> ImportantExcerpt<'a> {
    fn announce_and_return_part(&self, announcement: &str) -> &str {
        println!("Attention please: {announcement}");
        self.part
    }
}
```

有兩個輸入生命週期，因此 Rust 應用第一個生命週期省略規則，並為 `&self` 和 `announcement` 都指定自己的生命週期。然後，因為其中一個參數是 `&self`，所以回傳型別會獲得 `&self` 的生命週期，所有生命週期都已考慮在內。

### 靜態生命週期

我們需要討論的一個特殊生命週期是 `'static`，它表示受影響的 reference *可以*在整個程式執行期間存在。所有字串字面值都具有 `'static` 生命週期，我們可以這樣註解：

```rust
let s: &'static str = "I have a static lifetime.";
```

這個字串的文字直接儲存在程式的二進位檔中，它始終可用。因此，所有字串字面值的生命週期都是 `'static`。

你可能會在錯誤訊息中看到使用 `'static` 生命週期的建議。但在將 `'static` 指定為 reference 的生命週期之前，請思考你擁有的 reference 是否真的在你的程式的整個生命週期中存在，以及你是否希望它如此。大多數情況下，建議使用 `'static` 生命週期的錯誤訊息是試圖創建懸空 reference 或可用生命週期不匹配的結果。在這種情況下，解決方案是修復這些問題，而不是指定 `'static` 生命週期。

## 泛型型別參數、Trait Bound 和生命週期總覽

讓我們先簡要地看看在一個函數中同時指定泛型型別參數、trait bound 和生命週期的語法！

```rust
use std::fmt::Display;

fn longest_with_an_announcement<'a, T>(
    x: &'a str,
    y: &'a str,
    ann: T,
) -> &'a str
where
    T: Display,
{
    println!("Announcement! {ann}");
    if x.len() > y.len() { x } else { y }
}
```

這是來自範例 10-21 的 `longest` 函數，它回傳兩個字串 slice 中較長的一個。但現在它有一個額外的參數 `ann`，其泛型型別 `T` 可以由任何實作 `Display` trait 的型別填充，如 `where` 子句所指定。這個額外參數將使用 `{}` 印出，這就是 `Display` trait bound 必須存在的原因。因為生命週期是一種泛型，所以生命週期參數 `'a` 和泛型型別參數 `T` 的宣告都放在函數名稱後的角括號中的同一個列表中。

## 總結

本章我們涵蓋了許多內容！現在你已經了解了泛型型別參數、trait 和 trait bound，以及泛型生命週期參數，你已經準備好編寫沒有重複的程式碼，這些程式碼可以在許多不同情況下運作。泛型型別參數讓你能夠將程式碼應用於不同的型別。Trait 和 trait bound 確保即使型別是泛型的，它們也會具有程式碼所需的行為。你學習了如何使用生命週期註解來確保這個靈活的程式碼不會有任何懸空 reference。而所有這些分析都在編譯時發生，這不會影響執行時效能！

信不信由你，關於我們在本章討論的主題還有很多可以學習的：第 18 章討論了 trait object，這是使用 trait 的另一種方式。還有更複雜的涉及生命週期註解的場景，你只會在非常進階的場景中需要它們；對於這些，你應該閱讀 Rust Reference，網址為：[https://doc.rust-lang.org/book/../reference/index.html](https://doc.rust-lang.org/reference/index.html)。但接下來，你將學習如何在 Rust 中編寫測試，以便你可以確保你的程式碼按預期運作。
