<!-- DO NOT EDIT THIS FILE.

This file is periodically generated from the content in the `/src/`
directory, so all fixes need to be made in `/src/`.
-->

[TOC]

# 理解 Ownership

ownership 是 Rust 最獨特的功能，並對語言的其餘部分產生深遠的影響。它讓 Rust 能夠在不需要 garbage collector 的情況下提供記憶體安全保證，因此理解 ownership 的運作方式非常重要。在本章中，我們將討論 ownership 以及幾個相關的功能：borrowing、slices，以及 Rust 如何在記憶體中配置資料。

## 什麼是 Ownership？

*Ownership* 是一組規則，用於規範 Rust 程式如何管理記憶體。所有程式都必須在執行時管理它們使用電腦記憶體的方式。有些語言有 garbage collection，會在程式執行時定期尋找不再使用的記憶體；在其他語言中，程式設計師必須明確地分配和釋放記憶體。Rust 採用第三種方法：記憶體透過一套由編譯器檢查的 ownership 系統來管理。如果任何規則被違反，程式將無法編譯。在程式執行時，ownership 的任何功能都不會減慢你的程式。

由於 ownership 對於許多程式設計師來說是一個新概念，因此需要一些時間來適應。好消息是，你對 Rust 和 ownership 系統的規則越熟悉，你就會發現越容易自然地開發出安全且有效率的程式碼。請堅持下去！

當你理解 ownership 時，你將為理解 Rust 獨特的功能打下堅實的基礎。在本章中，你將透過一些以常見資料結構：字串為重點的範例來學習 ownership。

> ### Stack 和 Heap
>
> 許多程式語言不需要你經常考慮 stack 和 heap。但在像 Rust 這樣的系統程式語言中，一個值是在 stack 上還是在 heap 上，會影響語言的行為以及你為何必須做出某些決定。ownership 的部分內容將在本章稍後結合 stack 和 heap 進行描述，因此這裡提供一個簡要的解釋作為準備。
>
> stack 和 heap 都是你的程式碼在執行期可以使用的記憶體部分，但它們的結構不同。stack 按照接收值的順序儲存值，並以相反的順序移除值。這被稱為*後進先出 (last in, first out)*。想像一下一疊盤子：當你增加更多盤子時，你會把它們放在堆疊的頂部，當你需要一個盤子時，你會從頂部取下一個。從中間或底部添加或移除盤子就無法很好地運作！添加資料稱為*推進 stack (pushing onto the stack)*，移除資料稱為*從 stack 彈出 (popping off the stack)*。所有儲存在 stack 上的資料都必須具有已知且固定的大小。在編譯期大小未知或可能更改大小的資料必須儲存在 heap 上。
>
> heap 較不規則：當你將資料放在 heap 上時，你請求一定量的空間。記憶體分配器在 heap 中找到一個足夠大的空位，將其標記為正在使用中，並返回一個*指標 (pointer)*，它是該位置的記憶體位址。這個過程稱為*在 heap 上分配 (allocating on the heap)*，有時簡稱為*分配 (allocating)*（將值推進 stack 不被視為分配）。因為指向 heap 的指標具有已知且固定的大小，你可以將該指標儲存在 stack 上，但當你需要實際資料時，你必須追蹤該指標。想像一下在餐廳就座。當你進去時，你說明你組的人數，然後服務員找到一個適合每個人的空桌並帶你到那裡。如果你組裡有人遲到，他們可以詢問你坐在哪裡來找到你。
>
> 推進 stack 比在 heap 上分配更快，因為分配器永遠不需要搜尋儲存新資料的地方；該位置總是在 stack 的頂部。相比之下，在 heap 上分配空間需要更多工作，因為分配器必須首先找到足夠大的空間來容納資料，然後執行簿記以準備下一次分配。
>
> 存取 heap 中的資料通常比存取 stack 上的資料慢，因為你必須追蹤指標才能到達那裡。如果現代處理器在記憶體中跳躍的次數較少，它們會更快。繼續類比，考慮餐廳的服務員從許多桌子點餐。在移到下一桌之前，先點完一桌的所有訂單是最有效率的。從桌 A 點餐，然後從桌 B 點餐，然後再從 A 點一次，然後再從 B 點一次，這會是一個慢得多過程。同理，處理器通常可以更好地處理靠近其他資料（如在 stack 上）而不是遠離其他資料（如在 heap 上）的資料。
>
> 當你的程式碼呼叫一個函式時，傳遞給函式的值（可能包括指向 heap 上資料的指標）和函式的區域變數會被推進 stack。當函式結束時，這些值會從 stack 中彈出。
>
> 追蹤程式碼的哪些部分正在使用 heap 上的哪些資料、最小化 heap 上的重複資料量，以及清理 heap 上未使用的資料以避免空間不足，這些都是 ownership 解決的問題。一旦你理解了 ownership，你就不需要經常考慮 stack 和 heap，但了解 ownership 的主要目的是管理 heap 資料，可以幫助解釋它為何這樣運作。

### Ownership 規則

首先，我們來看看 ownership 的規則。在我們接下來看範例時，請記住這些規則：

* 在 Rust 中，每個值都有一個*owner*。
* 同一時間內只能有一個 owner。
* 當 owner 離開作用域時，該值將被 drop。

### 變數作用域

現在我們已經超過基本的 Rust 語法，在範例中我們將不再包含所有的 `fn main() {` 程式碼，所以如果你跟著做，請確保手動將以下範例放在 `main` 函式內部。因此，我們的範例將會更簡潔，讓我們能夠專注於實際細節而不是樣板程式碼。

作為 ownership 的第一個範例，我們將看看一些變數的*作用域 (scope)*。作用域是程式碼中一個項目有效的範圍。考慮以下變數：

```rust
let s = "hello";
```

變數 `s` 參照一個字串常值，其中字串的值被硬編碼到我們程式碼的文字中。該變數從宣告點開始，直到當前*作用域*結束為止都是有效的。範例 4-1 顯示了一個程式，其中註釋指出了變數 `s` 的有效範圍。

```rust
    {                      // s 在此處無效，因為尚未宣告
        let s = "hello";   // s 從此點開始有效

        // 對 s 執行操作
    }                      // 此作用域現在結束，s 不再有效
```

範例 4-1：一個變數及其有效作用域

換句話說，這裡有兩個重要的時間點：

* 當 `s` *進入*作用域時，它有效。
* 它保持有效直到它*離開*作用域。

目前為止，作用域和變數何時有效之間的關係與其他程式語言中的情況相似。現在我們將在此理解的基礎上引入 `String` 型別。

### `String` 型別

為了闡明 ownership 的規則，我們需要一種比第 3 章「資料型別」部分中討論的資料型別更複雜的資料型別。之前涵蓋的型別具有已知大小，可以儲存在 stack 上並在其作用域結束時從 stack 中彈出，並且如果程式碼的另一部分需要在不同作用域中使用相同的值，則可以快速且簡單地複製以建立一個新的獨立實例。但是我們想要查看儲存在 heap 上的資料，並探討 Rust 如何知道何時清理該資料，而 `String` 型別是一個很好的範例。

我們將專注於 `String` 中與 ownership 相關的部分。這些方面也適用於其他複雜的資料型別，無論它們是由標準函式庫提供的還是由你建立的。我們將在第 8 章中更深入地討論 `String`。

我們已經看過字串常值，其中字串值硬編碼到我們的程式中。字串常值很方便，但它們並不適用於我們可能想要使用文字的所有情況。其中一個原因是它們是不可變的。另一個原因是並非每個字串值都可以在我們編寫程式碼時得知：例如，如果我們想獲取使用者輸入並儲存它呢？對於這些情況，Rust 有第二種字串型別，`String`。這種型別管理分配在 heap 上的資料，因此能夠儲存編譯期我們未知數量的文字。你可以使用 `from` 函式從字串常值建立一個 `String`，如下所示：

```rust
let s = String::from("hello");
```

雙冒號 `::` 運算子允許我們將這個特定的 `from` 函式命名空間在 `String` 型別下，而不是使用像 `string_from` 這樣的名稱。我們將在第 5 章的「方法語法」部分中更深入地討論這個語法，以及在第 7 章的「模組樹中參照項目的路徑」中討論模組的命名空間。

這種字串*可以*是可變的：

```rust
    let mut s = String::from("hello");

    s.push_str(", world!"); // push_str() 函式會將一個常值字串附加到 String

    println!("{s}"); // 這將會印出 `hello, world!`
```

那麼，這裡有什麼區別呢？為什麼 `String` 可以被異變而常值不能？區別在於這兩種型別如何處理記憶體。

### 記憶體與分配

對於字串常值，我們在編譯期知道內容，因此文字會直接硬編碼到最終的可執行檔中。這就是為什麼字串常值快速且高效的原因。但這些屬性僅來自於字串常值的不可變性。不幸的是，對於每個在編譯期大小未知且在程式執行時大小可能改變的文字，我們無法將一塊記憶體放入二進位檔案中。

對於 `String` 型別，為了支援可變的、可增長的文字，我們需要在 heap 上分配一定量的記憶體，在編譯期未知，以容納其內容。這意味著：

* 記憶體必須在執行期從記憶體分配器請求。
* 當我們完成使用 `String` 時，我們需要一種方法將這塊記憶體返回給分配器。

第一部分由我們完成：當我們呼叫 `String::from` 時，它的實作會請求所需的記憶體。這在程式語言中幾乎是通用的。

然而，第二部分則不同。在帶有*garbage collector (GC)* 的語言中，GC 會追蹤並清理不再使用的記憶體，我們不需要去考慮它。在大多數沒有 GC 的語言中，我們有責任識別記憶體何時不再使用，並呼叫程式碼明確地釋放它，就像我們請求它一樣。正確地執行此操作歷來是一個困難的程式設計問題。如果我們忘記了，我們就會浪費記憶體。如果我們做得太早，我們將會有一個無效的變數。如果我們做了兩次，那也是一個錯誤。我們需要將恰好一個 `allocate` 與恰好一個 `free` 配對。

Rust 採用不同的路徑：一旦擁有記憶體的變數離開作用域，記憶體就會自動返回。這是我們在範例 4-1 中使用 `String` 而不是字串常值的範圍範例版本：

```rust
    {
        let s = String::from("hello"); // s 從此點開始有效

        // 對 s 執行操作
    }                                  // 此作用域現在結束，s 不再有效
                                       // 了
```

有一個自然的時機可以將 `String` 所需的記憶體返回給分配器：當 `s` 離開作用域時。當一個變數離開作用域時，Rust 會為我們呼叫一個特殊的函式。這個函式被稱為 `drop`，`String` 的作者可以在這裡放置返回記憶體的程式碼。Rust 會在閉合大括號處自動呼叫 `drop`。

> 注意：在 C++ 中，這種在項目生命週期結束時解除分配資源的模式有時被稱為*資源取得即初始化 (Resource Acquisition Is Initialization, RAII)*。如果你使用過 RAII 模式，那麼 Rust 中的 `drop` 函式將會讓你感到熟悉。

這種模式對 Rust 程式碼的寫作方式產生深遠影響。它現在看起來可能很簡單，但在更複雜的情況下，當我們希望有多個變數使用我們在 heap 上分配的資料時，程式碼的行為可能會出乎意料。現在讓我們探討其中一些情況。

<a id="ways-variables-and-data-interact-move"></a>

#### 變數與資料的互動：Move

在 Rust 中，多個變數可以以不同方式與相同的資料互動。讓我們看看範例 4-2 中使用整數的範例。

```rust
    let x = 5;
    let y = x;
```

範例 4-2：將變數 `x` 的整數值指派給 `y`

我們大概可以猜到這在做什麼：「將值 `5` 綁定到 `x`；然後複製 `x` 中的值並將其綁定到 `y`。」我們現在有兩個變數 `x` 和 `y`，兩者都等於 `5`。這確實是正在發生的事情，因為整數是具有已知、固定大小的簡單值，並且這兩個 `5` 值被推進 stack。

現在讓我們看看 `String` 版本：

```rust
    let s1 = String::from("hello");
    let s2 = s1;
```

這看起來非常相似，所以我們可能會假設它的運作方式也會相同：也就是說，第二行會複製 `s1` 中的值並將其綁定到 `s2`。但這並非完全如此。

請查看圖 4-1 以了解 `String` 在底層的運作方式。一個 `String` 由三部分組成，如左側所示：一個指向儲存字串內容的記憶體指標、一個長度 (length) 和一個容量 (capacity)。這組資料儲存在 stack 上。右側是儲存內容的 heap 記憶體。

![兩個表格：第一個表格包含 s1 在 stack 上的表示，由其長度 (5)、容量 (5) 和指向第二個表格中第一個值的指標組成。第二個表格包含字串資料在 heap 上的表示，逐位元組。](https://doc.rust-lang.org/book/img/trpl04-01.svg)

圖 4-1：String 儲存值 `"hello"` 並綁定到 `s1` 的記憶體表示

長度是指 `String` 內容目前使用的記憶體量（以位元組為單位）。容量是 `String` 從分配器接收到的總記憶體量（以位元組為單位）。長度和容量之間的差異很重要，但在此上下文中不重要，因此目前可以忽略容量。

當我們將 `s1` 指派給 `s2` 時，`String` 資料會被複製，這意味著我們複製 stack 上的指標、長度和容量。我們不會複製指標所指向的 heap 上的資料。換句話說，記憶體中的資料表示看起來像圖 4-2。

![三個表格：表格 s1 和 s2 分別代表這些字串在 stack 上，並且都指向 heap 上相同的字串資料。](https://doc.rust-lang.org/book/img/trpl04-02.svg)

圖 4-2：變數 `s2` 的記憶體表示，它複製了 `s1` 的指標、長度和容量

這種表示*不*像圖 4-3，如果 Rust 也複製 heap 資料，記憶體就會像這樣。如果 Rust 這樣做，如果 heap 上的資料很大，操作 `s2 = s1` 在執行期效能方面可能會非常昂貴。

![四個表格：兩個表格代表 s1 和 s2 的 stack 資料，並且每個表格都指向自己在 heap 上的字串資料副本。](https://doc.rust-lang.org/book/img/trpl04-03.svg)

圖 4-3：如果 Rust 也複製 heap 資料，`s2 = s1` 可能會執行的另一種情況

前面我們提到，當一個變數離開作用域時，Rust 會自動呼叫 `drop` 函式並清理該變數的 heap 記憶體。但圖 4-2 顯示兩個資料指標指向相同的位置。這是一個問題：當 `s2` 和 `s1` 離開作用域時，它們都會嘗試釋放相同的記憶體。這被稱為*double free* 錯誤，也是我們之前提到的一個記憶體安全錯誤。兩次釋放記憶體會導致記憶體損毀，這可能會導致安全漏洞。

為確保記憶體安全，在 `let s2 = s1;` 這行之後，Rust 認為 `s1` 不再有效。因此，當 `s1` 離開作用域時，Rust 無需釋放任何東西。請查看在 `s2` 建立後嘗試使用 `s1` 時會發生什麼；它將無法運作：

```rust
    let s1 = String::from("hello");
    let s2 = s1;

    println!("{s1}, world!");
```

你將會收到類似這樣的錯誤，因為 Rust 會阻止你使用無效的 reference：

```
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0382]: borrow of moved value: `s1`
 --> src/main.rs:5:15
  |
2 |     let s1 = String::from("hello");
  |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait
3 |     let s2 = s1;
  |              -- value moved here
4 |
5 |     println!("{s1}, world!");
  |               ^^^^ value borrowed here after move
  |
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider cloning the value if the performance cost is acceptable
  |
3 |     let s2 = s1.clone();
  |                ++++++++

For more information about this error, try `rustc --explain E0382`.
error: could not compile `ownership` (bin "ownership") due to 1 previous error
```

如果你在其他語言中聽過*shallow copy* 和*deep copy* 這些術語，那麼複製指標、長度和容量而不複製資料的概念聽起來可能就像是在進行 shallow copy。但由於 Rust 也會使第一個變數無效，因此它不被稱為 shallow copy，而是被稱為*move*。在這個範例中，我們會說 `s1` 被*moved* 到 `s2`。所以，實際發生的情況如圖 4-4 所示。

![三個表格：表格 s1 和 s2 分別代表這些字串在 stack 上，並且都指向 heap 上相同的字串資料。表格 s1 已變灰，因為 s1 不再有效；只有 s2 可以用來存取 heap 資料。](https://doc.rust-lang.org/book/img/trpl04-04.svg)

圖 4-4：`s1` 無效後的記憶體表示

這解決了我們的問題！由於只有 `s2` 有效，當它離開作用域時，它將獨自釋放記憶體，我們就完成了。

此外，這也暗示了一個設計選擇：Rust 永遠不會自動建立資料的「deep」副本。因此，任何*自動的*複製都可以假定在執行期效能方面是不昂貴的。

#### 作用域與指派

對於作用域、ownership 和透過 `drop` 函式釋放記憶體之間的關係，情況也是如此。當你將一個全新的值指派給現有變數時，Rust 會立即呼叫 `drop` 並釋放原始值的記憶體。例如，考慮這段程式碼：

```rust
    let mut s = String::from("hello");
    s = String::from("ahoy");

    println!("{s}, world!");
```

我們最初宣告了一個變數 `s` 並將其綁定到一個值為 `"hello"` 的 `String`。然後我們立即建立一個值為 `"ahoy"` 的新 `String` 並將其指派給 `s`。此時，沒有任何東西指向 heap 上的原始值。

![一個表格 s 代表 stack 上的字串值，指向 heap 上第二塊字串資料（ahoy），原始字串資料（hello）已變灰，因為它無法再被存取。](https://doc.rust-lang.org/book/img/trpl04-05.svg)

圖 4-5：初始值完全被取代後的記憶體表示。

因此，原始字串會立即離開作用域。Rust 將在其上執行 `drop` 函式，其記憶體將立即被釋放。當我們在結尾列印該值時，它將是 `"ahoy, world!"`。

<a id="ways-variables-and-data-interact-clone"></a>

#### 變數與資料的互動：Clone

如果我們*確實*想要 deep copy `String` 的 heap 資料，而不僅僅是 stack 資料，我們可以使用一個常見的方法 `clone`。我們將在第 5 章討論方法語法，但由於方法在許多程式語言中是常見的功能，你可能之前已經見過它們。

這是一個 `clone` 方法的實際範例：

```rust
    let s1 = String::from("hello");
    let s2 = s1.clone();

    println!("s1 = {s1}, s2 = {s2}");
```

這運作得很好，並且明確地產生圖 4-3 中所示的行為，其中 heap 資料*確實*被複製了。

當你看到 `clone` 的呼叫時，你就會知道有一些任意的程式碼正在執行，而且這些程式碼可能很昂貴。這是一個視覺指標，表示有不同的事情正在發生。

#### 僅 Stack 資料：Copy

還有一個我們尚未談到的細節。這段使用整數的程式碼（部分在範例 4-2 中展示）可以正常運作且有效：

```rust
    let x = 5;
    let y = x;

    println!("x = {x}, y = {y}");
```

但這段程式碼似乎與我們剛才學到的知識相矛盾：我們沒有呼叫 `clone`，但 `x` 仍然有效並且沒有被 move 到 `y`。

原因是像整數這類在編譯期大小已知的型別完全儲存在 stack 上，所以實際值的複製速度很快。這表示我們沒有理由阻止 `x` 在我們建立變數 `y` 後保持有效。換句話說，這裡的 deep copy 和 shallow copy 沒有區別，所以呼叫 `clone` 不會與通常的 shallow copy 做任何不同的事情，我們可以省略它。

Rust 有一個特殊的註解，稱為 `Copy` trait，我們可以將其放在儲存在 stack 上的型別上，就像整數一樣（我們將在第 10 章更深入地討論 trait）。如果一個型別實作了 `Copy` trait，則使用它的變數不會 move，而是簡單地複製，使其在指派給另一個變數後仍然有效。

如果型別或其任何部分實作了 `Drop` trait，Rust 不會讓我們用 `Copy` 註解該型別。如果該型別在值離開作用域時需要發生特殊的事情，而我們又為該型別添加了 `Copy` 註解，那麼我們將會收到一個編譯期錯誤。要了解如何為你的型別添加 `Copy` 註解以實作 trait，請參閱附錄 C 中的「可衍生 Trait」。

那麼，哪些型別實作了 `Copy` trait 呢？你可以檢查給定型別的文件以確定，但一般來說，任何簡單的純量值組都可以實作 `Copy`，並且任何需要分配或某種資源的形式都不能實作 `Copy`。以下是一些實作 `Copy` 的型別：

* 所有整數型別，例如 `u32`。
* 布林型別 `bool`，其值為 `true` 和 `false`。
* 所有浮點型別，例如 `f64`。
* 字元型別 `char`。
* Tuple，如果它們只包含也實作了 `Copy` 的型別。例如，`(i32, i32)` 實作 `Copy`，但 `(i32, String)` 則不實作。

### Ownership 與函式

將值傳遞給函式的機制與將值指派給變數時類似。將變數傳遞給函式會 move 或 copy，就像指派一樣。範例 4-3 有一個範例，帶有一些註釋，顯示變數何時進入和離開作用域。

src/main.rs

```rust
fn main() {
    let s = String::from("hello");  // s 進入作用域

    takes_ownership(s);             // s 的值 move 到函式中...
                                    // ... 因此在這裡不再有效

    let x = 5;                      // x 進入作用域

    makes_copy(x);                  // 因為 i32 實作了 Copy trait，
                                    // x 不會 move 到函式中，
                                    // 因此之後使用 x 是可以的。

} // 在這裡，x 離開作用域，然後 s。但是，由於 s 的值已被 move，
  // 所以沒有什麼特別的事情發生。

fn takes_ownership(some_string: String) { // some_string 進入作用域
    println!("{some_string}");
} // 在這裡，some_string 離開作用域並呼叫 `drop`。支援記憶體被釋放。

fn makes_copy(some_integer: i32) { // some_integer 進入作用域
    println!("{some_integer}");
} // 在這裡，some_integer 離開作用域。沒有什麼特別的事情發生。
```

範例 4-3：帶有 ownership 和作用域註釋的函式

如果我們在呼叫 `takes_ownership` 之後嘗試使用 `s`，Rust 將會拋出編譯期錯誤。這些靜態檢查保護我們免於犯錯。嘗試在 `main` 中添加使用 `s` 和 `x` 的程式碼，看看你可以在哪裡使用它們，以及 ownership 規則阻止你在哪裡使用它們。

### 回傳值與作用域

回傳值也可以轉移 ownership。範例 4-4 顯示了一個函式回傳一些值的範例，帶有與範例 4-3 類似的註釋。

src/main.rs

```rust
fn main() {
    let s1 = gives_ownership();        // gives_ownership 將其回傳值
                                       // move 到 s1

    let s2 = String::from("hello");    // s2 進入作用域

    let s3 = takes_and_gives_back(s2); // s2 被 move 到
                                       // takes_and_gives_back，它也
                                       // 將其回傳值 move 到 s3
} // 在這裡，s3 離開作用域並被 drop。s2 已經被 move，所以沒有
  // 任何事情發生。s1 離開作用域並被 drop。

fn gives_ownership() -> String {       // gives_ownership 將會將其
                                       // 回傳值 move 到呼叫它的
                                       // 函式中

    let some_string = String::from("yours"); // some_string 進入作用域

    some_string                        // some_string 被回傳並
                                       // move 到呼叫函式
}

// 這個函式接收一個 String 並回傳一個 String。
fn takes_and_gives_back(a_string: String) -> String {
    // a_string 進入
    // 作用域

    a_string  // a_string 被回傳並 move 到呼叫函式
}
```

範例 4-4：回傳值的 ownership 轉移

變數的 ownership 每次都遵循相同的模式：將一個值指派給另一個變數會將其 move。當一個包含 heap 上資料的變數離開作用域時，除非資料的 ownership 已被 move 到另一個變數，否則該值將由 `drop` 清理。

雖然這有效，但每次函式都接收 ownership 然後又回傳 ownership 有點繁瑣。如果我們想讓一個函式使用一個值但又不取得 ownership 呢？如果我們想要再次使用傳入的任何東西，除了函式主體中可能想要回傳的任何資料之外，傳入的任何東西也需要傳回，這會非常惱人。

Rust 確實允許我們使用 tuple 回傳多個值，如範例 4-5 所示。

src/main.rs

```rust
fn main() {
    let s1 = String::from("hello");

    let (s2, len) = calculate_length(s1);

    println!("The length of '{s2}' is {len}.");
}

fn calculate_length(s: String) -> (String, usize) {
    let length = s.len(); // len() 回傳 String 的長度

    (s, length)
}
```

範例 4-5：回傳參數的 ownership

但這對一個應該很常見的概念來說，儀式感太多且工作量大。幸運的是，Rust 有一個無需轉移 ownership 即可使用值的功能，稱為*references*。

## References 與 Borrowing

範例 4-5 中 tuple 程式碼的問題在於我們必須將 `String` 回傳給呼叫函式，以便在呼叫 `calculate_length` 之後我們仍然可以使用 `String`，因為 `String` 已經被 move 到 `calculate_length` 中了。作為替代，我們可以提供 `String` 值的 reference。一個*reference* 就像一個指標，它是一個我們可以遵循的位址，以存取儲存在該位址的資料；該資料由其他變數擁有。與指標不同的是，reference 保證在該 reference 的生命週期內指向特定型別的有效值。

以下是你如何定義和使用一個 `calculate_length` 函式，該函式將物件的 reference 作為參數，而不是取得值的 ownership：

src/main.rs

```rust
fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&s1);

    println!("The length of '{s1}' is {len}.");
}

fn calculate_length(s: &String) -> usize {
    s.len()
}
```

首先，請注意，變數宣告和函式回傳值中的所有 tuple 程式碼都消失了。其次，請注意我們將 `&s1` 傳遞給 `calculate_length`，並且在其定義中，我們接收的是 `&String` 而不是 `String`。這些邏輯與號 `&` 表示*references*，它們允許你參照某些值而無需取得其 ownership。圖 4-6 描繪了這個概念。

![三個表格：s 的表格只包含一個指向 s1 表格的指標。s1 的表格包含 s1 的 stack 資料，並指向 heap 上的字串資料。](https://doc.rust-lang.org/book/img/trpl04-06.svg)

圖 4-6：`&String s` 指向 `String s1` 的圖示

> 注意：使用 `&` 進行 reference 的反向操作是*解參照 (dereferencing)*，這透過解參照運算子 `*` 完成。我們將在第 8 章看到解參照運算子的一些用法，並在第 15 章討論解參照的細節。

讓我們仔細看看這裡的函式呼叫：

```rust
    let s1 = String::from("hello");

    let len = calculate_length(&s1);
```

`&s1` 語法讓我們可以建立一個*參照* `s1` 值但不擁有它的 reference。因為這個 reference 不擁有它，所以當這個 reference 停止使用時，它所指向的值不會被 drop。

同樣地，函式的簽章使用 `&` 來表示參數 `s` 的型別是一個 reference。讓我們添加一些解釋性註釋：

```rust
fn calculate_length(s: &String) -> usize { // s 是一個 String 的 reference
    s.len()
} // 在這裡，s 離開作用域。但因為 s 不擁有它所參照的內容，
  // 所以 String 不會被 drop。
```

變數 `s` 有效的作用域與任何函式參數的作用域相同，但當 `s` 停止使用時，reference 所指向的值不會被 drop，因為 `s` 沒有 ownership。當函式將 reference 作為參數而不是實際值時，我們不需要回傳值來回傳 ownership，因為我們從未擁有 ownership。

我們將建立 reference 的動作稱為*borrowing*。就像現實生活中一樣，如果一個人擁有某樣東西，你可以向他們借用。當你完成後，你必須歸還它。你不擁有它。

那麼，如果我們嘗試修改我們正在 borrowing 的東西會發生什麼？試試範例 4-6 中的程式碼。劇透警告：它不起作用！

src/main.rs

```rust
fn main() {
    let s = String::from("hello");

    change(&s);
}

fn change(some_string: &String) {
    some_string.push_str(", world");
}
```

範例 4-6：嘗試修改一個 borrowed 的值

這是錯誤：

```
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0596]: cannot borrow `*some_string` as mutable, as it is behind a `&` reference
 --> src/main.rs:8:5
  |
8 |     some_string.push_str(", world");
  |     ^^^^^^^^^^^ `some_string` is a `&` reference, so the data it refers to cannot be borrowed as mutable
  |
help: consider changing this to be a mutable reference
  |
7 | fn change(some_string: &mut String) {
  |                         +++

For more information about this error, try `rustc --explain E0596`.
error: could not compile `ownership` (bin "ownership") due to 1 previous error
```

就像變數預設是不可變的一樣，reference 也是。我們不允許修改我們擁有 reference 的東西。

### 可變 References

我們可以修改範例 4-6 中的程式碼，允許我們透過使用*可變 reference (mutable reference)* 的一些小調整來修改 borrowed 的值：

src/main.rs

```rust
fn main() {
    let mut s = String::from("hello");

    change(&mut s);
}

fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
```

首先，我們將 `s` 變為 `mut`。然後我們在呼叫 `change` 函式時使用 `&mut s` 建立一個可變 reference，並更新函式簽章以接受一個 `some_string: &mut String` 的可變 reference。這使得 `change` 函式將會異變它所 borrowed 的值變得非常明確。

可變 reference 有一個很大的限制：如果你擁有一個值的可變 reference，你就不能擁有該值的任何其他 reference。以下程式碼嘗試為 `s` 建立兩個可變 reference，這將會失敗：

src/main.rs

```rust
    let mut s = String::from("hello");

    let r1 = &mut s;
    let r2 = &mut s;

    println!("{r1}, {r2}");
```

這是錯誤：

```
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0499]: cannot borrow `s` as mutable more than once at a time
 --> src/main.rs:5:14
  |
4 |     let r1 = &mut s;
  |              ------ first mutable borrow occurs here
5 |     let r2 = &mut s;
  |              ^^^^^^ second mutable borrow occurs here
6 |
7 |     println!("{}, {}", r1, r2);
  |                        -- first borrow later used here

For more information about this error, try `rustc --explain E0499`.
error: could not compile `ownership` (bin "ownership") due to 1 previous error
```

此錯誤表示此程式碼無效，因為我們不能同時多次將 `s` borrow 為可變的。第一個可變 borrow 在 `r1` 中，並且必須持續到它在 `println!` 中使用為止，但在該可變 reference 建立及其使用之間，我們嘗試在 `r2` 中建立另一個可變 reference，該 reference borrow 了與 `r1` 相同的資料。

阻止同時對相同資料有多個可變 reference 的限制允許異變，但以一種非常受控制的方式。這是新的 Rustacean 會遇到的困難，因為大多數語言允許你隨時進行異變。擁有此限制的好處是 Rust 可以在編譯期預防 data race。*Data race* 類似於 race condition，並且在發生以下三種行為時發生：

* 兩個或更多個指標同時存取相同的資料。
* 至少有一個指標用於寫入資料。
* 沒有使用任何機制來同步對資料的存取。

Data race 會導致未定義的行為，並且在執行期追蹤它們時可能難以診斷和修復；Rust 透過拒絕編譯包含 data race 的程式碼來預防這個問題！

一如既往，我們可以使用大括號來建立一個新的作用域，允許有多個可變 reference，但不是*同時*的：

```rust
    let mut s = String::from("hello");

    {
        let r1 = &mut s;
    } // r1 在這裡離開作用域，所以我們可以毫無問題地建立一個新的 reference。

    let r2 = &mut s;
```

Rust 對於組合可變和不可變 reference 也實施了類似的規則。這段程式碼會導致錯誤：

```rust
    let mut s = String::from("hello");

    let r1 = &s; // 沒問題
    let r2 = &s; // 沒問題
    let r3 = &mut s; // 大問題

    println!("{r1}, {r2}, and {r3}");
```

這是錯誤：

```
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
 --> src/main.rs:6:14
  |
4 |     let r1 = &s; // no problem
  |              -- immutable borrow occurs here
5 |     let r2 = &s; // no problem
6 |     let r3 = &mut s; // BIG PROBLEM
  |              ^^^^^^ mutable borrow occurs here
7 |
8 |     println!("{}, {}, and {}", r1, r2, r3);
  |                                -- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership` (bin "ownership") due to 1 previous error
```

呼！當我們有一個不可變 reference 指向同一個值時，我們*也*不能有一個可變 reference。

不可變 reference 的使用者不希望該值突然在他們不知情的情況下發生改變！然而，允許多個不可變 reference 是因為沒有人僅僅是讀取資料就擁有影響其他人讀取資料的能力。

請注意，reference 的作用域從其引入處開始，並持續到該 reference 最後一次被使用。例如，這段程式碼將會編譯，因為不可變 reference 的最後一次使用是在 `println!` 中，發生在可變 reference 引入之前：

```rust
    let mut s = String::from("hello");

    let r1 = &s; // 沒問題
    let r2 = &s; // 沒問題
    println!("{r1} and {r2}");
    // 變數 r1 和 r2 在此之後將不再使用。

    let r3 = &mut s; // 沒問題
    println!("{r3}");
```

不可變 reference `r1` 和 `r2` 的作用域在它們最後一次使用的 `println!` 之後結束，這發生在可變 reference `r3` 建立之前。這些作用域不重疊，所以這段程式碼是允許的：編譯器可以判斷 reference 在作用域結束之前不再被使用。

儘管 borrowing 錯誤有時可能令人沮喪，但請記住，這是 Rust 編譯器提早（在編譯期而不是執行期）指出潛在錯誤，並準確地告訴你問題所在。這樣你就不必追蹤為什麼你的資料與你想像的不同。

### Dangling References

在具有指標的語言中，很容易錯誤地建立一個*dangling pointer*——一個參照到記憶體中可能已經被分配給其他人的位置的指標——透過釋放一些記憶體同時保留一個指向該記憶體的指標。相比之下，在 Rust 中，編譯器保證 references 永遠不會是 dangling references：如果你擁有某些資料的 reference，編譯器將確保該資料在該資料的 reference 離開作用域之前不會離開作用域。

讓我們嘗試建立一個 dangling reference，看看 Rust 如何透過編譯期錯誤來阻止它們：

src/main.rs

```rust
fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -> &String {
    let s = String::from("hello");

    &s
}
```

這是錯誤：

```
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0106]: missing lifetime specifier
 --> src/main.rs:5:16
  |
5 | fn dangle() -> &String {
  |                ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from
help: consider using the `'static` lifetime, but this uncommon unless you're returning a borrowed value from a `const` or a `static`
  |
5 | fn dangle() -> &'static String {
  |                 +++++++
help: instead, you are more likely to want to return an owned value
  |
5 - fn dangle() -> &String {
5 + fn dangle() -> String {
  |

error[E0515]: cannot return reference to local variable `s`
 --> src/main.rs:8:5
  |
8 |     &s
  |     ^^ returns a reference to data owned by the current function

Some errors have detailed explanations: E0106, E0515.
For more information about an error, try `rustc --explain E0106`.
error: could not compile `ownership` (bin "ownership") due to 2 previous errors
```

此錯誤訊息參照了我們尚未涵蓋的功能：lifetime。我們將在第 10 章詳細討論 lifetime。但是，如果你忽略有關 lifetime 的部分，該訊息確實包含了為什麼這段程式碼會出現問題的關鍵：

```
此函式的回傳型別包含一個 borrowed 的值，但沒有可以借用它的值
```

讓我們仔細看看 `dangle` 程式碼的每個階段究竟發生了什麼：

src/main.rs

```rust
fn dangle() -> &String { // dangle 回傳一個 String 的 reference

    let s = String::from("hello"); // s 是一個新的 String

    &s // 我們回傳 String s 的 reference
} // 在這裡，s 離開作用域並被 drop，所以它的記憶體消失了。
  // 危險！
```

因為 `s` 是在 `dangle` 內部建立的，所以當 `dangle` 的程式碼執行完畢時，`s` 將會被解分配。但我們嘗試回傳一個指向它的 reference。這意味著這個 reference 將會指向一個無效的 `String`。這可不行！Rust 不會讓我們這樣做。

這裡的解決方案是直接回傳 `String`：

```rust
fn no_dangle() -> String {
    let s = String::from("hello");

    s
}
```

這運作得很順利。ownership 被 move 出去，沒有任何東西被解分配。

### References 的規則

讓我們回顧一下我們討論過的關於 references 的內容：

* 在任何給定時間，你只能擁有一*個*可變 reference *或*任意數量的不可變 reference。
* References 必須始終有效。

接下來，我們將看看另一種 reference：slices。

## Slice 型別

*Slices* 允許你參照集合中連續的元素序列。Slice 是一種 reference，因此它沒有 ownership。

這裡有一個小程式設計問題：編寫一個函式，該函式接收一個由空格分隔的單字字串，並回傳它在該字串中找到的第一個單字。如果函式在字串中找不到空格，則整個字串必須是一個單字，因此應該回傳整個字串。

> 注意：為了介紹 string slices，我們在本節中假設只處理 ASCII 字元；有關 UTF-8 處理的更深入討論，請參閱第 8 章的「使用 String 儲存 UTF-8 編碼文字」部分。

讓我們來看看如何不使用 slices 來編寫這個函式的簽章，以理解 slices 將解決的問題：

```rust
fn first_word(s: &String) -> ?
```

`first_word` 函式有一個 `&String` 型別的參數。我們不需要 ownership，所以這沒問題。（在慣用的 Rust 中，函式除非需要，否則不會取得其參數的 ownership，其原因將在我們繼續學習時變得清楚。）但是我們應該回傳什麼呢？我們真的沒有辦法談論字串的*部分*。但是，我們可以回傳單字結尾的索引，由一個空格表示。讓我們嘗試一下，如範例 4-7 所示。

src/main.rs

```rust
fn first_word(s: &String) -> usize {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}
```

範例 4-7：`first_word` 函式，回傳 `String` 參數中的位元組索引值

因為我們需要逐個元素地遍歷 `String` 並檢查一個值是否為空格，所以我們將使用 `as_bytes` 方法將我們的 `String` 轉換為位元組陣列。

```rust
    let bytes = s.as_bytes();
```

接下來，我們使用 `iter` 方法在位元組陣列上建立一個 iterator：

```rust
    for (i, &item) in bytes.iter().enumerate() {
```

我們將在第 13 章更詳細地討論 iterators。目前，請知道 `iter` 是一個回傳集合中每個元素的方法，而 `enumerate` 則包裝了 `iter` 的結果並將每個元素作為 tuple 的一部分回傳。從 `enumerate` 回傳的 tuple 的第一個元素是索引，第二個元素是對元素的 reference。這比我們自己計算索引更方便一些。

由於 `enumerate` 方法回傳一個 tuple，我們可以使用模式來解構該 tuple。我們將在第 6 章更詳細地討論模式。在 `for` 迴圈中，我們指定了一個模式，其中 `i` 代表 tuple 中的索引，`&item` 代表 tuple 中的單一位元組。因為我們從 `.iter().enumerate()` 獲得了一個對元素的 reference，所以我們在模式中使用 `&`。

在 `for` 迴圈內部，我們透過使用位元組常值語法來搜尋代表空格的位元組。如果我們找到一個空格，我們就回傳該位置。否則，我們使用 `s.len()` 回傳字串的長度。

```rust
        if item == b' ' {
            return i;
        }
    }

    s.len()
```

我們現在有辦法找出字串中第一個單字結尾的索引，但有個問題。我們回傳的 `usize` 值本身，只有在 `&String` 的上下文中才有意義。換句話說，因為它是一個獨立於 `String` 的值，所以無法保證它將來仍然有效。考慮範例 4-8 中的程式，該程式使用了範例 4-7 中的 `first_word` 函式。

src/main.rs

```rust
fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&s); // word 將取得值 5

    s.clear(); // 這會清空 String，使其等於 ""

    // 此處 word 仍然有值 5，但 s 不再有任何我們可以有意義地與值 5
    // 一起使用的內容，所以 word 現在完全無效了！
}
```

範例 4-8：儲存呼叫 `first_word` 函式的結果，然後改變 `String` 的內容

這個程式碼在沒有任何錯誤的情況下編譯，即使我們在呼叫 `s.clear()` 之後使用 `word`，它也會這樣做。因為 `word` 與 `s` 的狀態完全無關，所以 `word` 仍然包含值 `5`。我們可以使用值 `5` 和變數 `s` 來嘗試提取第一個單字，但這將是一個錯誤，因為 `s` 的內容自我們將 `5` 儲存在 `word` 中以來已經改變了。

必須擔心 `word` 中的索引與 `s` 中的資料不同步是繁瑣且容易出錯的！如果我們編寫一個 `second_word` 函式，管理這些索引將會更加脆弱。它的簽章必須看起來像這樣：

```rust
fn second_word(s: &String) -> (usize, usize) {
```

現在我們要追蹤一個起始*和*一個結束索引，而且我們有更多從特定狀態的資料計算出來但與該狀態完全無關的值。我們有三個不相關的變數在周圍浮動，需要保持同步。

幸運的是，Rust 提供了這個問題的解決方案：string slices。

### String Slices

*String slice* 是對 `String` 元素連續序列的 reference，它看起來像這樣：

```rust
    let s = String::from("hello world");

    let hello = &s[0..5];
    let world = &s[6..11];
```

`hello` 不是指向整個 `String` 的 reference，而是指向 `String` 一部分的 reference，由額外的 `[0..5]` 指定。我們使用括號內的範圍來建立 slices，方法是指定 `[starting_index..ending_index]`，其中 *`starting_index`* 是 slice 中的第一個位置，而 *`ending_index`* 是 slice 中最後一個位置加一。在內部，slice 資料結構儲存 slice 的起始位置和長度，這對應於 *`ending_index`* 減去 *`starting_index`*。因此，在 `let world = &s[6..11];` 的情況下，`world` 將是一個 slice，其中包含一個指向 `s` 中索引 6 的位元組的指標，長度值為 `5`。

圖 4-7 以圖表形式顯示了這一點。

![三個表格：代表 s 的 stack 資料的表格，指向 heap 上字串資料「hello world」的表格中索引 0 的位元組。第三個表格代表 slice world 的 stack 資料，其長度值為 5，並指向 heap 資料表格的位元組 6。](https://doc.rust-lang.org/book/img/trpl04-07.svg)

圖 4-7：String slice 參照 `String` 的一部分

使用 Rust 的 `..` 範圍語法，如果你想從索引 0 開始，你可以省略兩個點之前的值。換句話說，這些是等價的：

```rust
let s = String::from("hello");

let slice = &s[0..2];
let slice = &s[..2];
```

同理，如果你的 slice 包含 `String` 的最後一個位元組，你可以省略尾隨數字。這表示這些是等價的：

```rust
let s = String::from("hello");

let len = s.len();

let slice = &s[3..len];
let slice = &s[3..];
```

你也可以省略兩個值來取得整個字串的 slice。所以這些是等價的：

```rust
let s = String::from("hello");

let len = s.len();

let slice = &s[0..len];
let slice = &s[..];
```

> 注意：String slice 的範圍索引必須位於有效的 UTF-8 字元邊界上。如果你嘗試在多位元組字元的 middle 建立一個 string slice，你的程式將會因錯誤而退出。

考慮到所有這些資訊，讓我們重新編寫 `first_word` 以回傳一個 slice。表示「string slice」的型別寫作 `&str`：

src/main.rs

```rust
fn first_word(s: &String) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..]
}
```

我們像在範例 4-7 中一樣，透過尋找空格的第一次出現來獲取單字結尾的索引。當我們找到一個空格時，我們使用字串的開頭和空格的索引作為起始和結束索引，回傳一個 string slice。

現在當我們呼叫 `first_word` 時，我們回傳一個與基礎資料綁定在一起的單一值。該值由一個指向 slice 起始點的 reference 和 slice 中元素的數量組成。

回傳 slice 也適用於 `second_word` 函式：

```rust
fn second_word(s: &String) -> &str {
```

我們現在有一個簡單的 API，它更難出錯，因為編譯器將確保指向 `String` 的 reference 保持有效。還記得範例 4-8 中的程式碼錯誤嗎？當時我們取得了第一個單字結尾的索引，但隨後清空了字串，導致我們的索引無效。那段程式碼在邏輯上是不正確的，但沒有立即顯示任何錯誤。問題會在我們繼續嘗試將第一個單字索引與已清空的字串一起使用時才出現。Slices 使得這個錯誤不可能發生，並讓我們更早地知道程式碼中存在問題。使用 `first_word` 的 slice 版本將會拋出編譯期錯誤：

src/main.rs

```rust
fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&s);

    s.clear(); // 錯誤！

    println!("the first word is: {word}");
}
```

這是編譯器錯誤：

```
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
  --> src/main.rs:18:5
   |
16 |     let word = first_word(&s);
   |                           -- immutable borrow occurs here
17 |
18 |     s.clear(); // error!
   |     ^^^^^^^^^ mutable borrow occurs here
19 |
20 |     println!("the first word is: {word}");
   |                                  ------ immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership` (bin "ownership") due to 1 previous error
```

呼！回想一下 borrowing 規則，如果我們有一個東西的不可變 reference，我們就不能同時擁有一個可變 reference。因為 `clear` 需要截斷 `String`，所以它需要取得一個可變 reference。在呼叫 `clear` 之後的 `println!` 使用了 `word` 中的 reference，所以不可變 reference 在那個時間點必須仍然活躍。Rust 不允許 `clear` 中的可變 reference 和 `word` 中的不可變 reference 同時存在，因此編譯失敗。Rust 不僅讓我們的 API 更易於使用，而且還在編譯期消除了整類錯誤！

<a id="string-literals-are-slices"></a>

#### 字串常值作為 Slices

回想一下我們討論過字串常值儲存在二進位檔案中。現在我們了解了 slices，我們可以正確理解字串常值：

```rust
let s = "Hello, world!";
```

這裡 `s` 的型別是 `&str`：它是一個指向二進位檔案中該特定位置的 slice。這也是為什麼字串常值是不可變的；`&str` 是一個不可變 reference。

#### String Slices 作為參數

知道你可以從常值和 `String` 值中取得 slices，這讓我們的 `first_word` 函式還有一個改進空間，那就是它的簽章：

```rust
fn first_word(s: &String) -> &str {
```

經驗豐富的 Rustacean 會編寫範例 4-9 中所示的簽章，因為它允許我們對 `&String` 值和 `&str` 值使用相同的函式。

```rust
fn first_word(s: &str) -> &str {
```

範例 4-9：透過使用 string slice 作為 `s` 參數的型別來改進 `first_word` 函式

如果我們有一個 string slice，我們可以直接傳遞它。如果我們有一個 `String`，我們可以傳遞 `String` 的 slice 或 `String` 的 reference。這種靈活性利用了 *deref coercions*，我們將在第 15 章的「函式與方法中的隱式 Deref 強制轉型」部分中涵蓋此功能。

將函式定義為接收 string slice 而不是 `String` 的 reference，使得我們的 API 更通用且更有用，同時不損失任何功能：

src/main.rs

```rust
fn main() {
    let my_string = String::from("hello world");

    // `first_word` 適用於 `String` 的 slices，無論是部分還是整體。
    let word = first_word(&my_string[0..6]);
    let word = first_word(&my_string[..]);
    // `first_word` 也適用於 `String` 的 references，這等同於
    // `String` 的完整 slices。
    let word = first_word(&my_string);

    let my_string_literal = "hello world";

    // `first_word` 適用於字串常值的 slices，無論是部分還是
    // 整體。
    let word = first_word(&my_string_literal[0..6]);
    let word = first_word(&my_string_literal[..]);

    // 因為字串常值 *本身就是* string slices，
    // 這也有效，不需要 slice 語法！
    let word = first_word(my_string_literal);
}
```

### 其他 Slices

顧名思義，String slices 專用於字串。但還有一種更通用的 slice 型別。考慮這個陣列：

```rust
let a = [1, 2, 3, 4, 5];
```

就像我們可能想要參照字串的一部分一樣，我們可能想要參照陣列的一部分。我們會這樣做：

```rust
let a = [1, 2, 3, 4, 5];

let slice = &a[1..3];

assert_eq!(slice, &[2, 3]);
```

這個 slice 的型別是 `&[i32]`。它的運作方式與 string slices 相同，透過儲存對第一個元素的 reference 和一個長度。你會將這種 slice 用於各種其他集合。我們將在第 8 章討論 vector 時詳細討論這些集合。

## 總結

ownership、borrowing 和 slices 的概念在編譯期確保了 Rust 程式的記憶體安全。Rust 語言讓你能夠像其他系統程式語言一樣控制記憶體使用，但當資料的 owner 離開作用域時自動清理該資料，這意味著你無需編寫和調試額外的程式碼即可獲得這種控制。

ownership 影響著 Rust 許多其他部分的運作方式，因此我們將在本書的其餘部分進一步討論這些概念。讓我們繼續進入第 5 章，看看如何在 `struct` 中將資料片段組合在一起。