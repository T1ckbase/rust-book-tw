<!-- DO NOT EDIT THIS FILE.

This file is periodically generated from the content in the `/src/`
directory, so all fixes need to be made in `/src/`.
-->

[目錄]

# 模式與匹配

_模式_ (Patterns) 是 Rust 中用於匹配複雜與簡單型別結構的特殊語法。結合 `match` 運算式與其他構造，使用模式能讓你對程式的控制流程有更多掌握。一個模式由以下項目組合而成：

- 常值 (Literals)
- 解構 (Destructured) 陣列 (arrays)、列舉 (enums)、結構 (structs) 或元組 (tuples)
- 變數 (Variables)
- 萬用字元 (Wildcards)
- 佔位符 (Placeholders)

一些模式範例包括 `x`、`(a, 3)` 和 `Some(Color::Red)`。在模式有效的上下文中，這些組件描述了資料的形狀。然後我們的程式將值與模式進行匹配，以判斷資料形狀是否正確，以便繼續執行特定的程式碼片段。

要使用一個模式，我們將其與某個值進行比較。如果模式匹配該值，我們就可以在程式碼中使用該值的各部分。回想在[第 6 章](https://doc.rust-lang.org/book/ch06-00-enums-and-pattern-matching.html)中使用的 `match` 運算式，例如硬幣分類機範例。如果值符合模式的形狀，我們就可以使用命名的部分。如果不符合，與該模式相關的程式碼就不會執行。

本章是關於模式相關內容的參考。我們將涵蓋模式的有效使用位置、可拒絕 (refutable) 模式與不可拒絕 (irrefutable) 模式之間的區別，以及你可能遇到的不同模式語法。在本章結束時，你將知道如何使用模式以清晰的方式表達許多概念。

## 模式可以使用的所有位置

模式在 Rust 的許多地方都會出現，而且你一直在大量使用它們而沒有意識到！本節將討論模式有效的所有位置。

### match 匹配分支

如[第 6 章](https://doc.rust-lang.org/book/ch06-00-enums-and-pattern-matching.html)所討論的，我們在 `match` 運算式的匹配分支 (arms) 中使用模式。形式上，`match` 運算式定義為 `match` 關鍵字、要匹配的值，以及一個或多個匹配分支，每個分支由一個模式和一個在值匹配該分支模式時執行的運算式組成，如下所示：

<!--
  Manually formatted rather than using Markdown intentionally: Markdown does not
  support italicizing code in the body of a block like this!
-->

<pre><code>match <em>VALUE</em> {
    <em>PATTERN</em> => <em>EXPRESSION</em>,
    <em>PATTERN</em> => <em>EXPRESSION</em>,
    <em>PATTERN</em> => <em>EXPRESSION</em>,
}</code></pre>

例如，這是[範例 6-5](https://doc.rust-lang.org/book/ch06-02-match.html#listing-6-5) 中的 `match` 運算式，它匹配變數 `x` 中的 `Option<i32>` 值：

```rust
match x {
    None => None,
    Some(i) => Some(i + 1),
}
```

這個 `match` 運算式中的模式是每個箭頭左側的 `None` 和 `Some(i)`。

`match` 運算式的一個要求是它們必須是_窮盡的_ (exhaustive)，這意味著 `match` 運算式中值的所有可能性都必須被考慮在內。確保你涵蓋了所有可能性的一種方法是為最後一個匹配分支設定一個全匹配模式 (catch-all pattern)：例如，匹配任何值的變數名稱永遠不會失敗，因此涵蓋了所有剩餘的情況。

特定的模式 `_` 會匹配任何內容，但它從不綁定到變數，因此它通常用於最後的匹配分支。當你想忽略任何未指定的值時，`_` 模式會很有用。我們將在本章後面的「在模式中忽略值」中更詳細地介紹 `_` 模式。

### let 陳述式

在本章之前，我們只明確討論了在 `match` 和 `if let` 中使用模式，但實際上，我們也在其他地方使用了模式，包括在 `let` 陳述式中。例如，考慮這個使用 `let` 的簡單變數賦值：

```rust
let x = 5;
```

每次你使用像這樣的 `let` 陳述式時，你都一直在使用模式，儘管你可能沒有意識到！更正式地說，`let` 陳述式看起來像這樣：

<!--
  Manually formatted rather than using Markdown intentionally: Markdown does not
  support italicizing code in the body of a block like this!
-->

<pre>
<code>let <em>PATTERN</em> = <em>EXPRESSION</em>;</code>
</pre>

在像 `let x = 5;` 這樣的陳述式中，PATTERN 槽位中的變數名稱只是一種特別簡單的模式形式。Rust 會將運算式與模式進行比較，並賦值它找到的任何名稱。因此，在 `let x = 5;` 範例中，`x` 是一個模式，意思是「將這裡匹配到的內容綁定到變數 `x`」。由於名稱 `x` 是整個模式，因此這個模式實際上意味著「將所有內容綁定到變數 `x`，無論其值是什麼。」

為了更清楚地看到 `let` 的模式匹配方面，請考慮[範例 19-1](https://doc.rust-lang.org/book/ch19-01-all-the-places-patterns-can-be-used.html#listing-19-1)，它使用帶有 `let` 的模式來解構一個元組。

```rust
let (x, y, z) = (1, 2, 3);
```

範例 19-1：使用模式解構元組並一次創建三個變數

在這裡，我們將一個元組與一個模式進行匹配。Rust 將值 `(1, 2, 3)` 與模式 `(x, y, z)` 進行比較，並看到值匹配模式，因為兩者中的元素數量相同，所以 Rust 將 `1` 綁定到 `x`，`2` 綁定到 `y`，`3` 綁定到 `z`。你可以將這個元組模式視為其中嵌套了三個單獨的變數模式。

如果模式中的元素數量與元組中的元素數量不匹配，則總體型別將不匹配，我們將會得到一個編譯器錯誤。例如，[範例 19-2](https://doc.rust-lang.org/book/ch19-01-all-the-places-patterns-can-be-used.html#listing-19-2) 顯示了嘗試將一個包含三個元素的元組解構為兩個變數，這將不起作用。

```rust
let (x, y) = (1, 2, 3);
```

範例 19-2：錯誤地建構模式，其變數不匹配元組中的元素數量

嘗試編譯這段程式碼會導致以下型別錯誤：

```
$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error[E0308]: mismatched types
 --> src/main.rs:2:9
  |
2 |     let (x, y) = (1, 2, 3);
  |         ^^^^^^   --------- this expression has type `({integer}, {integer}, {integer})`
  |         |
  |         expected a tuple with 3 elements, found one with 2 elements
  |
  = note: expected tuple `({integer}, {integer}, {integer})`
             found tuple `(_, _)`

For more information about this error, try `rustc --explain E0308`.
error: could not compile `patterns` (bin "patterns") due to 1 previous error
```

為了修復這個錯誤，我們可以像在「在模式中忽略值」一節中看到的那樣，使用 `_` 或 `..` 忽略元組中的一個或多個值。如果問題是模式中變數太多，解決方案是透過移除變數來使型別匹配，以便變數數量等於元組中元素的數量。

### 條件 if let 運算式

在[第 6 章](https://doc.rust-lang.org/book/ch06-00-enums-and-pattern-matching.html)中，我們討論了如何使用 `if let` 運算式，主要作為編寫只匹配一個案例的 `match` 運算式的簡短方式。可選擇地，`if let` 可以有一個對應的 `else`，其中包含在 `if let` 中的模式不匹配時要執行的程式碼。

[範例 19-3](https://doc.rust-lang.org/book/ch19-01-all-the-places-patterns-can-be-used.html#listing-19-3) 顯示了將 `if let`、`else if` 和 `else if let` 運算式混合搭配也是可能的。這樣做比 `match` 運算式提供了更大的靈活性，在 `match` 運算式中我們只能表達一個值與模式進行比較。此外，Rust 不要求一系列 `if let`、`else if` 和 `else if let` 分支中的條件相互關聯。

[範例 19-3](https://doc.rust-lang.org/book/ch19-01-all-the-places-patterns-can-be-used.html#listing-19-3) 中的程式碼根據一系列條件檢查來決定你的背景顏色。對於這個範例，我們創建了帶有硬編碼值的變數，這些值在實際程式中可能來自使用者輸入。

src/main.rs

```rust
fn main() {
    let favorite_color: Option<&str> = None;
    let is_tuesday = false;
    let age: Result<u8, _> = "34".parse();

    if let Some(color) = favorite_color {
        println!("Using your favorite color, {color}, as the background");
    } else if is_tuesday {
        println!("Tuesday is green day!");
    } else if let Ok(age) = age {
        if age > 30 {
            println!("Using purple as the background color");
        } else {
            println!("Using orange as the background color");
        }
    } else {
        println!("Using blue as the background color");
    }
}
```

範例 19-3：混合使用 `if let`、`else if`、`else if let` 和 `else`

如果使用者指定了喜歡的顏色，則該顏色將用作背景。如果未指定喜歡的顏色且今天是星期二，則背景顏色為綠色。否則，如果使用者將其年齡指定為字串並且我們可以成功將其解析為數字，則顏色為紫色或橙色，具體取決於數字的值。如果這些條件都不適用，則背景顏色為藍色。

這種條件結構使我們能夠支援複雜的要求。對於我們這裡硬編碼的值，這個範例將印出 `Using purple as the background color`。

你可以看到 `if let` 也可以引入新的變數，其遮蔽現有變數的方式與 `match` 分支相同：`if let Ok(age) = age` 這一行引入了一個新的 `age` 變數，其中包含 `Ok` 變體內的值，遮蔽了現有的 `age` 變數。這意味著我們需要將 `if age > 30` 條件放置在該程式碼區塊內：我們無法將這兩個條件組合為 `if let Ok(age) = age && age > 30`。我們想要與 30 比較的新的 `age` 在大括號開始的新作用域之前是無效的。

使用 `if let` 運算式的缺點是編譯器不檢查窮盡性，而 `match` 運算式則會檢查。如果我們省略了最後的 `else` 區塊，因此錯過了處理某些情況，編譯器將不會提醒我們可能存在的邏輯錯誤。

### while let 條件迴圈

與 `if let` 的結構相似，`while let` 條件迴圈允許 `while` 迴圈在模式持續匹配的情況下執行。在[範例 19-4](https://doc.rust-lang.org/book/ch19-01-all-the-places-patterns-can-be-used.html#listing-19-4) 中，我們展示了一個 `while let` 迴圈，它等待執行緒之間傳送的訊息，但在這種情況下，檢查 `Result` 而不是 `Option`。

```rust
    let (tx, rx) = std::sync::mpsc::channel();
    std::thread::spawn(move || {
        for val in [1, 2, 3] {
            tx.send(val).unwrap();
        }
    });

    while let Ok(value) = rx.recv() {
        println!("{value}");
    }
```

範例 19-4：使用 `while let` 迴圈在 `rx.recv()` 返回 `Ok` 時印出值

這個範例將印出 `1`、`2`，然後是 `3`。`recv` 方法從通道的接收端取出第一個訊息並返回 `Ok(value)`。當我們在[第 16 章](https://doc.rust-lang.org/book/ch16-00-concurrency.html)第一次看到 `recv` 時，我們直接解開了錯誤，或者使用 `for` 迴圈與它作為迭代器互動。然而，如[範例 19-4](https://doc.rust-lang.org/book/ch19-01-all-the-places-patterns-can-be-used.html#listing-19-4) 所示，我們也可以使用 `while let`，因為只要傳送端存在，`recv` 方法每次接收到訊息時都會返回 `Ok`，然後一旦傳送端斷開連接，就會產生 `Err`。

### for 迴圈

在 `for` 迴圈中，`for` 關鍵字後面的值是一個模式。例如，在 `for x in y` 中，`x` 就是模式。[範例 19-5](https://doc.rust-lang.org/book/ch19-01-all-the-places-patterns-can-be-used.html#listing-19-5) 演示了如何在 `for` 迴圈中使用模式來_解構_ (destructure) 或拆解 (break apart) 元組，作為 `for` 迴圈的一部分。

```rust
    let v = vec!['a', 'b', 'c'];

    for (index, value) in v.iter().enumerate() {
        println!("{value} is at index {index}");
    }
```

範例 19-5：在 `for` 迴圈中使用模式解構元組

[範例 19-5](https://doc.rust-lang.org/book/ch19-01-all-the-places-patterns-can-be-used.html#listing-19-5) 中的程式碼將印出以下內容：

```
$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.52s
     Running `target/debug/patterns`
a is at index 0
b is at index 1
c is at index 2
```

我們使用 `enumerate` 方法調整一個迭代器，使其產生一個值和該值的索引，並將其放入一個元組中。產生的第一個值是元組 `(0, 'a')`。當這個值與模式 `(index, value)` 匹配時，`index` 將為 `0`，`value` 將為 `'a'`，印出輸出的第一行。

### 函數參數

函數參數也可以是模式。[範例 19-6](https://doc.rust-lang.org/book/ch19-01-all-the-places-patterns-can-be-used.html#listing-19-6) 中的程式碼宣告了一個名為 `foo` 的函數，它接受一個名為 `x` 且型別為 `i32` 的參數，這對你來說現在應該很熟悉了。

```rust
fn foo(x: i32) {
    // code goes here
}
```

範例 19-6：函數簽章在參數中使用模式

`x` 部分就是一個模式！就像我們使用 `let` 一樣，我們可以在函數參數中匹配一個元組到模式。 [範例 19-7](https://doc.rust-lang.org/book/ch19-01-all-the-places-patterns-can-be-used.html#listing-19-7) 在我們將元組傳遞給函數時，將其值分割開來。

src/main.rs

```rust
fn print_coordinates(&(x, y): &(i32, i32)) {
    println!("Current location: ({x}, {y})");
}

fn main() {
    let point = (3, 5);
    print_coordinates(&point);
}
```

範例 19-7：函數參數解構元組

這段程式碼會印出 `Current location: (3, 5)`。值 `&(3, 5)` 與模式 `&(x, y)` 匹配，所以 `x` 的值是 `3`，`y` 的值是 `5`。

我們也可以在閉包參數列表中以與函數參數列表相同的方式使用模式，因為閉包與函數相似，如[第 13 章](https://doc.rust-lang.org/book/ch13-00-functional-features.html)所討論的。

至此，你已經看到了幾種使用模式的方法，但是模式並非在所有可以使用它們的地方都以相同的方式工作。在某些地方，模式必須是不可拒絕的；在其他情況下，它們可以是可拒絕的。我們接下來將討論這兩個概念。

## 可拒絕性：模式是否可能匹配失敗

模式有兩種形式：可拒絕的 (refutable) 和不可拒絕的 (irrefutable)。對於任何可能傳入的值都會匹配的模式是_不可拒絕的_。例如，陳述式 `let x = 5;` 中的 `x` 就是一個例子，因為 `x` 匹配任何內容，因此不可能匹配失敗。對於某些可能的值可能會匹配失敗的模式是_可拒絕的_。例如，運算式 `if let Some(x) = a_value` 中的 `Some(x)` 就是一個例子，因為如果 `a_value` 變數中的值是 `None` 而不是 `Some`，則 `Some(x)` 模式將不匹配。

函數參數、`let` 陳述式和 `for` 迴圈只能接受不可拒絕的模式，因為當值不匹配時，程式無法做任何有意義的事情。`if let` 和 `while let` 運算式以及 `let...else` 陳述式接受可拒絕和不可拒絕的模式，但編譯器會針對不可拒絕的模式發出警告，因為根據定義，它們旨在處理可能的失敗：條件的功能在於它能夠根據成功或失敗執行不同的操作。

通常，你不必擔心可拒絕模式和不可拒絕模式之間的區別；但是，你需要熟悉可拒絕性的概念，這樣當你在錯誤訊息中看到它時才能做出回應。在這些情況下，你需要根據程式碼的預期行為來更改模式或你使用該模式的構造。

讓我們看一個例子，當我們嘗試在 Rust 要求不可拒絕模式的地方使用可拒絕模式，反之亦然時會發生什麼。 [範例 19-8](https://doc.rust-lang.org/book/ch19-02-refutability.html#listing-19-8) 顯示了一個 `let` 陳述式，但在模式方面，我們指定了 `Some(x)`，這是一個可拒絕的模式。正如你可能預期的那樣，這段程式碼將無法編譯。

```rust
let Some(x) = some_option_value;
```

範例 19-8：嘗試將可拒絕模式與 `let` 一起使用

如果 `some_option_value` 是 `None` 值，它將無法匹配模式 `Some(x)`，這意味著該模式是可拒絕的。然而，`let` 陳述式只能接受不可拒絕的模式，因為程式碼無法對 `None` 值執行任何有效操作。在編譯時，Rust 會抱怨我們嘗試在需要不可拒絕模式的地方使用可拒絕模式：

```
$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error[E0005]: refutable pattern in local binding
 --> src/main.rs:3:9
  |
3 |     let Some(x) = some_option_value;
  |         ^^^^^^^ pattern `None` not covered
  |
  = note: `let` bindings require an "irrefutable pattern", like a `struct` or an `enum` with only one variant
  = note: for more information, visit https://doc.rust-lang.org/book/ch19-02-refutability.html
  = note: the matched value is of type `Option<i32>`
help: you might want to use `let else` to handle the variant that isn't matched
  |
3 |     let Some(x) = some_option_value else { todo!() };
  |                                     ++++++++++++++++

For more information about this error, try `rustc --explain E0005`.
error: could not compile `patterns` (bin "patterns") due to 1 previous error
```

因為我們沒有涵蓋 (也無法涵蓋！) 模式 `Some(x)` 的所有有效值，所以 Rust 正確地產生了一個編譯器錯誤。

如果我們在需要不可拒絕模式的地方有一個可拒絕模式，我們可以透過更改使用該模式的程式碼來修復它：我們可以使用 `let else` 而不是 `let`。然後，如果模式不匹配，程式碼將跳過大括號中的程式碼，從而使其能夠有效繼續。 [範例 19-9](https://doc.rust-lang.org/book/ch19-02-refutability.html#listing-19-9) 顯示了如何修復[範例 19-8](https://doc.rust-lang.org/book/ch19-02-refutability.html#listing-19-8) 中的程式碼。

```rust
let Some(x) = some_option_value else {
    return;
};
```

範例 19-9：使用 `let...else` 和帶有可拒絕模式的區塊取代 `let`

我們給了程式碼一個出路！這段程式碼完全有效，儘管這意味著我們無法在不收到警告的情況下使用不可拒絕模式。如果我們給 `let...else` 一個總是會匹配的模式，例如 `x`，如[範例 19-10](https://doc.rust-lang.org/book/ch19-02-refutability.html#listing-19-10) 所示，編譯器將給出警告。

```rust
let x = 5 else {
    return;
};
```

範例 19-10：嘗試將不可拒絕模式與 `let...else` 一起使用

Rust 抱怨將 `let...else` 與不可拒絕模式一起使用是沒有意義的：

```
$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
warning: irrefutable `let...else` pattern
 --> src/main.rs:2:5
  |
2 |     let x = 5 else {
  |     ^^^^^^^^^
  |
  = note: this pattern will always match, so the `else` clause is useless
  = help: consider removing the `else` clause
  = note: `#[warn(irrefutable_let_patterns)]` on by default

warning: `patterns` (bin "patterns") generated 1 warning
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.39s
     Running `target/debug/patterns`
```

因此，`match` 分支必須使用可拒絕模式，除了最後一個分支，它應該使用不可拒絕模式來匹配任何剩餘的值。Rust 允許我們在只有一個分支的 `match` 中使用不可拒絕模式，但這種語法不是特別有用，可以用更簡單的 `let` 陳述式代替。

現在你已經知道在哪裡使用模式以及可拒絕模式和不可拒絕模式之間的區別，讓我們來看看所有可以用來創建模式的語法。

## 模式語法

在本節中，我們將收集所有在模式中有效的語法，並討論為什麼以及何時使用它們。

### 匹配常值

正如你在[第 6 章](https://doc.rust-lang.org/book/ch06-00-enums-and-pattern-matching.html)中所看到的，你可以直接將模式與常值進行匹配。以下程式碼給出了一些範例：

```rust
    let x = 1;

    match x {
        1 => println!("one"),
        2 => println!("two"),
        3 => println!("three"),
        _ => println!("anything"),
    }
```

這段程式碼印出 `one`，因為 `x` 中的值是 `1`。當你希望程式碼在獲得特定具體值時執行某個動作時，這種語法很有用。

### 匹配命名變數

命名變數是不可拒絕的模式，它匹配任何值，我們在本書中多次使用過它們。然而，當你在 `match`、`if let` 或 `while let` 運算式中使用命名變數時，會出現一個複雜情況。因為這些類型的每個運算式都會啟動一個新作用域，所以作為這些運算式內部模式的一部分聲明的變數將會遮蔽那些在構造外部具有相同名稱的變數，就像所有變數一樣。在[範例 19-11](https://doc.rust-lang.org/book/ch19-03-pattern-syntax.html#listing-19-11) 中，我們聲明了一個名為 `x` 且值為 `Some(5)` 的變數，以及一個名為 `y` 且值為 `10` 的變數。然後我們在值 `x` 上創建一個 `match` 運算式。看看匹配分支中的模式和末尾的 `println!`，並在執行這段程式碼或繼續閱讀之前嘗試找出它會印出什麼。

src/main.rs

```rust
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) => println!("Got 50"),
        Some(y) => println!("Matched, y = {y}"),
        _ => println!("Default case, x = {x:?}"),
    }

    println!("at the end: x = {x:?}, y = {y}");
```

範例 19-11：帶有匹配分支的 `match` 運算式，該分支引入了一個遮蔽現有變數 `y` 的新變數

讓我們來看看當 `match` 運算式執行時會發生什麼。第一個匹配分支中的模式不匹配 `x` 的定義值，因此程式碼繼續執行。

第二個匹配分支中的模式引入了一個名為 `y` 的新變數，它將匹配 `Some` 值內部的任何值。因為我們在 `match` 運算式內部的一個新作用域中，這是一個新的 `y` 變數，而不是我們一開始用值 `10` 聲明的那個 `y`。這個新的 `y` 綁定將匹配 `Some` 內部的任何值，這正是我們在 `x` 中擁有的。因此，這個新的 `y` 綁定到 `x` 中 `Some` 的內部值。該值是 `5`，所以該分支的運算式執行並印出 `Matched, y = 5`。

如果 `x` 是 `None` 值而不是 `Some(5)`，那麼前兩個分支的模式就不會匹配，所以該值會匹配到底線。我們沒有在底線分支的模式中引入 `x` 變數，所以運算式中的 `x` 仍然是沒有被遮蔽的外部 `x`。在這種假設情況下，`match` 會印出 `Default case, x = None`。

當 `match` 運算式完成時，它的作用域結束，內部 `y` 的作用域也結束。最後的 `println!` 產生 `at the end: x = Some(5), y = 10`。

為了創建一個比較外部 `x` 和 `y` 值，而不是引入一個遮蔽現有 `y` 變數的新變數的 `match` 運算式，我們需要使用匹配守衛條件。我們稍後將在「使用 Match Guards 的額外條件」中討論匹配守衛。

### 多重模式

在 `match` 運算式中，你可以使用 `|` 語法來匹配多個模式，`|` 是模式的*或*運算子。例如，在以下程式碼中，我們將 `x` 的值與匹配分支進行匹配，其中第一個分支有一個*或*選項，這意味著如果 `x` 的值匹配該分支中的任一值，則該分支的程式碼將執行：

```rust
    let x = 1;

    match x {
        1 | 2 => println!("one or two"),
        3 => println!("three"),
        _ => println!("anything"),
    }
```

這段程式碼印出 `one or two`。

### 使用 ..= 匹配值範圍

`..=` 語法允許我們匹配一個包含範圍內的值。在以下程式碼中，當一個模式匹配給定範圍內的任何值時，該分支將執行：

```rust
    let x = 5;

    match x {
        1..=5 => println!("one through five"),
        _ => println!("something else"),
    }
```

如果 `x` 是 `1`、`2`、`3`、`4` 或 `5`，則第一個分支將匹配。這種語法對於多個匹配值來說比使用 `|` 運算子表達相同的概念更方便；如果我們使用 `|`，我們將不得不指定 `1 | 2 | 3 | 4 | 5`。指定範圍要短得多，特別是如果我們想匹配例如 1 到 1,000 之間的任何數字！

編譯器會在編譯時檢查範圍是否為空，並且由於 Rust 只能判斷 `char` 和數值型別的範圍是否為空，因此範圍只允許用於數值或 `char` 值。

這是一個使用 `char` 值範圍的範例：

```rust
    let x = 'c';

    match x {
        'a'..='j' => println!("early ASCII letter"),
        'k'..='z' => println!("late ASCII letter"),
        _ => println!("something else"),
    }
```

Rust 可以判斷 `'c'` 在第一個模式的範圍內，並印出 `early ASCII letter`。

### 解構以拆解值

我們也可以使用模式來解構結構、列舉和元組，以使用這些值的不同部分。讓我們逐一查看每個值。

#### 解構結構

[範例 19-12](https://doc.rust-lang.org/book/ch19-03-pattern-syntax.html#listing-19-12) 展示了一個 `Point` 結構，它有兩個欄位 `x` 和 `y`，我們可以使用 `let` 陳述式和模式來拆解它們。

src/main.rs

```rust
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x: a, y: b } = p;
    assert_eq!(0, a);
    assert_eq!(7, b);
}
```

範例 19-12：將結構的欄位解構為獨立變數

這段程式碼創建了變數 `a` 和 `b`，它們匹配 `p` 結構的 `x` 和 `y` 欄位的值。這個範例表明，模式中變數的名稱不必與結構的欄位名稱匹配。然而，通常會將變數名稱與欄位名稱匹配，以方便記住哪個變數來自哪個欄位。由於這種常見用法，以及因為編寫 `let Point { x: x, y: y } = p;` 包含大量重複，Rust 為匹配結構欄位的模式提供了一個簡寫：你只需要列出結構欄位的名稱，並且從模式創建的變數將具有相同的名稱。 [範例 19-13](https://doc.rust-lang.org/book/ch19-03-pattern-syntax.html#listing-19-13) 的行為與[範例 19-12](https://doc.rust-lang.org/book/ch19-03-pattern-syntax.html#listing-19-12) 中的程式碼相同，但 `let` 模式中創建的變數是 `x` 和 `y` 而不是 `a` 和 `b`。

src/main.rs

```rust
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x, y } = p;
    assert_eq!(0, x);
    assert_eq!(7, y);
}
```

範例 19-13：使用結構欄位簡寫解構結構欄位

這段程式碼創建了變數 `x` 和 `y`，它們匹配 `p` 變數的 `x` 和 `y` 欄位。結果是變數 `x` 和 `y` 包含 `p` 結構中的值。

我們也可以在結構模式中包含常值，而不是為所有欄位創建變數。這樣可以讓我們測試部分欄位的特定值，同時為其他欄位創建變數進行解構。

在[範例 19-14](https://doc.rust-lang.org/book/ch19-03-pattern-syntax.html#listing-19-14) 中，我們有一個 `match` 運算式，它將 `Point` 值分為三種情況：直接位於 `x` 軸上的點 (當 `y = 0` 時為真)、`y` 軸上的點 (`x = 0`)，或不在任何軸上的點。

src/main.rs

```rust
fn main() {
    let p = Point { x: 0, y: 7 };

    match p {
        Point { x, y: 0 } => println!("On the x axis at {x}"),
        Point { x: 0, y } => println!("On the y axis at {y}"),
        Point { x, y } => {
            println!("On neither axis: ({x}, {y})");
        }
    }
}
```

範例 19-14：在一個模式中解構並匹配常值

第一個匹配分支將匹配任何位於 `x` 軸上的點，方法是指定如果 `y` 欄位的值匹配常值 `0` 則匹配。該模式仍然會創建一個 `x` 變數，我們可以在該分支的程式碼中使用。

同樣地，第二個分支透過指定當 `x` 欄位的值為 `0` 時匹配 `y` 軸上的任何點，並為 `y` 欄位的值創建一個變數 `y`。第三個分支沒有指定任何常值，所以它匹配任何其他 `Point` 並為 `x` 和 `y` 欄位創建變數。

在這個範例中，值 `p` 因為 `x` 包含 `0` 而匹配第二個分支，所以這段程式碼將印出 `On the y axis at 7`。

請記住，`match` 運算式一旦找到第一個匹配模式就會停止檢查其他分支，所以即使 `Point { x: 0, y: 0}` 同時在 `x` 軸和 `y` 軸上，這段程式碼也只會印出 `On the x axis at 0`。

#### 解構列舉

我們在本書中已經解構了列舉 (例如，[第 6 章](https://doc.rust-lang.org/book/ch06-00-enums-and-pattern-matching.html)的[範例 6-5](https://doc.rust-lang.org/book/ch06-02-match.html#listing-6-5))，但尚未明確討論解構列舉的模式如何與列舉中儲存資料的定義方式相對應。作為一個範例，在[範例 19-15](https://doc.rust-lang.org/book/ch19-03-pattern-syntax.html#listing-19-15) 中，我們使用[範例 6-2](https://doc.rust-lang.org/book/ch06-02-match.html#listing-6-2) 中的 `Message` 列舉，並編寫一個帶有模式的 `match`，該模式將解構每個內部值。

src/main.rs

```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msg = Message::ChangeColor(0, 160, 255);

    match msg {
        Message::Quit => {
            println!("The Quit variant has no data to destructure.");
        }
        Message::Move { x, y } => {
            println!("Move in the x direction {x} and in the y direction {y}");
        }
        Message::Write(text) => {
            println!("Text message: {text}");
        }
        Message::ChangeColor(r, g, b) => {
            println!("Change color to red {r}, green {g}, and blue {b}");
        }
    }
}
```

範例 19-15：解構持有不同類型值的列舉變體

這段程式碼將印出 `Change color to red 0, green 160, and blue 255`。嘗試更改 `msg` 的值以查看其他分支的程式碼執行。

對於沒有任何資料的列舉變體，例如 `Message::Quit`，我們無法進一步解構該值。我們只能匹配常值 `Message::Quit`，且該模式中沒有任何變數。

對於結構體般的列舉變體，例如 `Message::Move`，我們可以使用的模式類似於我們指定匹配結構體的模式。在變體名稱之後，我們放置大括號，然後列出帶有變數的欄位，以便我們將各部分拆解以用於該分支的程式碼。在這裡，我們使用與[範例 19-13](https://doc.rust-lang.org/book/ch19-03-pattern-syntax.html#listing-19-13) 中相同的簡寫形式。

對於元組般的列舉變體，例如包含一個元素的元組的 `Message::Write` 和包含三個元素的元組的 `Message::ChangeColor`，其模式與我們指定匹配元組的模式相似。模式中變數的數量必須與我們正在匹配的變體中元素的數量匹配。

#### 解構嵌套結構與列舉

目前為止，我們的範例都只匹配一層深的結構或列舉，但匹配也可以作用於嵌套項目！例如，我們可以重構[範例 19-15](https://doc.rust-lang.org/book/ch19-03-pattern-syntax.html#listing-19-15) 中的程式碼，以支援 `ChangeColor` 訊息中的 RGB 和 HSV 顏色，如[範例 19-16](https://doc.rust-lang.org/book/ch19-03-pattern-syntax.html#listing-19-16) 所示。

```rust
enum Color {
    Rgb(i32, i32, i32),
    Hsv(i32, i32, i32),
}

enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(Color),
}

fn main() {
    let msg = Message::ChangeColor(Color::Hsv(0, 160, 255));

    match msg {
        Message::ChangeColor(Color::Rgb(r, g, b)) => {
            println!("Change color to red {r}, green {g}, and blue {b}");
        }
        Message::ChangeColor(Color::Hsv(h, s, v)) => {
            println!("Change color to hue {h}, saturation {s}, value {v}");
        }
        _ => (),
    }
}
```

範例 19-16：匹配嵌套列舉

`match` 運算式中第一個分支的模式匹配包含 `Color::Rgb` 變體的 `Message::ChangeColor` 列舉變體；然後模式綁定到三個內部 `i32` 值。第二個分支的模式也匹配 `Message::ChangeColor` 列舉變體，但內部列舉匹配 `Color::Hsv`。我們可以在一個 `match` 運算式中指定這些複雜條件，即使涉及兩個列舉。

#### 解構結構和元組

我們可以以更複雜的方式混合、匹配和嵌套解構模式。以下範例顯示了一個複雜的解構，我們將結構和元組嵌套在一個元組中，並將所有基本值解構出來：

```rust
let ((feet, inches), Point { x, y }) = ((3, 10), Point { x: 3, y: -10 });
```

這段程式碼讓我們將複雜的型別分解成它們的組成部分，這樣我們就可以單獨使用我們感興趣的值。

透過模式進行解構是一種方便的方式來使用值的片段，例如結構中每個欄位的值，彼此獨立。

### 在模式中忽略值

你已經看到，有時在模式中忽略值很有用，例如在 `match` 的最後一個分支中，以獲得一個全匹配 (catch-all) 模式，它實際上不執行任何操作，但確實考慮了所有剩餘的可能值。有幾種方法可以在模式中忽略整個值或部分值：使用 `_` 模式（你已經看到過）、在另一個模式中使用 `_` 模式、使用以下劃線開頭的名稱，或者使用 `..` 忽略值的剩餘部分。讓我們探討如何以及為何使用這些模式。

<!-- Old link, do not remove -->

<a id="ignoring-an-entire-value-with-_"></a>

#### 整個值使用 \_

我們已將底線用作萬用字元模式，它將匹配任何值，但不會綁定到該值。這在 `match` 運算式中作為最後一個分支特別有用，但我們也可以在任何模式中使用它，包括函數參數，如[範例 19-17](https://doc.rust-lang.org/book/ch19-03-pattern-syntax.html#listing-19-17) 所示。

src/main.rs

```rust
fn foo(_: i32, y: i32) {
    println!("This code only uses the y parameter: {y}");
}

fn main() {
    foo(3, 4);
}
```

範例 19-17：在函數簽章中使用 `_`

這段程式碼將完全忽略作為第一個參數傳入的值 `3`，並印出 `This code only uses the y parameter: 4`。

在大多數情況下，當你不再需要特定的函數參數時，你會更改其簽章，使其不包含未使用的參數。忽略函數參數在某些情況下特別有用，例如，當你實現一個 trait 時，你需要某種型別簽章，但你的實現中的函數本體不需要其中一個參數。這樣，你就可以避免收到關於未使用函數參數的編譯器警告，就像你使用名稱一樣。

<a id="ignoring-parts-of-a-value-with-a-nested-_"></a>

#### 部分值使用嵌套的 \_

我們也可以在另一個模式中使用 `_` 來只忽略值的一部分，例如，當我們只想測試值的一部分但不需要在相應的程式碼中使用其他部分時。 [範例 19-18](https://doc.rust-lang.org/book/ch19-03-pattern-syntax.html#listing-19-18) 顯示了負責管理設定值的程式碼。業務需求是使用者不應被允許覆寫現有的設定自訂，但可以取消設定並在目前未設定的情況下賦予它一個值。

```rust
    let mut setting_value = Some(5);
    let new_setting_value = Some(10);

    match (setting_value, new_setting_value) {
        (Some(_), Some(_)) => {
            println!("Can't overwrite an existing customized value");
        }
        _ => {
            setting_value = new_setting_value;
        }
    }

    println!("setting is {setting_value:?}");
```

範例 19-18：當我們不需要使用 `Some` 內的值時，在匹配 `Some` 變體的模式中使用底線

這段程式碼將印出 `Can't overwrite an existing customized value`，然後是 `setting is Some(5)`。在第一個匹配分支中，我們不需要匹配或使用任何 `Some` 變體內的值，但我們確實需要測試 `setting_value` 和 `new_setting_value` 都是 `Some` 變體的情況。在這種情況下，我們印出不更改 `setting_value` 的原因，並且它不會被更改。

在所有其他情況下（如果 `setting_value` 或 `new_setting_value` 是 `None`），由第二個分支中的 `_` 模式表示，我們希望允許 `new_setting_value` 成為 `setting_value`。

我們也可以在一個模式中的多個位置使用底線來忽略特定值。[範例 19-19](https://doc.rust-lang.org/book/ch19-03-pattern-syntax.html#listing-19-19) 顯示了一個忽略五個項目元組中的第二個和第四個值的範例。

```rust
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, _, third, _, fifth) => {
            println!("Some numbers: {first}, {third}, {fifth}");
        }
    }
```

範例 19-19：忽略元組的多個部分

這段程式碼將印出 `Some numbers: 2, 8, 32`，並且值 `4` 和 `16` 將被忽略。

<!-- Old link, do not remove -->

<a id="ignoring-an-unused-variable-by-starting-its-name-with-_"></a>

#### 以下劃線開頭的未使用變數

如果你創建了一個變數但沒有在任何地方使用它，Rust 通常會發出警告，因為未使用的變數可能是一個錯誤。然而，有時能夠創建一個你尚未使用的變數是很有用的，例如當你正在原型設計或剛開始一個專案時。在這種情況下，你可以透過將變數名稱以下劃線開頭來告訴 Rust 不要警告你該未使用的變數。在[範例 19-20](https://doc.rust-lang.org/book/ch19-03-pattern-syntax.html#listing-19-20) 中，我們創建了兩個未使用的變數，但當我們編譯這段程式碼時，我們應該只會收到其中一個的警告。

src/main.rs

```rust
fn main() {
    let _x = 5;
    let y = 10;
}
```

範例 19-20：變數名稱以下劃線開頭以避免未使用變數警告

在這裡，我們收到了關於未使用變數 `y` 的警告，但沒有收到關於未使用 `_x` 的警告。

請注意，僅使用 `_` 與使用以下劃線開頭的名稱之間存在細微差別。`_x` 語法仍然將值綁定到變數，而 `_` 根本不綁定。為了展示這種區別在哪裡很重要，[範例 19-21](https://doc.rust-lang.org/book/ch19-03-pattern-syntax.html#listing-19-21) 將給我們一個錯誤。

```rust
    let s = Some(String::from("Hello!"));

    if let Some(_s) = s {
        println!("found a string");
    }

    println!("{s:?}");
```

範例 19-21：以下劃線開頭的未使用變數仍然會綁定值，這可能會取得值的所有權。

我們將收到一個錯誤，因為 `s` 的值仍將被移動到 `_s` 中，這會阻止我們再次使用 `s`。然而，單獨使用底線根本不會綁定到值。[範例 19-22](https://doc.rust-lang.org/book/ch19-03-pattern-syntax.html#listing-19-22) 將編譯而沒有任何錯誤，因為 `s` 沒有被移動到 `_` 中。

```rust
    let s = Some(String::from("Hello!"));

    if let Some(_) = s {
        println!("found a string");
    }

    println!("{s:?}");
```

範例 19-22：使用底線不會綁定值。

這段程式碼運行良好，因為我們從未將 `s` 綁定到任何東西；它沒有被移動。

<a id="ignoring-remaining-parts-of-a-value-with-"></a>

#### 剩餘部分值使用 ..

對於具有許多部分的值，我們可以利用 `..` 語法來使用特定部分並忽略其餘部分，避免了為每個被忽略的值列出底線的麻煩。`..` 模式會忽略我們在模式其餘部分沒有明確匹配的任何值部分。在[範例 19-23](https://doc.rust-lang.org/book/ch19-03-pattern-syntax.html#listing-19-23) 中，我們有一個 `Point` 結構，它表示三維空間中的座標。在 `match` 運算式中，我們只想對 `x` 座標進行操作，並忽略 `y` 和 `z` 欄位中的值。

```rust
    struct Point {
        x: i32,
        y: i32,
        z: i32,
    }

    let origin = Point { x: 0, y: 0, z: 0 };

    match origin {
        Point { x, .. } => println!("x is {x}"),
    }
```

範例 19-23：透過使用 `..` 忽略 `Point` 除了 `x` 之外的所有欄位

我們列出 `x` 值，然後只包含 `..` 模式。這比必須列出 `y: _` 和 `z: _` 更快，特別是當我們處理的結構有很多欄位，而在某些情況下只有一兩個欄位相關時。

`..` 語法將擴展為它需要的任意多個值。 [範例 19-24](https://doc.rust-lang.org/book/ch19-03-pattern-syntax.html#listing-19-24) 展示了如何與元組一起使用 `..`。

src/main.rs

```rust
fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, .., last) => {
            println!("Some numbers: {first}, {last}");
        }
    }
```

範例 19-24：僅匹配元組中的第一個和最後一個值，並忽略所有其他值

在這段程式碼中，第一個和最後一個值分別與 `first` 和 `last` 匹配。`..` 將匹配並忽略中間的所有內容。

然而，使用 `..` 必須是明確的。如果無法清楚地判斷哪些值用於匹配，哪些值應該被忽略，Rust 將會給我們一個錯誤。[範例 19-25](https://doc.rust-lang.org/book/ch19-03-pattern-syntax.html#listing-19-25) 顯示了一個模糊地使用 `..` 的範例，因此它將無法編譯。

src/main.rs

```rust
fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (.., second, ..) => {
            println!("Some numbers: {second}")
        },
    }
}
```

範例 19-25：嘗試以不明確的方式使用 `..`

當我們編譯這個範例時，我們會得到這個錯誤：

```
$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error: `..` can only be used once per tuple pattern
 --> src/main.rs:5:22
  |
5 |         (.., second, ..) => {
  |          --          ^^ can only be used once per tuple pattern
  |          |
  |          previously used here

error: could not compile `patterns` (bin "patterns") due to 1 previous error
```

Rust 無法判斷在匹配 `second` 之前要忽略元組中的多少個值，然後之後還要忽略多少個值。這段程式碼可能意味著我們想忽略 `2`，將 `second` 綁定到 `4`，然後忽略 `8`、`16` 和 `32`；或者我們想忽略 `2` 和 `4`，將 `second` 綁定到 `8`，然後忽略 `16` 和 `32`；等等。變數名稱 `second` 對 Rust 沒有任何特殊意義，所以我們得到了編譯器錯誤，因為像這樣在兩個地方使用 `..` 是不明確的。

### 使用 Match Guards 的額外條件

_匹配守衛_ (match guard) 是一個額外的 `if` 條件，在 `match` 分支的模式之後指定，也必須匹配才能選擇該分支。匹配守衛對於表達比單獨模式允許的更複雜的想法很有用。但請注意，它們僅在 `match` 運算式中可用，而不適用於 `if let` 或 `while let` 運算式。

該條件可以使用模式中創建的變數。[範例 19-26](https://doc.rust-lang.org/book/ch19-03-pattern-syntax.html#listing-19-26) 顯示了一個 `match`，其中第一個分支的模式是 `Some(x)`，並且還有一個 `if x % 2 == 0` 的匹配守衛（如果數字是偶數，則為 `true`）。

```rust
    let num = Some(4);

    match num {
        Some(x) if x % 2 == 0 => println!("The number {x} is even"),
        Some(x) => println!("The number {x} is odd"),
        None => (),
    }
```

範例 19-26：為模式添加匹配守衛

這個範例將印出 `The number 4 is even`。當 `num` 與第一個分支中的模式進行比較時，它匹配成功，因為 `Some(4)` 匹配 `Some(x)`。然後匹配守衛檢查 `x` 除以 2 的餘數是否等於 0，由於是，所以選擇第一個分支。

如果 `num` 曾經是 `Some(5)`，那麼第一個分支中的匹配守衛將為 `false`，因為 5 除以 2 的餘數是 1，不等於 0。Rust 會轉到第二個分支，該分支將匹配，因為第二個分支沒有匹配守衛，因此匹配任何 `Some` 變體。

沒有辦法在模式中表達 `if x % 2 == 0` 條件，所以匹配守衛賦予我們表達這種邏輯的能力。這種額外表達能力的缺點是，當涉及匹配守衛運算式時，編譯器不會嘗試檢查窮盡性。

在[範例 19-11](https://doc.rust-lang.org/book/ch19-03-pattern-syntax.html#listing-19-11) 中，我們提到可以使用匹配守衛來解決模式遮蔽問題。回想一下，我們在 `match` 運算式中的模式內部創建了一個新變數，而不是使用 `match` 外部的變數。那個新變數意味著我們無法針對外部變數的值進行測試。 [範例 19-27](https://doc.rust-lang.org/book/ch19-03-pattern-syntax.html#listing-19-27) 顯示了如何使用匹配守衛來解決這個問題。

src/main.rs

```rust
fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) => println!("Got 50"),
        Some(n) if n == y => println!("Matched, n = {n}"),
        _ => println!("Default case, x = {x:?}"),
    }

    println!("at the end: x = {x:?}, y = {y}");
}
```

範例 19-27：使用匹配守衛測試與外部變數的相等性

這段程式碼現在將印出 `Default case, x = Some(5)`。第二個匹配分支中的模式沒有引入一個會遮蔽外部 `y` 的新變數 `y`，這意味著我們可以在匹配守衛中使用外部 `y`。我們沒有將模式指定為 `Some(y)`（這會遮蔽外部 `y`），而是指定 `Some(n)`。這創建了一個新變數 `n`，它不會遮蔽任何東西，因為 `match` 外部沒有 `n` 變數。

匹配守衛 `if n == y` 不是一個模式，因此不會引入新變數。這個 `y` *是*外部 `y`，而不是一個新的 `y` 遮蔽它，我們可以透過比較 `n` 與 `y` 來尋找與外部 `y` 具有相同值的值。

你也可以在匹配守衛中使用*或*運算子 `|` 來指定多個模式；匹配守衛條件將適用於所有模式。[範例 19-28](https://doc.rust-lang.org/book/ch19-03-pattern-syntax.html#listing-19-28) 顯示了結合使用 `|` 的模式與匹配守衛時的優先級。這個範例的重要部分是 `if y` 匹配守衛適用於 `4`、`5` _和_ `6`，儘管它可能看起來 `if y` 只適用於 `6`。

```rust
    let x = 4;
    let y = false;

    match x {
        4 | 5 | 6 if y => println!("yes"),
        _ => println!("no"),
    }
```

範例 19-28：將多個模式與匹配守衛結合使用

匹配條件表示該分支只有在 `x` 的值等於 `4`、`5` 或 `6` _並且_ `y` 為 `true` 時才匹配。當這段程式碼執行時，第一個分支的模式匹配，因為 `x` 是 `4`，但匹配守衛 `if y` 為 `false`，所以沒有選擇第一個分支。程式碼轉到第二個分支，該分支確實匹配，並且此程式印出 `no`。原因是 `if` 條件適用於整個模式 `4 | 5 | 6`，而不僅僅是最後一個值 `6`。換句話說，匹配守衛相對於模式的優先級行為如下：

```
(4 | 5 | 6) if y => ...
```

而不是這樣：

```
4 | 5 | (6 if y) => ...
```

執行程式碼後，優先級行為顯而易見：如果匹配守衛僅應用於使用 `|` 運算子指定的值列表中的最後一個值，則該分支將匹配，程式將印出 `yes`。

### @ 綁定

_at_ 運算子 `@` 讓我們的同時測試一個值是否匹配模式時，建立一個持有該值的變數。在[範例 19-29](https://doc.rust-lang.org/book/ch19-03-pattern-syntax.html#listing-19-29) 中，我們想測試 `Message::Hello` 的 `id` 欄位是否在 `3..=7` 範圍內。我們還想將該值綁定到變數 `id`，以便在與該分支相關的程式碼中使用它。

```rust
    enum Message {
        Hello { id: i32 },
    }

    let msg = Message::Hello { id: 5 };

    match msg {
        Message::Hello {
            id: id @ 3..=7,
        } => println!("Found an id in range: {id}"),
        Message::Hello { id: 10..=12 } => {
            println!("Found an id in another range")
        }
        Message::Hello { id } => println!("Found some other id: {id}"),
    }
```

範例 19-29：在模式中同時綁定值和測試值時使用 `@`

這個範例將印出 `Found an id in range: 5`。透過在範圍 `3..=7` 之前指定 `id @`，我們將匹配該範圍的值捕獲到一個名為 `id` 的變數中，同時也測試該值是否匹配範圍模式。

在第二個分支中，我們只在模式中指定了一個範圍，與該分支相關的程式碼沒有一個包含 `id` 欄位實際值的變數。`id` 欄位的值可能是 10、11 或 12，但與該模式相關的程式碼不知道它是哪個。模式程式碼無法使用 `id` 欄位中的值，因為我們沒有將 `id` 值儲存到變數中。

在最後一個分支中，我們指定了一個沒有範圍的變數，我們確實可以將該值在分支的程式碼中以名為 `id` 的變數使用。原因是在這裡我們使用了結構欄位簡寫語法。但是我們在這個分支中沒有對 `id` 欄位中的值應用任何測試，就像我們在前兩個分支中所做的那樣：任何值都將匹配此模式。

使用 `@` 讓我們可以在一個模式中同時測試一個值並將其儲存到變數中。

## 總結

Rust 的模式在區分不同種類的資料方面非常有用。當在 `match` 運算式中使用時，Rust 會確保你的模式涵蓋所有可能的值，否則你的程式將無法編譯。`let` 陳述式和函數參數中的模式使這些構造更有用，能夠將值解構成更小的部分並將這些部分賦值給變數。我們可以創建簡單或複雜的模式來滿足我們的需求。

接下來，對於本書的倒數第二章，我們將探討 Rust 各種功能的進階方面。
