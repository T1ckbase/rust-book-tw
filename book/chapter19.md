<!-- DO NOT EDIT THIS FILE.

This file is periodically generated from the content in the `/src/`
directory, so all fixes need to be made in `/src/`.
-->

[TOC]

# 模式與匹配

_Pattern_ 是 Rust 中的一種特殊語法，用於匹配型別的結構，無論是複雜還是簡單的型別。將 pattern 與 `match` 表達式及其他結構結合使用，可以讓你更精確地控制程式的流程。一個 pattern 由以下一些元素的組合構成：

- 字面值
- 解構的陣列、enum、struct 或 tuple
- 變數
- 萬用字元
- 預留位置

一些 pattern 的範例包含 `x`、`(a, 3)` 和 `Some(Color::Red)`。在可以使用 pattern 的情境中，這些元件描述了資料的「形狀」。我們的程式接著會將值與 pattern 進行匹配，以判斷它是否具有正確的資料形狀，從而繼續執行某段特定的程式碼。

要使用 pattern，我們會將它與某個值進行比較。如果 pattern 匹配該值，我們就在程式碼中使用該值的各個部分。回想一下第 6 章中 `match` 表達式使用的 pattern，例如硬幣分類機的範例。如果值的形狀符合 pattern 的形狀，我們就可以使用其中命名的部分。如果不符合，與該 pattern 相關的程式碼就不會執行。

本章是關於所有與 pattern 相關內容的參考資料。我們將涵蓋可以使用 pattern 的所有地方、refutable 與 irrefutable pattern 之間的差異，以及你可能會看到的各種 pattern 語法。讀完本章後，你將學會如何使用 pattern 以清晰的方式表達許多概念。

## 所有可以使用 Pattern 的地方

Pattern 在 Rust 的許多地方都會出現，而且你已經在不知不覺中大量使用它們了！本節將討論所有可以使用 pattern 的地方。

### `match` 分支

如第 6 章所述，我們在 `match` 表達式的分支（arm）中使用 pattern。形式上，`match` 表達式由 `match` 關鍵字、一個要匹配的值，以及一個或多個 `match` 分支所組成。每個分支包含一個 pattern，以及一個當值匹配該分支的 pattern 時要執行的表達式，如下所示：

<!--
  Manually formatted rather than using Markdown intentionally: Markdown does not
  support italicizing code in the body of a block like this!
-->

<pre><code>match <em>VALUE</em> {
    <em>PATTERN</em> => <em>EXPRESSION</em>,
    <em>PATTERN</em> => <em>EXPRESSION</em>,
    <em>PATTERN</em> => <em>EXPRESSION</em>,
}</code></pre>

例如，這是來自列表 6-5 的 `match` 表達式，它匹配變數 `x` 中的一個 `Option<i32>` 值：

```rust
match x {
    None => None,
    Some(i) => Some(i + 1),
}
```

這個 `match` 表達式中的 pattern 是每個箭頭左側的 `None` 和 `Some(i)`。

`match` 表達式有一個要求，就是它們必須是_窮盡的_（exhaustive），也就是說 `match` 表達式中值的所有可能性都必須被考慮到。確保你涵蓋了所有可能性的一種方法是在最後一個分支使用一個全捕捉（catch-all）的 pattern：例如，一個能匹配任何值的變數名稱永遠不會失敗，因此可以涵蓋所有剩餘的情況。

`_` 這個特殊的 pattern 會匹配任何東西，但它永遠不會綁定到變數上，所以它經常用於最後一個 `match` 分支。舉例來說，當你想忽略任何未指定的值時，`_` pattern 就很有用。我們將在本章後面的「在 Pattern 中忽略值」一節中更詳細地介紹 `_` pattern。

### `let` 陳述式

在本章之前，我們只明確討論過在 `match` 和 `if let` 中使用 pattern，但事實上，我們也在其他地方使用過 pattern，包括 `let` 陳述式。例如，考慮這個使用 `let` 的簡單變數賦值：

```rust
let x = 5;
```

每當你像這樣使用 `let` 陳述式時，你其實都在使用 pattern，雖然你可能沒有意識到！更正式地說，一個 `let` 陳述式看起來像這樣：

<!--
  Manually formatted rather than using Markdown intentionally: Markdown does not
  support italicizing code in the body of a block like this!
-->

<pre>
<code>let <em>PATTERN</em> = <em>EXPRESSION</em>;</code>
</pre>

在像 `let x = 5;` 這樣的陳述式中，`PATTERN` 位置上的是一個變數名稱，而變數名稱只是一種特別簡單的 pattern 形式。Rust 會將表達式與 pattern 進行比較，並賦值給它找到的任何名稱。因此，在 `let x = 5;` 的範例中，`x` 是一個 pattern，意思是「將匹配到的東西綁定到變數 `x` 上」。因為名稱 `x` 就是整個 pattern，所以這個 pattern 實際上意味著「無論值是什麼，都將所有東西綁定到變數 `x` 上」。

為了更清楚地看到 `let` 的 pattern 匹配特性，請看列表 19-1，它使用 `let` 搭配 pattern 來解構一個 tuple。

```rust
let (x, y, z) = (1, 2, 3);
```

列表 19-1：使用 pattern 解構一個 tuple 並一次性建立三個變數

在這裡，我們將一個 tuple 與一個 pattern 進行匹配。Rust 會將值 `(1, 2, 3)` 與 pattern `(x, y, z)` 進行比較，並看到這個值匹配該 pattern，因為它發現兩者的元素數量相同，所以 Rust 將 `1` 綁定到 `x`，`2` 綁定到 `y`，`3` 綁定到 `z`。你可以把這個 tuple pattern 想像成在內部巢狀了三個獨立的變數 pattern。

如果 pattern 中的元素數量與 tuple 中的元素數量不匹配，整體的型別就會不匹配，我們將會得到一個編譯器錯誤。例如，列表 19-2 展示了試圖將一個有三個元素的 tuple 解構成兩個變數，這是行不通的。

```rust
let (x, y) = (1, 2, 3);
```

列表 19-2：錯誤地建構一個 pattern，其變數數量與 tuple 中的元素數量不匹配

試圖編譯這段程式碼會導致以下型別錯誤：

```
$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error[E0308]: mismatched types
 --> src/main.rs:2:9
  |
2 |     let (x, y) = (1, 2, 3);
  |         ^^^^^^   --------- this expression has type `({integer}, {integer}, {integer})`
  |         |
  |         expected a tuple with 3 elements, found one with 2 elements
  |
  = note: expected tuple `({integer}, {integer}, {integer})`
             found tuple `(_, _)`

For more information about this error, try `rustc --explain E0308`.
error: could not compile `patterns` (bin "patterns") due to 1 previous error
```

要修正這個錯誤，我們可以使用 `_` 或 `..` 來忽略 tuple 中的一個或多個值，這點你將在「在 Pattern 中忽略值」一節中看到。如果問題是 pattern 中的變數太多，解決方法是移除變數，讓型別匹配，使得變數數量等於 tuple 中的元素數量。

### `if let` 條件表達式

在第 6 章中，我們討論過使用 `if let` 表達式，主要是作為一種更簡潔的方式來撰寫等同於只匹配一種情況的 `match`。`if let` 可以選擇性地搭配一個 `else`，其中包含當 `if let` 中的 pattern 不匹配時要執行的程式碼。

列表 19-3 展示了也可以混合使用 `if let`、`else if` 和 `else if let` 表達式。這樣做比 `match` 表達式給了我們更多的彈性，在 `match` 中我們只能表達一個值來與 pattern 比較。此外，Rust 不要求一系列 `if let`、`else if` 和 `else if let` 分支中的條件必須相互關聯。

列表 19-3 中的程式碼根據一系列對幾個條件的檢查來決定背景顏色。在這個範例中，我們建立了一些帶有硬編碼值的變數，而在真實的程式中，這些值可能會來自使用者的輸入。

src/main.rs

```rust
fn main() {
    let favorite_color: Option<&str> = None;
    let is_tuesday = false;
    let age: Result<u8, _> = "34".parse();

    if let Some(color) = favorite_color {
        println!("Using your favorite color, {color}, as the background");
    } else if is_tuesday {
        println!("Tuesday is green day!");
    } else if let Ok(age) = age {
        if age > 30 {
            println!("Using purple as the background color");
        } else {
            println!("Using orange as the background color");
        }
    } else {
        println!("Using blue as the background color");
    }
}
```

列表 19-3：混合使用 `if let`、`else if`、`else if let` 和 `else`

如果使用者指定了最喜歡的顏色，就用那個顏色作為背景。如果沒有指定最喜歡的顏色且今天是星期二，背景顏色就是綠色。否則，如果使用者以字串形式指定他們的年齡，且我們能成功地將其解析為數字，則顏色會根據數字的值是紫色或橘色。如果以上條件都不適用，背景顏色就是藍色。

這種條件結構讓我們能夠支援複雜的需求。使用我們這裡的硬編碼值，這個範例將會印出 `Using purple as the background color`。

你可以看到 `if let` 也可以引入新的變數，這些變數會遮蔽（shadow）現有的同名變數，就像 `match` 分支一樣：`if let Ok(age) = age` 這一行引入了一個新的 `age` 變數，它包含了 `Ok` 變體裡的值，遮蔽了現有的 `age` 變數。這意味著我們需要將 `if age > 30` 這個條件放在那個區塊內：我們不能將這兩個條件合併成 `if let Ok(age) = age && age > 30`。我們想要與 30 比較的新 `age` 變數，直到大括號開始的新作用域內才有效。

使用 `if let` 表達式的缺點是，編譯器不會檢查窮盡性，而 `match` 表達式會。如果我們省略了最後的 `else` 區塊，因而漏掉了一些情況的處理，編譯器不會提醒我們可能存在的邏輯錯誤。

### `while let` 條件迴圈

`while let` 條件迴圈的結構與 `if let` 類似，它允許一個 `while` 迴圈在一個 pattern 持續匹配的情況下一直執行。在列表 19-4 中，我們展示了一個 `while let` 迴圈，它等待執行緒之間傳送的訊息，但在這種情況下，檢查的是 `Result` 而不是 `Option`。

```rust
    let (tx, rx) = std::sync::mpsc::channel();
    std::thread::spawn(move || {
        for val in [1, 2, 3] {
            tx.send(val).unwrap();
        }
    });

    while let Ok(value) = rx.recv() {
        println!("{value}");
    }
```

列表 19-4：只要 `rx.recv()` 回傳 `Ok`，就使用 `while let` 迴圈來印出值

這個範例會印出 `1`、`2`，然後是 `3`。`recv` 方法會從 channel 的接收端取出第一則訊息，並回傳一個 `Ok(value)`。當我們在第 16 章第一次看到 `recv` 時，我們直接 `unwrap` 了錯誤，或是使用 `for` 迴圈將它當作迭代器來互動。不過，如列表 19-4 所示，我們也可以使用 `while let`，因為只要傳送端存在，`recv` 方法每次有訊息到達時都會回傳 `Ok`，而一旦傳送端斷線，就會產生 `Err`。

### `for` 迴圈

在 `for` 迴圈中，緊跟在 `for` 關鍵字後面的值就是一個 pattern。例如，在 `for x in y` 中，`x` 就是 pattern。列表 19-5 展示了如何在 `for` 迴圈中使用 pattern 來_解構_（destructure）或拆解一個 tuple，作為 `for` 迴圈的一部分。

```rust
    let v = vec!['a', 'b', 'c'];

    for (index, value) in v.iter().enumerate() {
        println!("{value} is at index {index}");
    }
```

列表 19-5：在 `for` 迴圈中使用 pattern 來解構一個 tuple

列表 19-5 中的程式碼將會印出以下內容：

```
$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.52s
     Running `target/debug/patterns`
a is at index 0
b is at index 1
c is at index 2
```

我們使用 `enumerate` 方法來調整一個迭代器，使其產生一個值以及該值的索引，並將它們放入一個 tuple 中。第一個產生的值是 tuple `(0, 'a')`。當這個值與 pattern `(index, value)` 匹配時，`index` 會是 `0`，`value` 會是 `'a'`，於是印出輸出的第一行。

### 函式參數

函式參數也可以是 pattern。列表 19-6 中的程式碼宣告了一個名為 `foo` 的函式，它接受一個名為 `x`、型別為 `i32` 的參數，這對你來說現在應該很熟悉了。

```rust
fn foo(x: i32) {
    // code goes here
}
```

列表 19-6：函式簽名在參數中使用 pattern

`x` 的部分就是一個 pattern！就像我們對 `let` 所做的一樣，我們可以在函式的引數中將一個 tuple 與 pattern 進行匹配。列表 19-7 在我們將一個 tuple 傳遞給函式時，將其值進行拆分。

src/main.rs

```rust
fn print_coordinates(&(x, y): &(i32, i32)) {
    println!("Current location: ({x}, {y})");
}

fn main() {
    let point = (3, 5);
    print_coordinates(&point);
}
```

列表 19-7：一個帶有解構 tuple 參數的函式

這段程式碼會印出 `Current location: (3, 5)`。值 `&(3, 5)` 匹配 pattern `&(x, y)`，所以 `x` 是 `3`，`y` 是 `5`。

我們也可以在閉包的參數列表中使用 pattern，方式與在函式參數列表中一樣，因為閉包和函式很類似，這在第 13 章已經討論過。

到目前為止，你已經看過幾種使用 pattern 的方式，但 pattern 在我們能使用它們的每個地方並不是都以相同的方式運作。在某些地方，pattern 必須是 irrefutable；在其他情況下，它們可以是 refutable。我們接下來將討論這兩個概念。

## Refutability：一個 Pattern 是否可能匹配失敗

Pattern 有兩種形式：refutable 和 irrefutable。對於任何傳入的可能值都會匹配的 pattern，稱為 _irrefutable_。一個例子是陳述式 `let x = 5;` 中的 `x`，因為 `x` 可以匹配任何東西，所以不可能匹配失敗。對於某些可能的值會匹配失敗的 pattern，稱為 _refutable_。一個例子是表達式 `if let Some(x) = a_value` 中的 `Some(x)`，因為如果 `a_value` 變數中的值是 `None` 而不是 `Some`，`Some(x)` pattern 將不會匹配。

函式參數、`let` 陳述式和 `for` 迴圈只能接受 irrefutable pattern，因為當值不匹配時，程式無法做任何有意義的事情。`if let` 和 `while let` 表達式以及 `let...else` 陳述式可以接受 refutable 和 irrefutable pattern，但編譯器會對 irrefutable pattern 發出警告，因為根據定義，它們是用來處理可能的失敗：條件式的功能在於它能夠根據成功或失敗來執行不同的操作。

一般來說，你不需要擔心 refutable 和 irrefutable pattern 之間的區別；但是，你需要熟悉 refutability 的概念，這樣當你在錯誤訊息中看到它時，才能做出反應。在那些情況下，你需要根據程式碼的預期行為，改變 pattern 或使用 pattern 的結構。

讓我們看一個例子，當我們試圖在 Rust 要求 irrefutable pattern 的地方使用 refutable pattern，以及反過來的情況會發生什麼。列表 19-8 展示了一個 `let` 陳述式，但我們為 pattern 指定了 `Some(x)`，這是一個 refutable pattern。如你所料，這段程式碼無法編譯。

```rust
let Some(x) = some_option_value;
```

列表 19-8：試圖在 `let` 中使用一個 refutable pattern

如果 `some_option_value` 的值是 `None`，它將無法匹配 pattern `Some(x)`，這意味著這個 pattern 是 refutable 的。然而，`let` 陳述式只能接受 irrefutable pattern，因為程式碼無法對 `None` 值做任何有效的處理。在編譯時期，Rust 會抱怨我們在需要 irrefutable pattern 的地方使用了 refutable pattern：

```
$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error[E0005]: refutable pattern in local binding
 --> src/main.rs:3:9
  |
3 |     let Some(x) = some_option_value;
  |         ^^^^^^^ pattern `None` not covered
  |
  = note: `let` bindings require an "irrefutable pattern", like a `struct` or an `enum` with only one variant
  = note: for more information, visit https://doc.rust-lang.org/book/ch19-02-refutability.html
  = note: the matched value is of type `Option<i32>`
help: you might want to use `let else` to handle the variant that isn't matched
  |
3 |     let Some(x) = some_option_value else { todo!() };
  |                                     ++++++++++++++++

For more information about this error, try `rustc --explain E0005`.
error: could not compile `patterns` (bin "patterns") due to 1 previous error
```

因為我們沒有（也無法）用 `Some(x)` 這個 pattern 涵蓋所有可能的值，Rust 理所當然地產生了一個編譯器錯誤。

如果我們在需要 irrefutable pattern 的地方有 refutable pattern，我們可以透過改變使用該 pattern 的程式碼來修正它：我們可以使用 `let else` 來取代 `let`。這樣一來，如果 pattern 不匹配，程式碼就會跳過大括號中的程式碼，讓它有辦法繼續有效地執行。列表 19-9 展示了如何修正列表 19-8 中的程式碼。

```rust
let Some(x) = some_option_value else {
    return;
};
```

列表 19-9：使用 `let...else` 和一個區塊來處理 refutable pattern，而不是 `let`

我們給了程式碼一個出口！這段程式碼是完全有效的，不過這也意味著我們不能使用 irrefutable pattern 而不收到警告。如果我們給 `let...else` 一個總是會匹配的 pattern，例如 `x`，如列表 19-10 所示，編譯器將會發出警告。

```rust
let x = 5 else {
    return;
};
```

列表 19-10：試圖在 `let...else` 中使用一個 irrefutable pattern

Rust 會抱怨在 `let...else` 中使用 irrefutable pattern 是沒有意義的：

```
$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
warning: irrefutable `let...else` pattern
 --> src/main.rs:2:5
  |
2 |     let x = 5 else {
  |     ^^^^^^^^^
  |
  = note: this pattern will always match, so the `else` clause is useless
  = help: consider removing the `else` clause
  = note: `#[warn(irrefutable_let_patterns)]` on by default

warning: `patterns` (bin "patterns") generated 1 warning
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.39s
     Running `target/debug/patterns`
```

因此，`match` 分支必須使用 refutable pattern，除了最後一個分支，它應該用一個 irrefutable pattern 來匹配任何剩餘的值。Rust 允許我們在只有一個分支的 `match` 中使用 irrefutable pattern，但這種語法並不是特別有用，可以用更簡單的 `let` 陳述式來取代。

現在你已經知道在哪裡使用 pattern，以及 refutable 和 irrefutable pattern 之間的區別，讓我們來看看所有可以用來建立 pattern 的語法。

## Pattern 語法

在本節中，我們將匯總所有在 pattern 中有效的語法，並討論為什麼以及何時你可能會想使用它們。

### 匹配字面值

如你在第 6 章所見，你可以直接將 pattern 與字面值進行匹配。以下程式碼提供了一些範例：

```rust
    let x = 1;

    match x {
        1 => println!("one"),
        2 => println!("two"),
        3 => println!("three"),
        _ => println!("anything"),
    }
```

這段程式碼會印出 `one`，因為 `x` 的值是 `1`。當你希望程式碼在得到某個特定的具體值時採取行動，這種語法就很有用。

### 匹配命名變數

命名變數是 irrefutable pattern，可以匹配任何值，我們在這本書中已經用過很多次了。然而，當你在 `match`、`if let` 或 `while let` 表達式中使用命名變數時，會有一點複雜。因為這些表達式都會開始一個新的作用域，所以在這些表達式內部作為 pattern 一部分宣告的變數，會遮蔽（shadow）外部同名的變數，這與所有變數的情況一樣。在列表 19-11 中，我們宣告了一個名為 `x` 的變數，其值為 `Some(5)`，以及一個名為 `y` 的變數，其值為 `10`。然後我們對 `x` 的值建立一個 `match` 表達式。請看看 `match` 分支中的 pattern 和結尾的 `println!`，並在執行這段程式碼或繼續閱讀之前，試著猜猜程式碼會印出什麼。

src/main.rs

```rust
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) => println!("Got 50"),
        Some(y) => println!("Matched, y = {y}"),
        _ => println!("Default case, x = {x:?}"),
    }

    println!("at the end: x = {x:?}, y = {y}");
```

列表 19-11：一個 `match` 表達式，其分支引入了一個新的變數，遮蔽了現有的變數 `y`

讓我們來逐步分析 `match` 表達式執行時會發生什麼事。第一個 `match` 分支的 pattern 不匹配 `x` 的定義值，所以程式碼繼續執行。

第二個 `match` 分支的 pattern 引入了一個名為 `y` 的新變數，它會匹配 `Some` 值內的任何值。因為我們在 `match` 表達式中有一個新的作用域，所以這是一個新的 `y` 變數，而不是我們一開始宣告的那個值為 `10` 的 `y`。這個新的 `y` 綁定會匹配 `Some` 內的任何值，而這正是 `x` 的情況。因此，這個新的 `y` 綁定到 `x` 中 `Some` 的內部值。那個值是 `5`，所以該分支的表達式會執行並印出 `Matched, y = 5`。

如果 `x` 的值是 `None` 而不是 `Some(5)`，前兩個分支的 pattern 都不會匹配，所以值會匹配到底線。我們沒有在底線分支的 pattern 中引入 `x` 變數，所以表達式中的 `x` 仍然是外部那個未被遮蔽的 `x`。在這種假設情況下，`match` 會印出 `Default case, x = None`。

當 `match` 表達式結束時，它的作用域也結束了，內部 `y` 的作用域也隨之結束。最後的 `println!` 會產生 `at the end: x = Some(5), y = 10`。

如果要建立一個比較外部 `x` 和 `y` 值的 `match` 表達式，而不是引入一個遮蔽現有 `y` 變數的新變數，我們需要使用 match guard 條件式。我們稍後將在「使用 Match Guard 的額外條件式」中討論 match guard。

### 多重 Pattern

在 `match` 表達式中，你可以使用 `|` 語法來匹配多個 pattern，這是 pattern 的_或_（or）運算子。例如，在以下程式碼中，我們將 `x` 的值與 `match` 分支進行匹配，其中第一個分支有一個*或*的選項，意味著如果 `x` 的值匹配該分支中的任何一個值，該分支的程式碼就會執行：

```rust
    let x = 1;

    match x {
        1 | 2 => println!("one or two"),
        3 => println!("three"),
        _ => println!("anything"),
    }
```

這段程式碼會印出 `one or two`。

### 使用 `..=` 匹配值的範圍

`..=` 語法讓我們可以匹配一個包含性（inclusive）的值範圍。在以下程式碼中，當一個 pattern 匹配到給定範圍內的任何值時，該分支就會執行：

```rust
    let x = 5;

    match x {
        1..=5 => println!("one through five"),
        _ => println!("something else"),
    }
```

如果 `x` 是 `1`、`2`、`3`、`4` 或 `5`，第一個分支就會匹配。對於多個匹配值，這種語法比使用 `|` 運算子來表達相同的概念更方便；如果我們使用 `|`，我們就必須寫 `1 | 2 | 3 | 4 | 5`。指定一個範圍要簡潔得多，特別是當我們想要匹配，比如說，1 到 1,000 之間的任何數字時！

編譯器在編譯時期會檢查範圍是否為空，而且因為 Rust 只能判斷 `char` 和數值型別的範圍是否為空，所以範圍只允許用在數值或 `char` 值上。

這是一個使用 `char` 值範圍的範例：

```rust
    let x = 'c';

    match x {
        'a'..='j' => println!("early ASCII letter"),
        'k'..='z' => println!("late ASCII letter"),
        _ => println!("something else"),
    }
```

Rust 可以判斷 `'c'` 在第一個 pattern 的範圍內，並印出 `early ASCII letter`。

### 使用解構來分解值

我們也可以使用 pattern 來解構 struct、enum 和 tuple，以使用這些值的不同部分。讓我們逐一來看。

#### 解構 Struct

列表 19-12 展示了一個有兩個欄位 `x` 和 `y` 的 `Point` struct，我們可以用一個 `let` 陳述式搭配 pattern 來將它分解。

src/main.rs

```rust
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x: a, y: b } = p;
    assert_eq!(0, a);
    assert_eq!(7, b);
}
```

列表 19-12：將一個 struct 的欄位解構成獨立的變數

這段程式碼建立了變數 `a` 和 `b`，它們會匹配 `p` struct 的 `x` 和 `y` 欄位的值。這個範例顯示 pattern 中的變數名稱不必與 struct 的欄位名稱相同。然而，通常會將變數名稱與欄位名稱匹配，以便更容易記住哪個變數來自哪個欄位。由於這種常見用法，以及因為撰寫 `let Point { x: x, y: y } = p;` 包含很多重複，Rust 提供了一種匹配 struct 欄位的 pattern 簡寫法：你只需要列出 struct 欄位的名稱，從 pattern 建立的變數就會有相同的名稱。列表 19-13 的行為與列表 19-12 中的程式碼相同，但在 `let` pattern 中建立的變數是 `x` 和 `y`，而不是 `a` 和 `b`。

src/main.rs

```rust
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x, y } = p;
    assert_eq!(0, x);
    assert_eq!(7, y);
}
```

列表 19-13：使用 struct 欄位簡寫法解構 struct 欄位

這段程式碼建立了變數 `x` 和 `y`，它們匹配 `p` 變數的 `x` 和 `y` 欄位。結果是變數 `x` 和 `y` 包含了來自 `p` struct 的值。

我們也可以在 struct pattern 中使用字面值進行解構，而不是為所有欄位建立變數。這樣做可以讓我們測試某些欄位是否為特定值，同時建立變數來解構其他欄位。

在列表 19-14 中，我們有一個 `match` 表達式，它將 `Point` 值分成三種情況：直接位於 `x` 軸上的點（當 `y = 0` 時為真）、位於 `y` 軸上的點（`x = 0`），或兩者皆非。

src/main.rs

```rust
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    match p {
        Point { x, y: 0 } => println!("On the x axis at {x}"),
        Point { x: 0, y } => println!("On the y axis at {y}"),
        Point { x, y } => {
            println!("On neither axis: ({x}, {y})");
        }
    }
}
```

列表 19-14：在一個 pattern 中同時進行解構和匹配字面值

第一個分支會匹配任何位於 `x` 軸上的點，方法是指定 `y` 欄位匹配的值為字面值 `0`。這個 pattern 仍然會建立一個 `x` 變數，我們可以在這個分支的程式碼中使用它。

同樣地，第二個分支會匹配任何位於 `y` 軸上的點，方法是指定 `x` 欄位匹配的值為 `0`，並為 `y` 欄位的值建立一個變數 `y`。第三個分支沒有指定任何字面值，所以它會匹配任何其他的 `Point`，並為 `x` 和 `y` 欄位建立變數。

在這個範例中，值 `p` 因為 `x` 包含 `0` 而匹配了第二個分支，所以這段程式碼會印出 `On the y axis at 7`。

請記住，`match` 表達式一旦找到第一個匹配的 pattern 就會停止檢查分支，所以即使 `Point { x: 0, y: 0}` 同時在 `x` 軸和 `y` 軸上，這段程式碼也只會印出 `On the x axis at 0`。

#### 解構 Enum

我們在這本書中已經解構過 enum（例如，第 6 章的列表 6-5），但還沒有明確討論過，解構 enum 的 pattern 是對應於 enum 中儲存資料的定義方式。舉例來說，在列表 19-15 中，我們使用了列表 6-2 中的 `Message` enum，並撰寫了一個 `match`，其 pattern 會解構每個內部值。

src/main.rs

```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msg = Message::ChangeColor(0, 160, 255);

    match msg {
        Message::Quit => {
            println!("The Quit variant has no data to destructure.");
        }
        Message::Move { x, y } => {
            println!("Move in the x direction {x} and in the y direction {y}");
        }
        Message::Write(text) => {
            println!("Text message: {text}");
        }
        Message::ChangeColor(r, g, b) => {
            println!("Change color to red {r}, green {g}, and blue {b}");
        }
    }
}
```

列表 19-15：解構持有不同類型值的 enum 變體

這段程式碼將會印出 `Change color to red 0, green 160, and blue 255`。試著改變 `msg` 的值，看看其他分支的程式碼執行情況。

對於沒有任何資料的 enum 變體，像是 `Message::Quit`，我們無法進一步解構其值。我們只能匹配字面值 `Message::Quit`，且該 pattern 中沒有任何變數。

對於類似 struct 的 enum 變體，例如 `Message::Move`，我們可以使用類似於我們用來匹配 struct 的 pattern。在變體名稱之後，我們放置大括號，然後列出欄位與變數，以便我們將各個部分拆解開來，在這個分支的程式碼中使用。這裡我們使用了像列表 19-13 中的簡寫形式。

對於類似 tuple 的 enum 變體，像是 `Message::Write`（持有一個元素的 tuple）和 `Message::ChangeColor`（持有三個元素的 tuple），其 pattern 類似於我們用來匹配 tuple 的 pattern。pattern 中的變數數量必須與我們所匹配的變體中的元素數量相符。

#### 解構巢狀的 Struct 與 Enum

到目前為止，我們的範例都是在單一層級上匹配 struct 或 enum，但匹配也可以應用於巢狀的項目！例如，我們可以重構列表 19-15 的程式碼，以在 `ChangeColor` 訊息中支援 RGB 和 HSV 顏色，如列表 19-16 所示。

```rust
enum Color {
    Rgb(i32, i32, i32),
    Hsv(i32, i32, i32),
}

enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(Color),
}

fn main() {
    let msg = Message::ChangeColor(Color::Hsv(0, 160, 255));

    match msg {
        Message::ChangeColor(Color::Rgb(r, g, b)) => {
            println!("Change color to red {r}, green {g}, and blue {b}");
        }
        Message::ChangeColor(Color::Hsv(h, s, v)) => {
            println!("Change color to hue {h}, saturation {s}, value {v}");
        }
        _ => (),
    }
}
```

列表 19-16：對巢狀 enum 進行匹配

`match` 表達式中第一個分支的 pattern 匹配一個 `Message::ChangeColor` enum 變體，該變體包含一個 `Color::Rgb` 變體；然後 pattern 綁定到三個內部的 `i32` 值。第二個分支的 pattern 也匹配一個 `Message::ChangeColor` enum 變體，但內部 enum 匹配的是 `Color::Hsv`。我們可以在一個 `match` 表達式中指定這些複雜的條件，即使涉及了兩個 enum。

#### 解構 Struct 與 Tuple

我們可以以更複雜的方式混合、匹配和巢狀解構 pattern。以下範例展示了一個複雜的解構，我們在一個 tuple 中巢狀了 struct 和 tuple，並將所有原始值都解構出來：

```rust
let ((feet, inches), Point { x, y }) = ((3, 10), Point { x: 3, y: -10 });
```

這段程式碼讓我們可以將複雜的型別分解成它們的組成部分，這樣我們就可以分別使用我們感興趣的值。

使用 pattern 進行解構是一種方便的方式，可以將值的各個部分，例如 struct 中每個欄位的值，分開來獨立使用。

### 在 Pattern 中忽略值

你已經看到，有時候在 pattern 中忽略值是很有用的，例如在 `match` 的最後一個分支，用來作為一個全捕捉（catch-all）的分支，它實際上不做任何事，但卻考慮了所有剩餘的可能性。在 pattern 中忽略整個值或部分值有幾種方法：使用 `_` pattern（你已經見過）、在另一個 pattern 中使用 `_` pattern、使用底線開頭的名稱，或使用 `..` 來忽略值的其餘部分。讓我們來探討如何以及為何使用這些 pattern。

<!-- Old link, do not remove -->

<a id="ignoring-an-entire-value-with-_"></a>

#### 用 `_` 忽略整個值

我們已經用過底線作為一個萬用字元 pattern，它會匹配任何值但不會綁定到該值。這在 `match` 表達式的最後一個分支特別有用，但我們也可以在任何 pattern 中使用它，包括函式參數，如列表 19-17 所示。

src/main.rs

```rust
fn foo(_: i32, y: i32) {
    println!("This code only uses the y parameter: {y}");
}

fn main() {
    foo(3, 4);
}
```

列表 19-17：在函式簽名中使用 `_`

這段程式碼會完全忽略傳入的第一個引數 `3`，並會印出 `This code only uses the y parameter: 4`。

在大多數情況下，當你不再需要某個特定的函式參數時，你會修改函式簽名，使其不包含那個未使用的參數。忽略函式參數在某些情況下特別有用，例如，當你在實作一個 trait 時，你需要某個特定的型別簽名，但你的實作中的函式主體並不需要其中一個參數。這樣你就可以避免收到關於未使用函式參數的編譯器警告，如果你使用一個名稱的話就會收到。

<a id="ignoring-parts-of-a-value-with-a-nested-_"></a>

#### 用巢狀的 `_` 忽略部分值

我們也可以在另一個 pattern 中使用 `_` 來只忽略值的一部分，例如，當我們只想測試值的一部分，但在對應要執行的程式碼中對其他部分沒有用處時。列表 19-18 展示了一段負責管理設定值的程式碼。業務需求是，使用者不應該被允許覆蓋一個已存在的自訂設定，但如果設定目前未設定，可以取消設定並給它一個值。

```rust
    let mut setting_value = Some(5);
    let new_setting_value = Some(10);

    match (setting_value, new_setting_value) {
        (Some(_), Some(_)) => {
            println!("Can't overwrite an existing customized value");
        }
        _ => {
            setting_value = new_setting_value;
        }
    }

    println!("setting is {setting_value:?}");
```

列表 19-18：當我們不需要使用 `Some` 內的值時，在匹配 `Some` 變體的 pattern 中使用底線

這段程式碼會印出 `Can't overwrite an existing customized value`，然後是 `setting is Some(5)`。在第一個 `match` 分支中，我們不需要匹配或使用任一個 `Some` 變體內部的值，但我們確實需要測試 `setting_value` 和 `new_setting_value` 都是 `Some` 變體的情況。在這種情況下，我們印出不更改 `setting_value` 的原因，而它也確實沒有被更改。

在所有其他情況下（如果 `setting_value` 或 `new_setting_value` 是 `None`），由第二個分支中的 `_` pattern 表示，我們希望允許 `new_setting_value` 成為 `setting_value`。

我們也可以在一個 pattern 中的多個地方使用底線來忽略特定的值。列表 19-19 展示了一個忽略一個五元素 tuple 中第二和第四個值的範例。

```rust
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, _, third, _, fifth) => {
            println!("Some numbers: {first}, {third}, {fifth}");
        }
    }
```

列表 19-19：忽略一個 tuple 的多個部分

這段程式碼會印出 `Some numbers: 2, 8, 32`，而值 `4` 和 `16` 將被忽略。

<!-- Old link, do not remove -->

<a id="ignoring-an-unused-variable-by-starting-its-name-with-_"></a>

#### 用底線開頭的名稱忽略未使用的變數

如果你建立了一個變數但沒有在任何地方使用它，Rust 通常會發出一個警告，因為未使用的變數可能是一個 bug。然而，有時候能夠建立一個你暫時不會使用的變數是很有用的，例如當你在原型設計或剛開始一個專案時。在這種情況下，你可以透過用底線作為變數名稱的開頭，來告訴 Rust 不要對未使用的變數發出警告。在列表 19-20 中，我們建立了兩個未使用的變數，但當我們編譯這段程式碼時，我們應該只會收到關於其中一個的警告。

src/main.rs

```rust
fn main() {
    let _x = 5;
    let y = 10;
}
```

列表 19-20：用底線作為變數名稱的開頭，以避免收到未使用變數的警告

在這裡，我們收到了關於未使用變數 `y` 的警告，但沒有收到關於未使用 `_x` 的警告。

請注意，只使用 `_` 和使用以底線開頭的名稱之間有一個細微的差別。語法 `_x` 仍然會將值綁定到變數上，而 `_` 則完全不綁定。為了展示這個區別很重要的情況，列表 19-21 將會給我們一個錯誤。

```rust
    let s = Some(String::from("Hello!"));

    if let Some(_s) = s {
        println!("found a string");
    }

    println!("{s:?}");
```

列表 19-21：一個以底線開頭的未使用變數仍然會綁定值，這可能會取得該值的所有權

我們會收到一個錯誤，因為 `s` 的值仍然會被移動到 `_s` 中，這使得我們無法再次使用 `s`。然而，單獨使用底線永遠不會綁定到值。列表 19-22 將會編譯成功且沒有任何錯誤，因為 `s` 沒有被移動到 `_` 中。

```rust
    let s = Some(String::from("Hello!"));

    if let Some(_) = s {
        println!("found a string");
    }

    println!("{s:?}");
```

列表 19-22：使用底線不會綁定值

這段程式碼運作得很好，因為我們從未將 `s` 綁定到任何東西上；它沒有被移動。

<a id="ignoring-remaining-parts-of-a-value-with-"></a>

#### 用 `..` 忽略值的其餘部分

對於擁有很多部分的值，我們可以使用 `..` 語法來使用特定的部分並忽略其餘部分，這樣就不需要為每個被忽略的值都列出底線。`..` pattern 會忽略我們在 pattern 其餘部分中沒有明確匹配的值的任何部分。在列表 19-23 中，我們有一個 `Point` struct，它儲存了一個三維空間中的座標。在 `match` 表達式中，我們只想對 `x` 座標進行操作，並忽略 `y` 和 `z` 欄位中的值。

```rust
    struct Point {
        x: i32,
        y: i32,
        z: i32,
    }

    let origin = Point { x: 0, y: 0, z: 0 };

    match origin {
        Point { x, .. } => println!("x is {x}"),
    }
```

列表 19-23：使用 `..` 忽略 `Point` 的所有欄位，除了 `x`

我們列出了 `x` 值，然後只包含了 `..` pattern。這比必須列出 `y: _` 和 `z: _` 更快，特別是當我們處理有很多欄位的 struct，而只有一兩個欄位是相關的時。

`..` 語法會擴展到它所需要的值的數量。列表 19-24 展示了如何對一個 tuple 使用 `..`。

src/main.rs

```rust
fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, .., last) => {
            println!("Some numbers: {first}, {last}");
        }
    }
}
```

列表 19-24：只匹配 tuple 中的第一個和最後一個值，並忽略所有其他值

在這段程式碼中，第一個和最後一個值分別與 `first` 和 `last` 匹配。`..` 將會匹配並忽略中間的所有東西。

然而，使用 `..` 必須是無歧義的。如果不清楚哪些值是用於匹配，哪些應該被忽略，Rust 會給我們一個錯誤。列表 19-25 展示了一個模稜兩可地使用 `..` 的範例，所以它無法編譯。

src/main.rs

```rust
fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (.., second, ..) => {
            println!("Some numbers: {second}")
        },
    }
}
```

列表 19-25：一個試圖以模稜兩可的方式使用 `..` 的例子

當我們編譯這個範例時，我們會得到這個錯誤：

```
$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error: `..` can only be used once per tuple pattern
 --> src/main.rs:5:22
  |
5 |         (.., second, ..) => {
  |          --          ^^ can only be used once per tuple pattern
  |          |
  |          previously used here

error: could not compile `patterns` (bin "patterns") due to 1 previous error
```

Rust 無法確定在與 `second` 匹配一個值之前，要在 tuple 中忽略多少個值，然後再忽略多少個值。這段程式碼可能意味著我們想要忽略 `2`，將 `second` 綁定到 `4`，然後忽略 `8`、`16` 和 `32`；或者我們想要忽略 `2` 和 `4`，將 `second` 綁定到 `8`，然後忽略 `16` 和 `32`；以此類推。變數名稱 `second` 對 Rust 來說沒有任何特殊意義，所以我們會得到一個編譯器錯誤，因為像這樣在兩個地方使用 `..` 是有歧義的。

### 使用 Match Guard 的額外條件式

_match guard_ 是一個額外的 `if` 條件，指定在 `match` 分支的 pattern 之後，該條件也必須為真，才能選擇該分支。Match guard 對於表達比單獨一個 pattern 更複雜的想法很有用。不過請注意，它們只在 `match` 表達式中可用，在 `if let` 或 `while let` 表達式中則不可用。

條件可以使用在 pattern 中建立的變數。列表 19-26 展示了一個 `match`，其中第一個分支的 pattern 是 `Some(x)`，並且還有一個 `if x % 2 == 0` 的 match guard（如果數字是偶數，這將會是 `true`）。

```rust
    let num = Some(4);

    match num {
        Some(x) if x % 2 == 0 => println!("The number {x} is even"),
        Some(x) => println!("The number {x} is odd"),
        None => (),
    }
```

列表 19-26：在一個 pattern 上加上一個 match guard

這個範例將會印出 `The number 4 is even`。當 `num` 與第一個分支的 pattern 比較時，它匹配了，因為 `Some(4)` 匹配 `Some(x)`。然後 match guard 會檢查 `x` 除以 2 的餘數是否等於 0，因為是的，所以選擇了第一個分支。

如果 `num` 是 `Some(5)`，第一個分支的 match guard 將會是 `false`，因為 5 除以 2 的餘數是 1，不等於 0。Rust 接著會檢查第二個分支，該分支會匹配，因為第二個分支沒有 match guard，因此會匹配任何 `Some` 變體。

沒有辦法在一個 pattern 內表達 `if x % 2 == 0` 這個條件，所以 match guard 賦予我們表達這種邏輯的能力。這種額外表達能力的缺點是，當涉及到 match guard 表達式時，編譯器不會嘗試檢查窮盡性。

在列表 19-11 中，我們提到過可以使用 match guard 來解決我們的 pattern 遮蔽問題。回想一下，我們在 `match` 表達式的 pattern 中建立了一個新變數，而不是使用 `match` 外的變數。那個新變數意味著我們無法對外部變數的值進行測試。列表 19-27 展示了我們如何使用 match guard 來解決這個問題。

src/main.rs

```rust
fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) => println!("Got 50"),
        Some(n) if n == y => println!("Matched, n = {n}"),
        _ => println!("Default case, x = {x:?}"),
    }

    println!("at the end: x = {x:?}, y = {y}");
}
```

列表 19-27：使用 match guard 來測試是否與外部變數相等

這段程式碼現在將會印出 `Default case, x = Some(5)`。第二個 `match` 分支的 pattern 不會引入一個會遮蔽外部 `y` 的新變數 `y`，這意味著我們可以在 match guard 中使用外部的 `y`。我們將 pattern 指定為 `Some(n)`，而不是 `Some(y)`（這會遮蔽外部的 `y`）。這會建立一個新變數 `n`，它不會遮蔽任何東西，因為 `match` 外面沒有 `n` 變數。

match guard `if n == y` 不是一個 pattern，因此不會引入新的變數。這個 `y` *是*外部的 `y`，而不是一個遮蔽它的新 `y`，我們可以透過比較 `n` 和 `y` 來尋找一個與外部 `y` 具有相同值的值。

你也可以在 match guard 中使用*或*運算子 `|` 來指定多個 pattern；match guard 條件將適用於所有的 pattern。列表 19-28 展示了將使用 `|` 的 pattern 與 match guard 結合時的優先級。這個範例的重點是，`if y` match guard 適用於 `4`、`5` _和_ `6`，儘管看起來 `if y` 可能只適用於 `6`。

```rust
    let x = 4;
    let y = false;

    match x {
        4 | 5 | 6 if y => println!("yes"),
        _ => println!("no"),
    }
```

列表 19-28：將多個 pattern 與一個 match guard 結合

`match` 條件陳述，該分支只在 `x` 的值等於 `4`、`5` 或 `6` _且_ `y` 是 `true` 的情況下才會匹配。當這段程式碼執行時，第一個分支的 pattern 匹配了，因為 `x` 是 `4`，但 match guard `if y` 是 `false`，所以沒有選擇第一個分支。程式碼繼續執行到第二個分支，該分支匹配，於是這個程式印出 `no`。原因是 `if` 條件適用於整個 pattern `4 | 5 | 6`，而不僅僅是最後一個值 `6`。換句話說，match guard 相對於 pattern 的優先級行為如下：

```
(4 | 5 | 6) if y => ...
```

而不是這樣：

```
4 | 5 | (6 if y) => ...
```

執行程式碼後，優先級的行為就很明顯了：如果 match guard 只應用於使用 `|` 運算子指定的值列表中的最後一個值，那麼該分支就會匹配，程式就會印出 `yes`。

### `@` 綁定

_at_ 運算子 `@` 讓我們可以在測試一個值是否匹配某個 pattern 的同時，建立一個持有該值的變數。在列表 19-29 中，我們想要測試一個 `Message::Hello` 的 `id` 欄位是否在 `3..=7` 的範圍內。我們也想將該值綁定到變數 `id`，以便我們可以在與該分支相關的程式碼中使用它。

```rust
    enum Message {
        Hello { id: i32 },
    }

    let msg = Message::Hello { id: 5 };

    match msg {
        Message::Hello {
            id: id @ 3..=7,
        } => println!("Found an id in range: {id}"),
        Message::Hello { id: 10..=12 } => {
            println!("Found an id in another range")
        }
        Message::Hello { id } => println!("Found some other id: {id}"),
    }
```

列表 19-29：使用 `@` 在一個 pattern 中綁定一個值，同時對其進行測試

這個範例將會印出 `Found an id in range: 5`。透過在範圍 `3..=7` 前面指定 `id @`，我們在測試該值是否匹配範圍 pattern 的同時，將匹配該範圍的任何值捕獲到一個名為 `id` 的變數中。

在第二個分支中，我們只在 pattern 中指定了一個範圍，與該分支相關的程式碼沒有一個變數包含 `id` 欄位的實際值。`id` 欄位的值可能是 10、11 或 12，但與該 pattern 相關的程式碼並不知道是哪一個。pattern 程式碼無法使用 `id` 欄位的值，因為我們沒有將 `id` 值儲存在一個變數中。

在最後一個分支中，我們指定了一個沒有範圍的變數，我們確實可以在分支的程式碼中，在一個名為 `id` 的變數中使用這個值。原因在於我們使用了 struct 欄位的簡寫語法。但我們沒有像前兩個分支那樣，對這個分支中 `id` 欄位的值進行任何測試：任何值都會匹配這個 pattern。

使用 `@` 讓我們可以在一個 pattern 中測試一個值並將其儲存在一個變數中。

## 總結

Rust 的 pattern 在區分不同種類的資料方面非常有用。當在 `match` 表達式中使用時，Rust 會確保你的 pattern 涵蓋了所有可能的值，否則你的程式將無法編譯。在 `let` 陳述式和函式參數中的 pattern 使這些結構更加有用，能夠將值解構成更小的部分，並將這些部分賦值給變數。我們可以建立簡單或複雜的 pattern 來滿足我們的需求。

接下來，在本書的倒數第二章，我們將探討 Rust 各種特性的一些進階方面。
