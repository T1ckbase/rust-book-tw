<!-- DO NOT EDIT THIS FILE.

This file is periodically generated from the content in the `/src/`
directory, so all fixes need to be made in `/src/`.
-->

[TOC]

# 智慧型指標（Smart Pointers）

_指標_（pointer）是一個通用概念，代表一個包含記憶體位址的變數。這個位址指向（“points at”）某些其他資料。在 Rust 中最常見的指標類型是參考（reference），你在第四章學過。參考由 `&` 符號表示，並借用它們所指向的值。除了指向資料以外，它們沒有任何特殊功能，而且沒有額外的開銷（overhead）。

另一方面，_智慧型指標_（smart pointers）是資料結構，它們像指標一樣運作，但同時也具有額外的中繼資料和功能。智慧型指標的概念並非 Rust 獨有：智慧型指標起源於 C++，也存在於其他語言中。Rust 的標準函式庫中定義了多種智慧型指標，提供超越參考所能提供的功能。為了探索這個通用概念，我們將看幾個不同的智慧型指標範例，包括一種_參考計數_（reference counting）智慧型指標類型。這種指標能讓你透過追蹤 owner 的數量來允許資料有多個 owner，當沒有 owner 剩下時，會清理資料。

Rust 透過其 ownership 和 borrowing 的概念，使得參考和智慧型指標之間有額外的區別：雖然參考只是借用資料，但在許多情況下，智慧型指標*擁有*它們指向的資料。

智慧型指標通常是使用 struct 實作的。與普通 struct 不同，智慧型指標實作了 `Deref` 和 `Drop` trait。`Deref` trait 允許智慧型指標 struct 的實例表現得像參考，這樣你就可以編寫程式碼，使其同時適用於參考或智慧型指標。`Drop` trait 允許你客製化當智慧型指標實例超出作用域時執行的程式碼。在本章中，我們將討論這兩個 trait，並展示它們對智慧型指標的重要性。

鑑於智慧型指標模式是 Rust 中經常使用的通用設計模式，本章不會涵蓋所有現有的智慧型指標。許多函式庫都有自己的智慧型指標，你甚至可以編寫自己的智慧型指標。我們將涵蓋標準函式庫中最常見的智慧型指標：

- `Box<T>`：用於在 heap 上分配值。
- `Rc<T>`：一種參考計數類型，允許多個 ownership。
- `Ref<T>` 和 `RefMut<T>`：透過 `RefCell<T>` 存取，一種在 runtime 而非 compile time 強制執行 borrowing 規則的類型。

此外，我們將涵蓋_內部可變性_（interior mutability）模式，其中一個不可變類型會暴露出用於改變內部值的 API。我們還將討論參考循環（reference cycles）：它們如何導致記憶體洩漏，以及如何避免它們。

讓我們深入研究！

## 使用 Box<T> 指向 Heap 上的資料

最直接的智慧型指標是 box，其類型寫為 `Box<T>`。_Box_ 允許你將資料儲存在 heap 而不是 stack 上。留在 stack 上的是指向 heap 資料的指標。請參考第四章以複習 stack 和 heap 之間的差異。

Box 沒有效能開銷，除了將資料儲存在 heap 而不是 stack 上之外。但它們也沒有太多額外的功能。你最常在這些情況下使用它們：

- 當你有一種在 compile time 無法確定大小的類型，並且你希望在需要確切大小的上下文中實用該類型的值時。
- 當你擁有大量資料並希望轉移 ownership 但確保資料在轉移時不會被複製時。
- 當你想要擁有一個值，並且只關心它是一個實作了特定 trait 的類型，而不是特定類型時。

我們將在「透過 Box 啟用遞迴型別」中展示第一種情況。在第二種情況中，轉移大量資料的 ownership 可能會花費很長時間，因為資料會在 stack 上被複製。為改善這種情況下的效能，我們可以將大量資料儲存在 box 的 heap 上。然後，只有少量的指標資料會在 stack 上複製，而它所參考的資料則會留在 heap 上的單一位置。第三種情況稱為 _trait object_，第十八章中的「使用 Trait Object 允許不同類型的值」專門討論這個主題。所以你在此學到的知識將在該部分再次應用！

### 使用 Box<T> 將資料儲存在 Heap 上

在我們討論 `Box<T>` 的 heap 儲存使用案例之前，我們將涵蓋語法以及如何與儲存在 `Box<T>` 內的值互動。

範例 15-1 顯示了如何使用 box 將 `i32` 值儲存在 heap 上。

src/main.rs

```rust
fn main() {
    let b = Box::new(5);
    println!("b = {b}");
}
```

範例 15-1：使用 box 將 `i32` 值儲存在 heap 上

我們將變數 `b` 定義為一個 `Box` 的值，該 `Box` 指向值 `5`，而 `5` 被分配在 heap 上。此程式將印出 `b = 5`；在這種情況下，我們可以像資料在 stack 上一樣存取 box 中的資料。就像任何 owned 的值一樣，當 box 超出作用域時，就像 `b` 在 `main` 結束時一樣，它將被解除分配。解除分配會同時發生在 box（儲存在 stack 上）和它指向的資料（儲存在 heap 上）。

將單個值放在 heap 上並沒有多大用處，因此你不會經常以這種方式單獨使用 box。在大多數情況下，將像單個 `i32` 這樣的值放在 stack 上（它們預設儲存的位置）更合適。讓我們看一個 box 允許我們定義如果沒有 box 就無法定義的類型的情況。

### 透過 Box 啟用遞迴型別

_遞迴型別_（recursive type）的值可以將同類型的另一個值作為其自身的一部分。遞迴型別會帶來一個問題，因為 Rust 需要在 compile time 知道類型佔用多少空間。然而，遞迴型別的值的巢狀結構在理論上可以無限繼續下去，因此 Rust 無法知道該值需要多少空間。由於 box 有已知大小，我們可以透過在遞迴類型定義中插入一個 box 來啟用遞迴類型。

作為遞迴型別的一個範例，讓我們探索_串列（cons list）_。這是一種在函數式程式語言中常見的資料類型。我們將定義的串列類型除了遞迴之外都很簡單；因此，我們將使用的範例中的概念在任何你遇到涉及遞迴型別的更複雜情況時都會很有用。

#### 關於串列的更多資訊

_串列_（cons list）是一種來自 Lisp 程式語言及其方言的資料結構，由巢狀對（nested pairs）組成，是 Lisp 版本的 linked list。其名稱來自 Lisp 中的 `cons` 函數（construct function 的縮寫），該函數從其兩個參數建構一個新對。透過在包含一個值和另一個對的對上呼叫 `cons`，我們可以建構由遞迴對組成的串列。

例如，這是一個包含 `1, 2, 3` 列表的串列的偽程式碼表示，每個對都在括號中：

```
(1, (2, (3, Nil)))
```

串列中的每個項目都包含兩個元素：目前項目的值和下一個項目。清單中的最後一個項目只包含一個名為 `Nil` 的值，沒有下一個項目。串列是透過遞迴呼叫 `cons` 函數產生的。表示遞迴基本情況的標準名稱是 `Nil`。請注意，這與第六章中討論的「null」或「nil」概念不同，該概念表示無效或不存在的值。

串列在 Rust 中不是常用的資料結構。大多數情況下，當你在 Rust 中有一個項目列表時，`Vec<T>` 是一個更好的選擇。其他更複雜的遞迴資料類型在各種情況下*都*很有用，但本章從串列開始，可以讓我們在不分散注意力的情況下探索 box 如何讓我們定義遞迴資料類型。

範例 15-2 包含串列的 enum 定義。請注意，這段程式碼尚無法編譯，因為 `List` 類型沒有已知大小，我們將會展示這一點。

src/main.rs

```rust
enum List {
    Cons(i32, List),
    Nil,
}
```

範例 15-2：第一次嘗試定義一個 enum 來表示 `i32` 值的串列資料結構

> 注意：為了這個範例的目的，我們實作了一個只持有 `i32` 值 的串列。我們可以使用泛型來實作它，就像我們在第十章中討論的那樣，以定義一個可以儲存任何類型值的串列類型。

使用 `List` 類型來儲存 `1, 2, 3` 列表將如下範例 15-3 所示。

src/main.rs

```rust
// --snip--

use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Cons(2, Cons(3, Nil)));
}
```

範例 15-3：使用 `List` enum 儲存 `1, 2, 3` 列表

第一個 `Cons` 值持有 `1` 和另一個 `List` 值。這個 `List` 值是另一個 `Cons` 值，它持有 `2` 和另一個 `List` 值。這個 `List` 值是再一個 `Cons` 值，它持有 `3` 和一個 `List` 值，這個 `List` 值最終是 `Nil`，這是表示列表結束的非遞迴 variant。

如果我們嘗試編譯範例 15-3 中的程式碼，我們將得到範例 15-4 中顯示的錯誤。

```
$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
error[E0072]: recursive type `List` has infinite size
 --> src/main.rs:1:1
  |
1 | enum List {
  | ^^^^^^^^^
2 |     Cons(i32, List),
  |               ---- recursive without indirection
  |
help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to break the cycle
  |
2 |     Cons(i32, Box<List>),
  |               ++++    +

error[E0391]: cycle detected when computing when `List` needs drop
 --> src/main.rs:1:1
  |
1 | enum List {
  | ^^^^^^^^^
  |
  = note: ...which immediately requires computing when `List` needs drop again
  = note: cycle used when computing whether `List` needs drop
  = note: see https://rustc-dev-guide.rust-lang.org/overview.html#queries and https://rustc-dev-guide.rust-lang.org/query.html for more information

Some errors have detailed explanations: E0072, E0391.
For more information about an error, try `rustc --explain E0072`.
error: could not compile `cons-list` (bin "cons-list") due to 2 previous errors
```

範例 15-4：嘗試定義遞迴 enum 時遇到的錯誤

錯誤顯示此類型「具有無限大小」。原因在於我們使用遞迴方式定義 `List` 的其中一個 variant：它直接持有另一個相同類型的值。因此，Rust 無法確定儲存 `List` 值所需的空間大小。讓我們分解一下為什麼會出現這個錯誤。首先，我們將看看 Rust 如何決定儲存非遞迴類型值所需的空間大小。

#### 計算非遞迴類型的大小

回想我們在第六章討論 enum 定義時在範例 6-2 中定義的 `Message` enum：

```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
```

為了確定為 `Message` 值分配多少空間，Rust 會遍歷每個 variant，看看哪個 variant 需要最多空間。Rust 會看到 `Message::Quit` 不需要任何空間，`Message::Move` 需要足夠空間來儲存兩個 `i32` 值，依此類推。因為只會使用一個 variant，所以 `Message` 值所需的最大空間是其最大 variant 所需的空間。

將此與 Rust 嘗試確定遞迴類型（如範例 15-2 中的 `List` enum）需要多少空間時發生的情況進行對比。編譯器首先查看 `Cons` variant，它持有 `i32` 類型的值和 `List` 類型的值。因此，`Cons` 需要的空間量等於 `i32` 的大小加上 `List` 的大小。為了弄清楚 `List` 類型需要多少記憶體，編譯器會查看 variant，從 `Cons` variant 開始。`Cons` variant 持有 `i32` 類型的值和 `List` 類型的值，這個過程會無限地持續下去，如圖 15-1 所示。

![An infinite Cons list: a rectangle labeled 'Cons' split into two smaller rectangles. The first smaller rectangle holds the label 'i32', and the second smaller rectangle holds the label 'Cons' and a smaller version of the outer 'Cons' rectangle. The 'Cons' rectangles continue to hold smaller and smaller versions of themselves until the smallest comfortably-sized rectangle holds an infinity symbol, indicating that this repetition goes on forever](https://doc.rust-lang.org/book/img/trpl15-01.svg)

圖 15-1：由無限 `Cons` variant 組成的無限 `List`

#### 使用 Box<T> 取得已知大小的遞迴類型

因為 Rust 無法確定為遞迴定義類型分配多少空間，編譯器會提供一個錯誤，並附帶這個有用的建議：

```
help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to break the cycle
  |
2 |     Cons(i32, Box<List>),
  |               ++++    +
```

在這個建議中，_間接_（indirection）意味著我們不應該直接儲存一個值，而是應該改變資料結構以透過儲存一個指向該值的指標來間接儲存該值。

因為 `Box<T>` 是一個指標，Rust 總是知道 `Box<T>` 需要多少空間：指標的大小不會因其指向的資料量而改變。這表示我們可以將 `Box<T>` 放入 `Cons` variant 中，而不是直接放入另一個 `List` 值。`Box<T>` 將指向 heap 上的下一個 `List` 值，而不是 `Cons` variant 內部。概念上，我們仍然有一個列表，由包含其他列表的列表創建，但此實作現在更像是將項目並排放置，而不是相互包含。

我們可以將範例 15-2 中的 `List` enum 定義和範例 15-3 中 `List` 的使用變更為範例 15-5 中的程式碼，這將會編譯。

src/main.rs

```rust
enum List {
    Cons(i32, Box<List>),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));
}
```

範例 15-5：使用 `Box<T>` 的 `List` 定義以具有已知大小

`Cons` variant 需要一個 `i32` 的大小加上儲存 box 指標資料的空間。`Nil` variant 不儲存任何值，因此它在 stack 上需要的空間比 `Cons` variant 少。我們現在知道任何 `List` 值將佔用一個 `i32` 的大小加上一個 box 指標資料的大小。透過使用 box，我們打破了無限的遞迴鏈，因此編譯器可以計算出儲存 `List` 值所需的空間大小。圖 15-2 顯示了 `Cons` variant 現在的樣子。

![A rectangle labeled 'Cons' split into two smaller rectangles. The first smaller rectangle holds the label 'i32', and the second smaller rectangle holds the label 'Box' with one inner rectangle that contains the label 'usize', representing the finite size of the box's pointer](https://doc.rust-lang.org/book/img/trpl15-02.svg)

圖 15-2：一個沒有無限大小的 `List`，因為 `Cons` 持有 `Box`

Box 只提供間接和 heap 分配；它們沒有任何其他特殊功能，就像我們將在其他智慧型指標類型中看到的那樣。它們也沒有這些特殊功能所帶來的效能開銷，因此它們在串列等情況下很有用，在這些情況下，間接性是我們需要的唯一功能。我們將在第十八章中查看更多 box 的使用案例。

`Box<T>` 類型是一個智慧型指標，因為它實作了 `Deref` trait，這使得 `Box<T>` 值可以像參考一樣被對待。當 `Box<T>` 值超出作用域時，box 指向的 heap 資料也會因為 `Drop` trait 的實作而被清理。這兩個 trait 對於本章其餘部分我們將討論的其他智慧型指標類型所提供的功能將更為重要。讓我們更詳細地探討這兩個 trait。

## 使用 Deref 將智慧型指標視為一般參考

實作 `Deref` trait 允許你客製化_解參考運算子_ `*` 的行為（不要與乘法或 glob 運算子混淆）。透過以智慧型指標可以像一般參考一樣被對待的方式實作 `Deref`，你可以編寫作用於參考的程式碼，並將該程式碼與智慧型指標一起使用。

讓我們先看看解參考運算子如何與一般參考一起運作。然後我們將嘗試定義一個行為類似 `Box<T>` 的自訂類型，並看看為什麼解參考運算子在我們新定義的類型上不像參考一樣運作。我們將探索實作 `Deref` trait 如何使智慧型指標能夠以類似參考的方式運作。然後我們將看看 Rust 的 _deref 強制轉型_（deref coercion）功能以及它如何讓我們使用參考或智慧型指標。

### 追蹤參考到值

一般參考是一種指標類型，指標的一種思考方式是將其視為指向儲存在其他地方的值的箭頭。在範例 15-6 中，我們建立了一個指向 `i32` 值 的參考，然後使用解參考運算子來追蹤參考到該值。

src/main.rs

```rust
fn main() {
    let x = 5;
    let y = &x;

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
```

範例 15-6：使用解參考運算子追蹤指向 `i32` 值 的參考

變數 `x` 持有一個 `i32` 值 `5`。我們將 `y` 設定為 `x` 的參考。我們可以斷言 `x` 等於 `5`。然而，如果我們想斷言 `y` 中的值，我們必須使用 `*y` 來追蹤參考到它所指向的值（因此是_解參考_），這樣編譯器才能比較實際值。一旦我們解參考 `y`，我們就可以存取 `y` 所指向的整數值，我們可以將其與 `5` 進行比較。

如果我們嘗試改寫 `assert_eq!(5, y);`，我們會得到以下編譯錯誤：

```
$ cargo run
   Compiling deref-example v0.1.0 (file:///projects/deref-example)
error[E0277]: can't compare `{integer}` with `&{integer}`
 --> src/main.rs:6:5
  |
6 |     assert_eq!(5, y);
  |     ^^^^^^^^^^^^^^^^ no implementation for `{integer} == &{integer}`
  |
  = help: the trait `PartialEq<&{integer}>` is not implemented for `{integer}`
  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)

For more information about this error, try `rustc --explain E0277`.
error: could not compile `deref-example` (bin "deref-example") due to 1 previous error
```

比較數字與數字的參考是不允許的，因為它們是不同的類型。我們必須使用解參考運算子來追蹤參考到它所指向的值。

### 將 Box<T> 視為參考使用

我們可以重寫範例 15-6 中的程式碼，改用 `Box<T>` 而不是參考；範例 15-7 中用於 `Box<T>` 的解參考運算子與範例 15-6 中用於參考的解參考運算子以相同的方式運作。

src/main.rs

```rust
fn main() {
    let x = 5;
    let y = Box::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
```

範例 15-7：在 `Box<i32>` 上使用解參考運算子

範例 15-7 和範例 15-6 的主要區別在於，這裡我們將 `y` 設定為一個指向 `x` 的複製值的 box 實例，而不是一個指向 `x` 值的參考。在最後一個斷言中，我們可以使用解參考運算子來追蹤 box 的指標，就像 `y` 是一個參考時一樣。接下來，我們將透過定義我們自己的 box 類型來探索 `Box<T>` 的特殊之處，這使我們能夠使用解參考運算子。

### 定義我們自己的智慧型指標

讓我們建立一個類似標準函式庫提供的 `Box<T>` 類型的包裝器類型，以體驗智慧型指標類型預設情況下與參考的不同之處。然後我們將看看如何新增使用解參考運算子的能力。

> 注意：我們即將建構的 `MyBox<T>` 類型與真正的 `Box<T>` 有一個很大的不同：我們的版本不會將其資料儲存在 heap 上。我們將此範例的重點放在 `Deref` 上，因此資料實際儲存在何處不如指標般的行為重要。

`Box<T>` 類型最終被定義為一個帶有一個元素的 tuple struct，因此範例 15-8 以相同的方式定義了 `MyBox<T>` 類型。我們還將定義一個 `new` 函數以符合 `Box<T>` 上定義的 `new` 函數。

src/main.rs

```rust
struct MyBox<T>(T);

impl<T> MyBox<T> {
    fn new(x: T) -> MyBox<T> {
        MyBox(x)
    }
}
```

範例 15-8：定義 `MyBox<T>` 類型

我們定義了一個名為 `MyBox` 的 struct，並宣告了一個泛型參數 `T`，因為我們希望我們的類型可以持有任何類型的值。`MyBox` 類型是一個帶有一個 `T` 類型元素的 tuple struct。`MyBox::new` 函數接受一個 `T` 類型參數，並回傳一個持有傳入值的 `MyBox` 實例。

讓我們先嘗試將範例 15-7 中的 `main` 函數加入到範例 15-8 中，並將其改為使用我們定義的 `MyBox<T>` 類型而不是 `Box<T>`。範例 15-9 中的程式碼將無法編譯，因為 Rust 不知道如何解參考 `MyBox`。

src/main.rs

```rust
fn main() {
    let x = 5;
    let y = MyBox::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
```

範例 15-9：嘗試以我們使用參考和 `Box<T>` 的相同方式使用 `MyBox<T>`

這是結果編譯錯誤：

```
$ cargo run
   Compiling deref-example v0.1.0 (file:///projects/deref-example)
error[E0614]: type `MyBox<{integer}>` cannot be dereferenced
  --> src/main.rs:14:19
   |
14 |     assert_eq!(5, *y);
   |                   ^^

For more information about this error, try `rustc --explain E0614`.
error: could not compile `deref-example` (bin "deref-example") due to 1 previous error
```

我們的 `MyBox<T>` 類型無法解參考，因為我們尚未在我們的類型上實作該功能。為了啟用 `*` 運算子的解參考功能，我們實作了 `Deref` trait。

### 實作 Deref Trait

如第十章「在類型上實作 Trait」中討論的，要實作 trait，我們需要為 trait 的所需方法提供實作。標準函式庫提供的 `Deref` trait 要求我們實作一個名為 `deref` 的方法，該方法借用 `self` 並回傳內部資料的參考。範例 15-10 包含 `Deref` 的實作，以新增到 `MyBox<T>` 的定義中。

src/main.rs

```rust
use std::ops::Deref;

impl<T> Deref for MyBox<T> {
    type Target = T;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
```

範例 15-10：在 `MyBox<T>` 上實作 `Deref`

`type Target = T;` 語法定義了 `Deref` trait 要使用的關聯類型。關聯類型是一種稍微不同的宣告泛型參數的方式，但你現在不需要擔心它們；我們將在第二十章中更詳細地介紹它們。

我們使用 `&self.0` 填入 `deref` 方法的主體，這樣 `deref` 會回傳一個參考，指向我們想用 `*` 運算子存取的值；回想一下第五章的「在沒有命名欄位的情況下使用 tuple struct 建立不同型別」，其中 `.0` 存取 tuple struct 中的第一個值。範例 15-9 中對 `MyBox<T>` 值呼叫 `*` 的 `main` 函數現在會編譯，並且斷言會通過！

沒有 `Deref` trait，編譯器只能解參考 `&` 參考。`deref` 方法讓編譯器能夠取任何實作 `Deref` 的類型的值，並呼叫 `deref` 方法來取得它知道如何解參考的 `&` 參考。

當我們在範例 15-9 中輸入 `*y` 時，在幕後 Rust 實際上執行了這段程式碼：

```rust
*(y.deref())
```

Rust 會將 `*` 運算子替換為對 `deref` 方法的呼叫，然後再進行一次普通解參考，這樣我們就不必考慮是否需要呼叫 `deref` 方法了。這個 Rust 功能讓我們可以編寫無論是普通參考還是實作 `Deref` 的類型都能相同運作的程式碼。

`deref` 方法回傳一個值的參考，以及 `*(y.deref())` 中括號外面的普通解參考仍然是必要的原因，與 ownership 系統有關。如果 `deref` 方法直接回傳值而不是值的參考，那麼該值將會從 `self` 中移動出去。在這種情況下，或者在大多數我們使用解參考運算子的地方，我們不希望取得 `MyBox<T>` 內部值的 ownership。

請注意，`*` 運算子會被替換為對 `deref` 方法的呼叫，然後再對 `*` 運算子呼叫一次，每次我們在程式碼中使用 `*` 時都是如此。由於 `*` 運算子的替換不會無限遞迴，因此我們最終得到 `i32` 類型的資料，這與範例 15-9 中 `assert_eq!` 中的 `5` 相符。

### 函數和方法中的隱式 Deref 強制轉型

_Deref 強制轉型_（Deref coercion）會將實作 `Deref` trait 的類型參考轉換為另一種類型參考。例如，deref 強制轉型可以將 `&String` 轉換為 `&str`，因為 `String` 實作了 `Deref` trait，使其回傳 `&str`。Deref 強制轉型是 Rust 在函數和方法引數上執行的便利功能，並且只作用於實作 `Deref` trait 的類型。當我們將特定類型值的參考作為引數傳遞給函數或方法，而該引數的類型與函數或方法定義中的參數類型不符時，它會自動發生。一系列對 `deref` 方法的呼叫會將我們提供的類型轉換為參數所需的類型。

Deref 強制轉型被新增到 Rust 中，這樣編寫函數和方法呼叫的程式設計師就不需要使用 `&` 和 `*` 添加那麼多顯式的參考和解參考了。Deref 強制轉型功能還讓我們可以編寫更多可以同時適用於參考或智慧型指標的程式碼。

為了了解 deref 強制轉型的運作方式，讓我們使用範例 15-8 中定義的 `MyBox<T>` 類型，以及我們在範例 15-10 中新增的 `Deref` 實作。範例 15-11 顯示了一個帶有字串 slice 參數的函數定義。

src/main.rs

```rust
fn hello(name: &str) {
    println!("Hello, {name}!");
}
```

範例 15-11：一個 `hello` 函數，其參數 `name` 的類型為 `&str`

我們可以呼叫 `hello` 函數，並以字串 slice 作為引數，例如 `hello("Rust");`。Deref 強制轉型使得我們可以呼叫 `hello`，並以 `MyBox<String>` 類型的值的參考作為引數，如範例 15-12 所示。

src/main.rs

```rust
fn main() {
    let m = MyBox::new(String::from("Rust"));
    hello(&m);
}
```

範例 15-12：呼叫 `hello` 帶有 `MyBox<String>` 值的參考，因為 deref 強制轉型所以能夠運作

在這裡，我們使用引數 `&m` 呼叫 `hello` 函數，`&m` 是 `MyBox<String>` 值的參考。因為我們在範例 15-10 中在 `MyBox<T>` 上實作了 `Deref` trait，Rust 可以透過呼叫 `deref` 將 `&MyBox<String>` 轉換為 `&String`。標準函式庫在 `String` 上提供了一個 `Deref` 的實作，它回傳一個字串 slice，這在 `Deref` 的 API 文件中。Rust 會再次呼叫 `deref`，將 `&String` 轉換為 `&str`，這與 `hello` 函數的定義相符。

如果 Rust 沒有實作 deref 強制轉型，我們必須像範例 15-13 中那樣編寫程式碼，而不是範例 15-12 中的程式碼，才能用 `&MyBox<String>` 類型的值呼叫 `hello`。

src/main.rs

```rust
fn main() {
    let m = MyBox::new(String::from("Rust"));
    hello(&(*m)[..]);
}
```

範例 15-13：如果 Rust 沒有 deref 強制轉型，我們必須編寫的程式碼

`(*m)` 解參考 `MyBox<String>` 為 `String`。然後 `&` 和 `[..]` 取 `String` 的字串 slice，該 slice 等於整個字串，以符合 `hello` 的簽章。這種沒有 deref 強制轉型的程式碼，由於涉及所有這些符號，因此更難讀、寫和理解。Deref 強制轉型允許 Rust 自動為我們處理這些轉換。

當 `Deref` trait 為所涉及的類型定義時，Rust 將會分析類型並根據需要多次使用 `Deref::deref` 來獲取與參數類型匹配的參考。`Deref::deref` 需要插入的次數在 compile time 解析，因此利用 deref 強制轉型沒有 runtime 開銷！

### Deref 強制轉型如何與可變性互動

與你使用 `Deref` trait 覆寫不可變參考上的 `*` 運算子類似，你可以使用 `DerefMut` trait 覆寫可變參考上的 `*` 運算子。

Rust 在三種情況下，當它發現類型和 trait 實作時，會執行 deref 強制轉型：

1. 從 `&T` 到 `&U`，當 `T: Deref<Target=U>` 時
1. 從 `&mut T` 到 `&mut U`，當 `T: DerefMut<Target=U>` 時
1. 從 `&mut T` 到 `&U`，當 `T: Deref<Target=U>` 時

前兩種情況是相同的，只是第二種情況實作了可變性。第一種情況指出，如果你有一個 `&T`，並且 `T` 實作了 `Deref` 到某種類型 `U`，你可以透明地得到一個 `&U`。第二種情況指出，相同的 deref 強制轉型會發生在可變參考上。

第三種情況比較棘手：Rust 也會將可變參考強制轉型為不可變參考。但反過來*不*可能：不可變參考永遠不會強制轉型為可變參考。由於 borrowing 規則，如果你有一個可變參考，那個可變參考必須是該資料的唯一參考（否則，程式將無法編譯）。將一個可變參考轉換為一個不可變參考永遠不會破壞 borrowing 規則。將一個不可變參考轉換為可變參考將要求最初的不可變參考是該資料的唯一不可變參考，但 borrowing 規則不保證這一點。因此，Rust 無法假設將不可變參考轉換為可變參考是可能的。

## 使用 Drop Trait 在清理時執行程式碼

對智慧型指標模式而言重要的第二個 trait 是 `Drop`，它允許你客製化值即將超出作用域時發生的事情。你可以在任何類型上提供 `Drop` trait 的實作，該程式碼可以用於釋放檔案或網路連線等資源。

我們在智慧型指標的上下文中介紹 `Drop`，因為 `Drop` trait 的功能幾乎總是實作智慧型指標時使用的。例如，當 `Box<T>` 被 drop 時，它將解除分配 box 指向的 heap 上的空間。

在某些語言中，對於某些類型，程式設計師每次使用完這些類型的實例時，都必須呼叫程式碼來釋放記憶體或資源。例子包括檔案句柄、socket 和鎖。如果他們忘記了，系統可能會超載並崩潰。在 Rust 中，你可以指定每當值超出作用域時要執行特定程式碼，並且編譯器會自動插入此程式碼。因此，你不需要在程式中任何地方小心放置清理程式碼，而某個特定類型的實例已經完成使用——你仍然不會洩漏資源！

你可以透過實作 `Drop` trait 來指定值超出作用域時要執行的程式碼。`Drop` trait 要求你實作一個名為 `drop` 的方法，該方法接受一個 `self` 的可變參考。為了了解 Rust 何時呼叫 `drop`，我們現在暫時使用 `println!` 語句來實作 `drop`。

範例 15-14 顯示了一個 `CustomSmartPointer` struct，其唯一自訂功能是在實例超出作用域時印出 `Dropping CustomSmartPointer!`，以顯示 Rust 何時執行 `drop` 方法。

src/main.rs

```rust
struct CustomSmartPointer {
    data: String,
}

impl Drop for CustomSmartPointer {
    fn drop(&mut self) {
        println!("Dropping CustomSmartPointer with data `{}`!", self.data);
    }
}

fn main() {
    let c = CustomSmartPointer {
        data: String::from("my stuff"),
    };
    let d = CustomSmartPointer {
        data: String::from("other stuff"),
    };
    println!("CustomSmartPointers created.");
}
```

範例 15-14：一個實作了 `Drop` trait 的 `CustomSmartPointer` struct，我們可以在其中放置清理程式碼

`Drop` trait 包含在 prelude 中，所以我們不需要將它帶入作用域。我們在 `CustomSmartPointer` 上實作 `Drop` trait，並為 `drop` 方法提供一個呼叫 `println!` 的實作。`drop` 方法的主體是你想要在類型實例超出作用域時執行的任何邏輯。我們在這裡印出一些文字，以視覺化地演示 Rust 何時會呼叫 `drop`。

在 `main` 中，我們建立兩個 `CustomSmartPointer` 實例，然後印出 `CustomSmartPointers created`。在 `main` 的結尾，我們的 `CustomSmartPointer` 實例將超出作用域，Rust 將呼叫我們在 `drop` 方法中放置的程式碼，印出我們的最終訊息。請注意，我們不需要明確呼叫 `drop` 方法。

當我們執行這個程式時，我們會看到以下輸出：

```
$ cargo run
   Compiling drop-example v0.1.0 (file:///projects/drop-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.60s
     Running `target/debug/drop-example`
CustomSmartPointers created.
Dropping CustomSmartPointer with data `other stuff`!
Dropping CustomSmartPointer with data `my stuff`!
```

Rust 在我們的實例超出作用域時自動為我們呼叫了 `drop`，呼叫了我們指定的程式碼。變數會以其創建的相反順序 drop，因此 `d` 在 `c` 之前被 drop。此範例的目的是為你提供 `drop` 方法如何運作的視覺指南；通常你會指定你的類型需要運行的清理程式碼，而不是列印訊息。

不幸的是，停用自動 `drop` 功能並不容易。停用 `drop` 通常不需要；`Drop` trait 的重點在於它會自動處理。然而，偶爾你可能希望提早清理一個值。一個例子是使用管理鎖的智慧型指標時：你可能希望強制執行釋放鎖的 `drop` 方法，以便同一作用域中的其他程式碼可以取得該鎖。Rust 不允許你手動呼叫 `Drop` trait 的 `drop` 方法；相反，如果你想在值超出其作用域之前強制 drop 一個值，你必須呼叫標準函式庫提供的 `std::mem::drop` 函數。

如果我們嘗試透過修改範例 15-14 中的 `main` 函數來手動呼叫 `Drop` trait 的 `drop` 方法，如範例 15-15 所示，我們將會得到一個編譯器錯誤。

src/main.rs

```rust
fn main() {
    let c = CustomSmartPointer {
        data: String::from("some data"),
    };
    println!("CustomSmartPointer created.");
    c.drop();
    println!("CustomSmartPointer dropped before the end of main.");
}
```

範例 15-15：嘗試手動呼叫 `Drop` trait 的 `drop` 方法以提早清理

當我們嘗試編譯這段程式碼時，我們會得到以下錯誤：

```
$ cargo run
   Compiling drop-example v0.1.0 (file:///projects/drop-example)
error[E0040]: explicit use of destructor method
  --> src/main.rs:16:7
   |
16 |     c.drop();
   |       ^^^^ explicit destructor calls not allowed
   |
help: consider using `drop` function
   |
16 |     drop(c);
   |     +++++ ~

For more information about this error, try `rustc --explain E0040`.
error: could not compile `drop-example` (bin "drop-example") due to 1 previous error
```

此錯誤訊息指出我們不允許明確呼叫 `drop`。錯誤訊息使用了_解構子_（destructor）一詞，這是清理實例的通用程式設計術語。*解構子*類比於_建構子_（constructor），後者建立實例。Rust 中的 `drop` 函數是一個特定的解構子。

Rust 不允許我們明確呼叫 `drop`，因為 Rust 仍然會在 `main` 結束時自動呼叫該值的 `drop`。這將導致一個_重複釋放_（double free）錯誤，因為 Rust 將會嘗試清理同一個值兩次。

我們無法在值超出作用域時停用自動插入 `drop`，也無法明確呼叫 `drop` 方法。因此，如果我們需要強制提早清理一個值，我們可以使用 `std::mem::drop` 函數。

`std::mem::drop` 函數與 `Drop` trait 中的 `drop` 方法不同。我們透過傳遞我們想要強制 drop 的值作為引數來呼叫它。該函數在 prelude 中，所以我們可以修改範例 15-15 中的 `main` 以呼叫 `drop` 函數，如範例 15-16 所示。

src/main.rs

```rust
fn main() {
    let c = CustomSmartPointer {
        data: String::from("some data"),
    };
    println!("CustomSmartPointer created.");
    drop(c);
    println!("CustomSmartPointer dropped before the end of main.");
}
```

範例 15-16：呼叫 `std::mem::drop` 以在值超出作用域之前明確 drop

執行此程式碼將會印出以下內容：

```
$ cargo run
   Compiling drop-example v0.1.0 (file:///projects/drop-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.73s
     Running `target/debug/drop-example`
CustomSmartPointer created.
Dropping CustomSmartPointer with data `some data`!
CustomSmartPointer dropped before the end of main.
```

文字 ``Dropping CustomSmartPointer with data `some data`!`` 印在 `CustomSmartPointer created.` 和 `CustomSmartPointer dropped before the end of main.` 文字之間，這表示 `drop` 方法程式碼是在該點呼叫來 drop `c`。

你可以用許多方式使用 `Drop` trait 實作中指定的程式碼，以使清理方便且安全：例如，你可以用它來建立自己的記憶體分配器！有了 `Drop` trait 和 Rust 的 ownership 系統，你無需記住清理，因為 Rust 會自動完成。

你也不必擔心因意外清理仍在使用的值而導致的問題：確保參考始終有效的 ownership 系統也確保 `drop` 在值不再使用時只被呼叫一次。

現在我們已經研究了 `Box<T>` 和智慧型指標的一些特性，讓我們看看標準函式庫中定義的其他一些智慧型指標。

## Rc<T>：參考計數的智慧型指標

在大多數情況下，ownership 是明確的：你確切知道哪個變數擁有給定的值。然而，在某些情況下，單一值可能有多個 owner。例如，在圖形資料結構中，多個邊可能指向同一個節點，並且該節點在概念上由所有指向它的邊擁有。節點不應該被清理，除非它沒有任何邊指向它，因此沒有 owner。

你必須透過使用 Rust 類型 `Rc<T>` 明確啟用多個 ownership，它是 _reference counting_ 的縮寫。`Rc<T>` 類型會追蹤值被參考的次數，以確定該值是否仍在被使用。如果對一個值有零個參考，則該值可以被清理，而不會有任何參考變得無效。

想像 `Rc<T>` 就像一間家庭房裡的電視。當一個人進來觀看電視時，他們會打開電視。其他人可以進入房間觀看電視。當最後一個人離開房間時，他們會關閉電視，因為它不再被使用。如果有人在其他人還在觀看時關閉電視，那麼剩下的電視觀眾就會大吵大鬧！

當我們想要在 heap 上分配一些資料供程式的多個部分讀取，並且無法在 compile time 確定哪個部分最後會使用這些資料時，我們使用 `Rc<T>` 類型。如果我們知道哪個部分最後會完成，我們可以讓該部分成為資料的 owner，並且在 compile time 強制執行的正常 ownership 規則將會生效。

請注意，`Rc<T>` 僅適用於單執行緒場景。當我們在第十六章討論並行時，我們將介紹如何在多執行緒程式中進行參考計數。

### 使用 Rc<T> 共享資料

讓我們回到範例 15-5 中的串列範例。回想一下，我們使用 `Box<T>` 定義了它。這次，我們將建立兩個列表，它們都共享第三個列表的 ownership。概念上，這看起來類似於圖 15-3。

![A linked list with the label 'a' pointing to three elements: the first element contains the integer 5 and points to the second element. The second element contains the integer 10 and points to the third element. The third element contains the value 'Nil' that signifies the end of the list; it does not point anywhere. A linked list with the label 'b' points to an element that contains the integer 3 and points to the first element of list 'a'. A linked list with the label 'c' points to an element that contains the integer 4 and also points to the first element of list 'a', so that the tail of lists 'b' and 'c' are both list 'a'](https://doc.rust-lang.org/book/img/trpl15-03.svg)

圖 15-3：兩個列表 `b` 和 `c` 共享第三個列表 `a` 的 ownership

我們將建立一個包含 `5` 和 `10` 的列表 `a`。然後我們將再建立兩個列表：`b` 開頭為 `3`，`c` 開頭為 `4`。`b` 和 `c` 兩個列表隨後都會繼續到包含 `5` 和 `10` 的第一個 `a` 列表。換句話說，兩個列表都將共享包含 `5` 和 `10` 的第一個列表。

嘗試使用我們定義的 `List` 與 `Box<T>` 來實作此場景將無法運作，如範例 15-17 所示。

src/main.rs

```rust
enum List {
    Cons(i32, Box<List>),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));
    let b = Cons(3, Box::new(a));
    let c = Cons(4, Box::new(a));
}
```

範例 15-17：演示我們不允許有兩個使用 `Box<T>` 的列表嘗試共享第三個列表的 ownership

當我們編譯這段程式碼時，我們會得到以下錯誤：

```
$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
error[E0382]: use of moved value: `a`
  --> src/main.rs:11:30
   |
9  |     let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));
   |         - move occurs because `a` has type `List`, which does not implement the `Copy` trait
10 |     let b = Cons(3, Box::new(a));
   |                              - value moved here
11 |     let c = Cons(4, Box::new(a));
   |                              ^ value used here after move

For more information about this error, try `rustc --explain E0382`.
error: could not compile `cons-list` (bin "cons-list") due to 1 previous error
```

`Cons` variant 擁有它們持有的資料，所以當我們建立 `b` 列表時，`a` 被移動到 `b` 中，`b` 擁有 `a`。然後，當我們在建立 `c` 時再次嘗試使用 `a` 時，我們不被允許，因為 `a` 已經被移動了。

我們可以更改 `Cons` 的定義以改為持有參考，但這樣我們就必須指定 lifetime 參數。透過指定 lifetime 參數，我們將指定列表中的每個元素都將至少與整個列表一樣長。範例 15-17 中的元素和列表就是這種情況，但在所有情況下都不是如此。

相反，我們將改變 `List` 的定義，以 `Rc<T>` 取代 `Box<T>`，如範例 15-18 所示。現在每個 `Cons` variant 都會持有一個值和一個指向 `List` 的 `Rc<T>`。當我們建立 `b` 時，我們不會取得 `a` 的 ownership，而是會複製 `a` 所持有的 `Rc<List>`，從而將參考數量從一個增加到兩個，並讓 `a` 和 `b` 共享該 `Rc<List>` 中資料的 ownership。我們在建立 `c` 時也會複製 `a`，將參考數量從兩個增加到三個。每次我們呼叫 `Rc::clone` 時，`Rc<List>` 內資料的參考計數都會增加，並且除非對它有零個參考，否則資料不會被清理。

src/main.rs

```rust
enum List {
    Cons(i32, Rc<List>),
    Nil,
}

use crate::List::{Cons, Nil};
use std::rc::Rc;

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    let b = Cons(3, Rc::clone(&a));
    let c = Cons(4, Rc::clone(&a));
}
```

範例 15-18：使用 `Rc<T>` 的 `List` 定義

我們需要新增一個 `use` 語句來將 `Rc<T>` 引入作用域，因為它不在 prelude 中。在 `main` 中，我們建立包含 `5` 和 `10` 的列表，並將其儲存在 `a` 中的新 `Rc<List>` 中。然後，當我們建立 `b` 和 `c` 時，我們呼叫 `Rc::clone` 函數並將 `a` 中的 `Rc<List>` 的參考作為引數傳遞。

我們可以呼叫 `a.clone()` 而不是 `Rc::clone(&a)`，但在這種情況下，Rust 的慣例是使用 `Rc::clone`。`Rc::clone` 的實作不會像大多數類型的 `clone` 實作那樣深度複製所有資料。呼叫 `Rc::clone` 只會增加參考計數，這不需要花費太多時間。資料的深度複製可能需要很多時間。透過使用 `Rc::clone` 進行參考計數，我們可以在深度複製類型的複製和增加參考計數的複製之間進行視覺區分。在尋找程式碼中的效能問題時，我們只需要考慮深度複製的複製，並且可以忽略對 `Rc::clone` 的呼叫。

### 複製 Rc<T> 會增加參考計數

讓我們改變範例 15-18 中的工作範例，這樣我們就可以看到當我們建立和 drop 對 `a` 中 `Rc<List>` 的參考時，參考計數的變化。

在範例 15-19 中，我們將改變 `main`，使其在列表 `c` 周圍有一個內部作用域；然後我們可以看到當 `c` 超出作用域時，參考計數如何變化。

src/main.rs

```rust
// --snip--

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    println!("count after creating a = {}", Rc::strong_count(&a));
    let b = Cons(3, Rc::clone(&a));
    println!("count after creating b = {}", Rc::strong_count(&a));
    {
        let c = Cons(4, Rc::clone(&a));
        println!("count after creating c = {}", Rc::strong_count(&a));
    }
    println!("count after c goes out of scope = {}", Rc::strong_count(&a));
}
```

範例 15-19：印出參考計數

在程式中參考計數變化的每個點，我們都會印出參考計數，這透過呼叫 `Rc::strong_count` 函數來取得。這個函數之所以命名為 `strong_count` 而不是 `count`，是因為 `Rc<T>` 類型還有一個 `weak_count`；我們將在「使用 `Weak<T>` 預防參考循環」中看到 `weak_count` 的用途。

這段程式碼印出以下內容：

```
$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.45s
     Running `target/debug/cons-list`
count after creating a = 1
count after creating b = 2
count after creating c = 3
count after c goes out of scope = 2
```

我們可以看到 `a` 中的 `Rc<List>` 的初始參考計數為 1；然後每次我們呼叫 `clone` 時，計數都會增加 1。當 `c` 超出作用域時，計數會減少 1。我們不需要像呼叫 `Rc::clone` 來增加參考計數那樣呼叫一個函數來減少參考計數：`Drop` trait 的實作會在 `Rc<T>` 值超出作用域時自動減少參考計數。

我們在這個範例中看不到的是，當 `b` 和 `a` 在 `main` 結束時超出作用域時，計數變為 0，並且 `Rc<List>` 完全被清理。使用 `Rc<T>` 允許單一值有多個 owner，並且計數確保只要任何 owner 仍然存在，該值就仍然有效。

透過不可變參考，`Rc<T>` 允許你只在程式的多個部分之間共享資料以供讀取。如果 `Rc<T>` 也允許你有多個可變參考，你可能會違反第四章討論的其中一個 borrowing 規則：對同一位置的多個可變借用可能導致資料競爭和不一致。但能夠改變資料非常有用！在下一節中，我們將討論內部可變性模式以及你可以與 `Rc<T>` 結合使用的 `RefCell<T>` 類型，以解決這種不可變性限制。

## RefCell<T> 與內部可變性模式

_內部可變性_（interior mutability）是 Rust 中的一種設計模式，它允許你在資料存在不可變參考時仍然修改資料；通常，此操作會被 borrowing 規則禁止。為了修改資料，該模式會在資料結構內部使用 `unsafe` 程式碼，以彎曲 Rust 通常管理修改和借用的規則。Unsafe 程式碼向編譯器表明我們正在手動檢查規則，而不是依賴編譯器為我們檢查；我們將在第二十章中更詳細地討論 unsafe 程式碼。

我們只能在我們能夠確保 borrowing 規則將在 runtime 遵循時才使用採用內部可變性模式的類型，即使編譯器無法保證這一點。所涉及的 `unsafe` 程式碼隨後被包裝在一個 safe API 中，並且外部類型仍然是不可變的。

讓我們透過查看遵循內部可變性模式的 `RefCell<T>` 類型來探索這個概念。

### 使用 RefCell<T> 在 Runtime 強制執行 Borrowing 規則

與 `Rc<T>` 不同，`RefCell<T>` 類型代表其持有的資料的單一 ownership。那麼是什麼讓 `RefCell<T>` 與 `Box<T>` 這樣的類型不同呢？回想你在第四章學到的 borrowing 規則：

- 在任何給定時間，你只能擁有*一個*可變參考，或者任意數量的不可變參考（但不能同時擁有兩者）。
- 參考必須始終有效。

對於參考和 `Box<T>`，borrowing 規則的不變量在 compile time 強制執行。對於 `RefCell<T>`，這些不變量在 _runtime_ 強制執行。對於參考，如果你違反了這些規則，你將會得到一個 compile time 錯誤。對於 `RefCell<T>`，如果你違反了這些規則，你的程式將會 `panic!` 並退出。

在 compile time 檢查 borrowing 規則的優點是，錯誤會在開發過程的早期被發現，並且對 runtime 效能沒有影響，因為所有分析都是預先完成的。基於這些原因，在 compile time 檢查 borrowing 規則是大多數情況下的最佳選擇，這也是 Rust 的預設設定。

在 runtime 檢查 borrowing 規則的優點是，某些記憶體安全的場景現在被允許，而這些場景原本會被 compile time 檢查所禁止。靜態分析，例如 Rust 編譯器，本質上是保守的。程式碼的某些屬性是無法透過分析程式碼來檢測的：最著名的例子是停機問題（Halting Problem），這超出了本書的範圍，但卻是一個有趣的探索主題。

因為某些分析是不可能的，如果 Rust 編譯器無法確定程式碼符合 ownership 規則，它可能會拒絕一個正確的程式；以這種方式，它是保守的。如果 Rust 接受了一個不正確的程式，使用者將無法信任 Rust 所做的保證。然而，如果 Rust 拒絕了一個正確的程式，程式設計師會感到不便，但不會發生任何災難性的事情。`RefCell<T>` 類型在你確定你的程式碼遵循 borrowing 規則但編譯器無法理解並保證時非常有用。

與 `Rc<T>` 類似，`RefCell<T>` 僅適用於單執行緒場景，如果你嘗試在多執行緒上下文中使用它，將會收到一個 compile time 錯誤。我們將在第十六章討論如何在多執行緒程式中取得 `RefCell<T>` 的功能。

以下是選擇 `Box<T>`、`Rc<T>` 或 `RefCell<T>` 的原因概述：

- `Rc<T>` 允許同一個資料有多個 owner；`Box<T>` 和 `RefCell<T>` 只有單一 owner。
- `Box<T>` 允許在 compile time 檢查不可變或可變借用；`Rc<T>` 只允許在 compile time 檢查不可變借用；`RefCell<T>` 允許在 runtime 檢查不可變或可變借用。
- 因為 `RefCell<T>` 允許在 runtime 檢查可變借用，即使 `RefCell<T>` 是不可變的，你也可以改變 `RefCell<T>` 內的值。

在不可變值內部改變值是*內部可變性*模式。讓我們看看一個內部可變性有用的情況，並探討它如何可能實現。

### 內部可變性：不可變值的一個可變借用

borrowing 規則的一個結果是，當你擁有一個不可變值時，你不能可變地借用它。例如，這段程式碼將無法編譯：

```rust
fn main() {
    let x = 5;
    let y = &mut x;
}
```

如果你嘗試編譯這段程式碼，你會得到以下錯誤：

```
$ cargo run
   Compiling borrowing v0.1.0 (file:///projects/borrowing)
error[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable
 --> src/main.rs:3:13
  |
3 |     let y = &mut x;
  |             ^^^^^^ cannot borrow as mutable
  |
help: consider changing this to be mutable
  |
2 |     let mut x = 5;
  |         +++

For more information about this error, try `rustc --explain E0596`.
error: could not compile `borrowing` (bin "borrowing") due to 1 previous error
```

然而，在某些情況下，如果一個值在其方法中可以自行改變，但對其他程式碼來說卻是不可變的，這將會很有用。該值的方法之外的程式碼將無法改變該值。使用 `RefCell<T>` 是實現內部可變性的一種方法，但 `RefCell<T>` 並未完全繞過 borrowing 規則：編譯器中的借用檢查器允許這種內部可變性，而 borrowing 規則則在 runtime 進行檢查。如果你違反了規則，你將會得到一個 `panic!` 而不是編譯器錯誤。

讓我們來看看一個實際的範例，我們可以使用 `RefCell<T>` 來改變一個不可變值，並看看為什麼這很有用。

#### 內部可變性的一個使用案例：Mock Objects

有時候在測試期間，程式設計師會使用一種類型來代替另一種類型，以便觀察特定行為並斷言它被正確實作。這種佔位符類型稱為_測試替身_（test double）。你可以從電影製作中的特技替身這個意義上去思考它，特技替身代替演員執行一個特別棘手的場景。當我們執行測試時，測試替身會代替其他類型。_Mock object_ 是特定類型的測試替身，它們在測試期間記錄發生的事情，這樣你就可以斷言正確的動作已經發生。

Rust 沒有像其他語言那樣的物件概念，而且 Rust 的標準函式庫中也沒有像其他語言那樣內建 mock object 功能。然而，你絕對可以建立一個 struct，它將與 mock object 達到相同的目的。

以下是我們將測試的場景：我們將建立一個函式庫，它會追蹤一個值與最大值的關係，並根據目前值與最大值的接近程度發送訊息。例如，此函式庫可以用於追蹤使用者允許發送 API 呼叫的配額。

我們的函式庫只會提供追蹤值與最大值接近程度的功能，以及在何時應該發送哪些訊息。使用我們函式庫的應用程式預計將提供發送訊息的機制：應用程式可以在應用程式中放入訊息，發送電子郵件，發送簡訊，或執行其他操作。函式庫不需要知道這些細節。它只需要實作一個我們將提供的名為 `Messenger` 的 trait。範例 15-20 顯示了函式庫程式碼。

src/lib.rs

```rust
pub trait Messenger {
    fn send(&self, msg: &str);
}

pub struct LimitTracker<'a, T: Messenger> {
    messenger: &'a T,
    value: usize,
    max: usize,
}

impl<'a, T> LimitTracker<'a, T>
where
    T: Messenger,
{
    pub fn new(messenger: &'a T, max: usize) -> LimitTracker<'a, T> {
        LimitTracker {
            messenger,
            value: 0,
            max,
        }
    }

    pub fn set_value(&mut self, value: usize) {
        self.value = value;

        let percentage_of_max = self.value as f64 / self.max as f64;

        if percentage_of_max >= 1.0 {
            self.messenger.send("Error: You are over your quota!");
        } else if percentage_of_max >= 0.9 {
            self.messenger
                .send("Urgent warning: You've used up over 90% of your quota!");
        } else if percentage_of_max >= 0.75 {
            self.messenger
                .send("Warning: You've used up over 75% of your quota!");
        }
    }
}
```

範例 15-20：一個函式庫，用於追蹤值與最大值的接近程度，並在值達到特定水準時發出警告

這段程式碼的一個重要部分是 `Messenger` trait 只有一個名為 `send` 的方法，該方法接受一個 `self` 的不可變參考和訊息的文字。這個 trait 是我們的 mock object 需要實作的介面，這樣 mock 就可以像真實物件一樣使用。另一個重要部分是我們想測試 `LimitTracker` 上 `set_value` 方法的行為。我們可以改變傳入 `value` 參數的值，但 `set_value` 不會回傳任何東西供我們斷言。我們希望能夠說，如果我們使用實作 `Messenger` trait 的東西和特定的 `max` 值建立一個 `LimitTracker`，當我們傳入不同的 `value` 數字時，`messenger` 會被告知發送適當的訊息。

我們需要一個 mock object，當我們呼叫 `send` 時，它不會發送電子郵件或簡訊，而只會追蹤它被告知要發送的訊息。我們可以建立一個新的 mock object 實例，建立一個使用該 mock object 的 `LimitTracker`，呼叫 `LimitTracker` 上的 `set_value` 方法，然後檢查該 mock object 是否有我們預期的訊息。範例 15-21 顯示了嘗試實作一個 mock object 來執行此操作，但借用檢查器不允許。

src/lib.rs

```rust
#[cfg(test)]
mod tests {
    use super::*;

    struct MockMessenger {
        sent_messages: Vec<String>,
    }

    impl MockMessenger {
        fn new() -> MockMessenger {
            MockMessenger {
                sent_messages: vec![],
            }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&self, message: &str) {
            self.sent_messages.push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        let mock_messenger = MockMessenger::new();
        let mut limit_tracker = LimitTracker::new(&mock_messenger, 100);

        limit_tracker.set_value(80);

        assert_eq!(mock_messenger.sent_messages.len(), 1);
    }
}
```

範例 15-21：嘗試實作一個不被借用檢查器允許的 `MockMessenger`

這個測試程式碼定義了一個 `MockMessenger` struct，它有一個 `sent_messages` 欄位，其中包含一個 `String` 值 的 `Vec`，用於追蹤它被告知要發送的訊息。我們還定義了一個關聯函數 `new`，以便方便建立以空訊息列表開始的新 `MockMessenger` 值。然後我們為 `MockMessenger` 實作了 `Messenger` trait，這樣我們就可以將 `MockMessenger` 提供給 `LimitTracker`。在 `send` 方法的定義中，我們將作為參數傳入的訊息儲存在 `MockMessenger` 的 `sent_messages` 列表中。

在測試中，我們正在測試當 `LimitTracker` 被告知將 `value` 設定為超過 `max` 值 75% 時會發生什麼。首先我們建立一個新的 `MockMessenger`，它將以空訊息列表開始。然後我們建立一個新的 `LimitTracker` 並給它一個指向新 `MockMessenger` 的參考和一個 `max` 值 `100`。我們呼叫 `LimitTracker` 上的 `set_value` 方法，其值為 `80`，這超過 100 的 75%。然後我們斷言 `MockMessenger` 正在追蹤的訊息列表現在應該有一條訊息。

然而，這個測試有一個問題，如下所示：

```
$ cargo test
   Compiling limit-tracker v0.1.0 (file:///projects/limit-tracker)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.91s
     Running unittests src/lib.rs (target/debug/deps/limit_tracker-e599811fa246dbde)

running 1 test
test tests::it_sends_an_over_75_percent_warning_message ... FAILED

failures:

---- tests::it_sends_an_over_75_percent_warning_message stdout ----

thread 'tests::it_sends_an_over_75_percent_warning_message' panicked at src/lib.rs:58:13:
cannot borrow `self.sent_messages` as mutable, as it is behind a `&` reference
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::it_sends_an_over_75_percent_warning_message

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
```

我們無法修改 `MockMessenger` 來追蹤訊息，因為 `send` 方法接受 `self` 的不可變參考。我們也無法採納錯誤訊息的建議，在 `impl` 方法和 trait 定義中都使用 `&mut self`。我們不希望僅為了測試而更改 `Messenger` trait。相反，我們需要找到一種方法，讓我們的測試程式碼與現有設計正確運作。

這種情況下內部可變性可以提供幫助！我們將把 `sent_messages` 儲存在 `RefCell<T>` 中，然後 `send` 方法將能夠修改 `sent_messages` 來儲存我們所見的訊息。範例 15-22 顯示了它的樣子。

src/lib.rs

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use std::cell::RefCell;

    struct MockMessenger {
        sent_messages: RefCell<Vec<String>>,
    }

    impl MockMessenger {
        fn new() -> MockMessenger {
            MockMessenger {
                sent_messages: RefCell::new(vec![]),
            }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&self, message: &str) {
            self.sent_messages.borrow_mut().push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        // --snip--

        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);
    }
}
```

範例 15-22：使用 `RefCell<T>` 在外部值被視為不可變時修改內部值

`sent_messages` 欄位現在是 `RefCell<Vec<String>>` 類型，而不是 `Vec<String>`。在 `new` 函數中，我們圍繞著空向量建立了一個新的 `RefCell<Vec<String>>` 實例。

對於 `send` 方法的實作，第一個參數仍然是 `self` 的不可變借用，這與 trait 定義相符。我們在 `self.sent_messages` 中的 `RefCell<Vec<String>>` 上呼叫 `borrow_mut` 以取得 `RefCell<Vec<String>>` 內部值（即向量）的可變參考。然後我們可以在向量的可變參考上呼叫 `push`，以追蹤測試期間發送的訊息。

我們必須做的最後一個更改是在斷言中：為了查看內部向量中有多少個項目，我們在 `RefCell<Vec<String>>` 上呼叫 `borrow` 以取得向量的不可變參考。

現在你已經看到如何使用 `RefCell<T>`，讓我們深入了解它的運作方式！

#### 使用 RefCell<T> 在 Runtime 追蹤借用

當建立不可變和可變參考時，我們分別使用 `&` 和 `&mut` 語法。對於 `RefCell<T>`，我們使用 `borrow` 和 `borrow_mut` 方法，這些方法是 `RefCell<T>` 的 safe API 的一部分。`borrow` 方法回傳智慧型指標類型 `Ref<T>`，而 `borrow_mut` 回傳智慧型指標類型 `RefMut<T>`。這兩種類型都實作了 `Deref`，所以我們可以將它們視為一般參考。

`RefCell<T>` 會追蹤目前有多少 `Ref<T>` 和 `RefMut<T>` 智慧型指標處於活躍狀態。每次我們呼叫 `borrow` 時，`RefCell<T>` 會增加活躍的不可變借用計數。當 `Ref<T>` 值超出作用域時，不可變借用計數會減少 1。就像 compile time 的 borrowing 規則一樣，`RefCell<T>` 允許我們在任何時間點擁有許多不可變借用或一個可變借用。

如果我們嘗試違反這些規則，`RefCell<T>` 的實作將會在 runtime `panic!`，而不是像使用參考那樣得到 compile time 錯誤。範例 15-23 顯示了範例 15-22 中 `send` 實作的修改。我們故意嘗試在同一個作用域中建立兩個活躍的可變借用，以說明 `RefCell<T>` 如何在 runtime 阻止我們這樣做。

src/lib.rs

```rust
    impl Messenger for MockMessenger {
        fn send(&self, message: &str) {
            let mut one_borrow = self.sent_messages.borrow_mut();
            let mut two_borrow = self.sent_messages.borrow_mut();

            one_borrow.push(String::from(message));
            two_borrow.push(String::from(message));
        }
    }
```

範例 15-23：在同一個作用域中建立兩個可變參考，以查看 `RefCell<T>` 會 `panic!`

我們為從 `borrow_mut` 回傳的 `RefMut<T>` 智慧型指標建立一個變數 `one_borrow`。然後我們以相同的方式在變數 `two_borrow` 中建立另一個可變借用。這會導致在同一個作用域中有兩個可變參考，這是不允許的。當我們執行函式庫的測試時，範例 15-23 中的程式碼將會編譯，沒有任何錯誤，但測試將會失敗：

```
$ cargo test
   Compiling limit-tracker v0.1.0 (file:///projects/limit-tracker)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.91s
     Running unittests src/lib.rs (target/debug/deps/limit_tracker-e599811fa246dbde)

running 1 test
test tests::it_sends_an_over_75_percent_warning_message ... FAILED

failures:

---- tests::it_sends_an_over_75_percent_warning_message stdout ----

thread 'tests::it_sends_an_over_75_percent_warning_message' panicked at src/lib.rs:60:53:
already borrowed: BorrowMutError
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::it_sends_an_over_75_percent_warning_message

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
```

請注意，程式碼在 `already borrowed: BorrowMutError` 訊息下 `panic!`。這就是 `RefCell<T>` 在 runtime 處理違反 borrowing 規則的方式。

選擇在 runtime 而非 compile time 捕捉 borrowing 錯誤，正如我們在這裡所做的，這意味著你可能會在開發過程的後期才發現程式碼中的錯誤：可能直到你的程式碼部署到生產環境時。此外，由於在 runtime 而非 compile time 追蹤借用，你的程式碼會產生少量的 runtime 效能開銷。然而，使用 `RefCell<T>` 使得編寫一個 mock object 成為可能，該 mock object 可以在你將其用於只允許不可變值的上下文中時修改自身以追蹤它所見的訊息。儘管有其取捨，你仍然可以使用 `RefCell<T>` 來獲得比一般參考更多的功能。

### 使用 Rc<T> 和 RefCell<T> 允許可變資料的多個 Owner

使用 `RefCell<T>` 的常見方式是與 `Rc<T>` 結合使用。回想一下，`Rc<T>` 允許你擁有同一資料的多個 owner，但它只提供對該資料的不可變存取。如果你有一個持有 `RefCell<T>` 的 `Rc<T>`，你可以獲得一個可以有多個 owner *並且*可以修改的值！

例如，回想範例 15-18 中的串列範例，我們使用 `Rc<T>` 來允許多個列表共享另一個列表的 ownership。由於 `Rc<T>` 只持有不可變值，一旦我們建立它們，我們就無法更改列表中的任何值。讓我們新增 `RefCell<T>`，以利用其改變列表中值的能力。範例 15-24 顯示，透過在 `Cons` 定義中使用 `RefCell<T>`，我們可以修改儲存在所有列表中的值。

src/main.rs

```rust
#[derive(Debug)]
enum List {
    Cons(Rc<RefCell<i32>>, Rc<List>),
    Nil,
}

use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

fn main() {
    let value = Rc::new(RefCell::new(5));

    let a = Rc::new(Cons(Rc::clone(&value), Rc::new(Nil)));

    let b = Cons(Rc::new(RefCell::new(3)), Rc::clone(&a));
    let c = Cons(Rc::new(RefCell::new(4)), Rc::clone(&a));

    *value.borrow_mut() += 10;

    println!("a after = {a:?}");
    println!("b after = {b:?}");
    println!("c after = {c:?}");
}
```

範例 15-24：使用 `Rc<RefCell<i32>>` 建立一個我們可以修改的 `List`

我們建立一個 `Rc<RefCell<i32>>` 的實例，並將其儲存在名為 `value` 的變數中，以便稍後直接存取它。然後我們在 `a` 中建立一個 `List`，其中有一個 `Cons` variant 持有 `value`。我們需要複製 `value`，這樣 `a` 和 `value` 都擁有內部 `5` 值的 ownership，而不是將 ownership 從 `value` 轉移到 `a` 或讓 `a` 從 `value` 借用。

我們將列表 `a` 包裝在 `Rc<T>` 中，這樣當我們建立列表 `b` 和 `c` 時，它們都可以參考 `a`，這就是我們在範例 15-18 中所做的。

在我們建立 `a`、`b` 和 `c` 中的列表之後，我們想要將 `value` 中的值增加 10。我們透過在 `value` 上呼叫 `borrow_mut` 來實現這一點，它使用我們在第五章「`->` 運算子在哪裡？」中討論的自動解參考功能，將 `Rc<T>` 解參考到內部 `RefCell<T>` 值。`borrow_mut` 方法回傳一個 `RefMut<T>` 智慧型指標，我們在其上使用解參考運算子並更改內部值。

當我們印出 `a`、`b` 和 `c` 時，我們可以看到它們都具有修改過的值 `15` 而不是 `5`：

```
$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.63s
     Running `target/debug/cons-list`
a after = Cons(RefCell { value: 15 }, Nil)
b after = Cons(RefCell { value: 3 }, Cons(RefCell { value: 15 }, Nil))
c after = Cons(RefCell { value: 4 }, Cons(RefCell { value: 15 }, Nil))
```

這個技巧非常棒！透過使用 `RefCell<T>`，我們擁有一個 outwardly 不可變的 `List` 值。但是我們可以利用 `RefCell<T>` 上的方法來存取其內部可變性，這樣我們就可以在需要時修改我們的資料。borrowing 規則的 runtime 檢查保護我們免受資料競爭的影響，並且有時為了資料結構的這種靈活性而犧牲一點速度是值得的。請注意，`RefCell<T>` 不適用於多執行緒程式碼！`Mutex<T>` 是 `RefCell<T>` 的執行緒安全版本，我們將在第十六章討論 `Mutex<T>`。

## 參考循環可能會造成記憶體洩漏

Rust 的記憶體安全保證使得意外建立永不被清理的記憶體（稱為_記憶體洩漏_）變得困難，但並非不可能。完全防止記憶體洩漏並非 Rust 的保證之一，這表示記憶體洩漏在 Rust 中是記憶體安全的。我們可以使用 `Rc<T>` 和 `RefCell<T>` 來證明 Rust 允許記憶體洩漏：有可能建立項目相互參考的循環。這會造成記憶體洩漏，因為循環中每個項目的參考計數永遠不會達到 0，並且這些值永遠不會被 drop。

### 建立參考循環

讓我們看看參考循環如何發生以及如何防止它，從範例 15-25 中的 `List` enum 定義和 `tail` 方法開始。

src/main.rs

```rust
use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
enum List {
    Cons(i32, RefCell<Rc<List>>),
    Nil,
}

impl List {
    fn tail(&self) -> Option<&RefCell<Rc<List>>> {
        match self {
            Cons(_, item) => Some(item),
            Nil => None,
        }
    }
}

fn main() {}
```

範例 15-25：一個持有 `RefCell<T>` 的串列定義，以便我們能夠修改 `Cons` variant 所參考的內容

我們正在使用範例 15-5 中 `List` 定義的另一個變體。`Cons` variant 中的第二個元素現在是 `RefCell<Rc<List>>`，這表示我們不是像範例 15-24 那樣能夠修改 `i32` 值，而是希望修改 `Cons` variant 指向的 `List` 值。我們還新增了一個 `tail` 方法，以便我們方便地存取第二個項目，如果我們有一個 `Cons` variant。

在範例 15-26 中，我們將新增一個 `main` 函數，它使用範例 15-25 中的定義。此程式碼在 `a` 中建立一個列表，並在 `b` 中建立一個指向 `a` 中列表的列表。然後它修改 `a` 中的列表以指向 `b`，從而建立一個參考循環。沿途有一些 `println!` 語句，用於顯示在此過程中各個點的參考計數。

src/main.rs

```rust
fn main() {
    let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil))));

    println!("a initial rc count = {}", Rc::strong_count(&a));
    println!("a next item = {:?}", a.tail());

    let b = Rc::new(Cons(10, RefCell::new(Rc::clone(&a))));

    println!("a rc count after b creation = {}", Rc::strong_count(&a));
    println!("b initial rc count = {}", Rc::strong_count(&b));
    println!("b next item = {:?}", b.tail());

    if let Some(link) = a.tail() {
        *link.borrow_mut() = Rc::clone(&b);
    }

    println!("b rc count after changing a = {}", Rc::strong_count(&b));
    println!("a rc count after changing a = {}", Rc::strong_count(&a));

    // Uncomment the next line to see that we have a cycle;
    // it will overflow the stack.
    // println!("a next item = {:?}", a.tail());
}
```

範例 15-26：建立兩個 `List` 值相互指向的參考循環

我們建立一個 `Rc<List>` 實例，其中包含變數 `a` 中的 `List` 值，初始列表為 `5, Nil`。然後我們建立一個 `Rc<List>` 實例，其中包含變數 `b` 中的另一個 `List` 值，該值包含 `10` 並指向 `a` 中的列表。

我們修改 `a`，使其指向 `b` 而不是 `Nil`，從而建立一個循環。我們透過使用 `tail` 方法取得 `a` 中 `RefCell<Rc<List>>` 的參考來實現，我們將其放入變數 `link` 中。然後我們在 `RefCell<Rc<List>>` 上使用 `borrow_mut` 方法，將內部的值從一個持有 `Nil` 值的 `Rc<List>` 更改為 `b` 中的 `Rc<List>`。

當我們運行這段程式碼時（暫時將最後一個 `println!` 註解掉），我們將得到以下輸出：

```
$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.53s
     Running `target/debug/cons-list`
a initial rc count = 1
a next item = Some(RefCell { value: Nil })
a rc count after b creation = 2
b initial rc count = 1
b next item = Some(RefCell { value: Cons(5, RefCell { value: Nil }) })
b rc count after changing a = 2
a rc count after changing a = 2
```

在我們將 `a` 中的列表更改為指向 `b` 後，`a` 和 `b` 中 `Rc<List>` 實例的參考計數都是 2。在 `main` 的結尾，Rust 會 drop 變數 `b`，這會將 `b` `Rc<List>` 實例的參考計數從 2 減少到 1。此時 `Rc<List>` 在 heap 上的記憶體不會被 drop，因為它的參考計數是 1，而不是 0。然後 Rust 會 drop `a`，這也會將 `a` `Rc<List>` 實例的參考計數從 2 減少到 1。此實例的記憶體也無法被 drop，因為另一個 `Rc<List>` 實例仍然參考它。分配給列表的記憶體將永遠無法被回收。為了視覺化這個參考循環，我們建立了圖 15-4。

![A rectangle labeled 'a' that points to a rectangle containing the integer 5. A rectangle labeled 'b' that points to a rectangle containing the integer 10. The rectangle containing 5 points to the rectangle containing 10, and the rectangle containing 10 points back to the rectangle containing 5, creating a cycle](https://doc.rust-lang.org/book/img/trpl15-04.svg)

圖 15-4：列表 `a` 和 `b` 相互指向的參考循環

如果你取消註解最後一個 `println!` 並執行程式，Rust 將會嘗試印出這個循環，`a` 指向 `b`，`b` 指向 `a`，依此類推，直到 stack overflow。

與真實世界的程式相比，此範例中建立參考循環的後果並不嚴重：在我們建立參考循環後，程式立即結束。然而，如果一個更複雜的程式在循環中分配了大量記憶體並長時間持有它，那麼程式將使用比所需更多的記憶體，並可能使系統不堪重負，導致記憶體不足。

建立參考循環並不容易，但也並非不可能。如果你有包含 `Rc<T>` 值或其他類似的內部可變性和參考計數類型巢狀組合的 `RefCell<T>` 值，你必須確保不會建立循環；你不能依賴 Rust 來捕捉它們。建立參考循環將會是你程式中的一個邏輯錯誤，你應該使用自動測試、程式碼審查和其他軟體開發實踐來將其最小化。

避免參考循環的另一個解決方案是重組你的資料結構，讓某些參考表達 ownership，而某些參考不表達 ownership。因此，你可以建立由某些 ownership 關係和某些非 ownership 關係組成的循環，並且只有 ownership 關係會影響值是否可以被 drop。在範例 15-25 中，我們總是希望 `Cons` variant 擁有它們的列表，因此無法重組資料結構。讓我們看一個使用由父節點和子節點組成的圖形的範例，看看非 ownership 關係何時是防止參考循環的適當方式。

### 使用 Weak<T> 預防參考循環

到目前為止，我們已經證明呼叫 `Rc::clone` 會增加 `Rc<T>` 實例的 `strong_count`，並且 `Rc<T>` 實例只在其 `strong_count` 為 0 時才會被清理。你也可以透過呼叫 `Rc::downgrade` 並傳遞 `Rc<T>` 的參考，來建立對 `Rc<T>` 實例內部值的弱參考。*強參考*是你共享 `Rc<T>` 實例 ownership 的方式。*弱參考*不表達 ownership 關係，並且它們的計數不會影響 `Rc<T>` 實例何時被清理。它們不會造成參考循環，因為任何涉及某些弱參考的循環，一旦相關值的強參考計數為 0，就會被中斷。

當你呼叫 `Rc::downgrade` 時，你會得到一個 `Weak<T>` 類型的智慧型指標。呼叫 `Rc::downgrade` 不會將 `Rc<T>` 實例中的 `strong_count` 增加 1，而是會將 `weak_count` 增加 1。`Rc<T>` 類型使用 `weak_count` 來追蹤存在多少 `Weak<T>` 參考，類似於 `strong_count`。不同之處在於，`weak_count` 不需要為 0 才能清理 `Rc<T>` 實例。

因為 `Weak<T>` 所參考的值可能已經被 drop，所以要對 `Weak<T>` 指向的值進行任何操作，你必須確保該值仍然存在。這可以透過在 `Weak<T>` 實例上呼叫 `upgrade` 方法來實現，它將回傳一個 `Option<Rc<T>>`。如果 `Rc<T>` 值尚未被 drop，你將得到 `Some` 結果；如果 `Rc<T>` 值已被 drop，你將得到 `None` 結果。因為 `upgrade` 回傳 `Option<Rc<T>>`，Rust 將確保 `Some` 和 `None` 的情況都得到處理，並且不會有無效指標。

舉例來說，我們不會使用只知道下一個項目的列表，而是建立一個節點知道其子節點*以及*其父節點的樹。

#### 建立樹狀資料結構：帶有子節點的節點

首先，我們將建立一棵樹，其中的節點知道其子節點。我們將建立一個名為 `Node` 的 struct，它包含其自己的 `i32` 值以及其子 `Node` 值的參考：

Filename: src/main.rs

```rust
use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
struct Node {
    value: i32,
    children: RefCell<Vec<Rc<Node>>>,
}
```

我們希望一個 `Node` 擁有其子節點，並且我們希望與變數共享該 ownership，以便我們可以直接存取樹中的每個 `Node`。為此，我們將 `Vec<T>` 項目定義為 `Rc<Node>` 類型的值。我們也希望修改哪些節點是另一個節點的子節點，因此我們在 `children` 中有一個 `RefCell<T>`，圍繞著 `Vec<Rc<Node>>`。

接下來，我們將使用我們的 struct 定義，並建立一個名為 `leaf` 的 `Node` 實例，其值為 `3` 且沒有子節點，以及另一個名為 `branch` 的實例，其值為 `5`，並以 `leaf` 作為其子節點之一，如範例 15-27 所示。

src/main.rs

```rust
fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        children: RefCell::new(vec![]),
    });

    let branch = Rc::new(Node {
        value: 5,
        children: RefCell::new(vec![Rc::clone(&leaf)]),
    });
}
```

範例 15-27：建立一個沒有子節點的 `leaf` 節點和一個以 `leaf` 作為其子節點之一的 `branch` 節點

我們複製 `leaf` 中的 `Rc<Node>` 並將其儲存在 `branch` 中，這表示 `leaf` 中的 `Node` 現在有兩個 owner：`leaf` 和 `branch`。我們可以透過 `branch.children` 從 `branch` 轉到 `leaf`，但無法從 `leaf` 轉到 `branch`。原因是 `leaf` 沒有參考 `branch`，也不知道它們之間有關係。我們希望 `leaf` 知道 `branch` 是它的父節點。我們將在接下來進行。

#### 從子節點新增參考到其父節點

為了讓子節點知道它的父節點，我們需要在 `Node` struct 定義中新增一個 `parent` 欄位。問題在於決定 `parent` 的類型應該是什麼。我們知道它不能包含 `Rc<T>`，因為那樣會建立一個參考循環，其中 `leaf.parent` 指向 `branch`，而 `branch.children` 指向 `leaf`，這會導致它們的 `strong_count` 值永遠不會為 0。

從另一個角度思考這些關係，父節點應該擁有其子節點：如果父節點被 drop，其子節點也應該被 drop。然而，子節點不應該擁有其父節點：如果我們 drop 一個子節點，父節點應該仍然存在。這就是弱參考的情況！

因此，我們將使用 `Weak<T>` 作為 `parent` 的類型，而不是 `Rc<T>`，特別是 `RefCell<Weak<Node>>`。現在我們的 `Node` struct 定義如下：

Filename: src/main.rs

```rust
use std::cell::RefCell;
use std::rc::{Rc, Weak};

#[derive(Debug)]
struct Node {
    value: i32,
    parent: RefCell<Weak<Node>>,
    children: RefCell<Vec<Rc<Node>>>,
}
```

一個節點將能夠參考其父節點，但不會擁有其父節點。在範例 15-28 中，我們更新 `main` 以使用此新定義，這樣 `leaf` 節點將能夠參考其父節點 `branch`。

src/main.rs

```rust
fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());

    let branch = Rc::new(Node {
        value: 5,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![Rc::clone(&leaf)]),
    });

    *leaf.parent.borrow_mut() = Rc::downgrade(&branch);

    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());
}
```

範例 15-28：一個 `leaf` 節點，帶有指向其父節點 `branch` 的弱參考

建立 `leaf` 節點看起來與範例 15-27 類似，除了 `parent` 欄位：`leaf` 一開始沒有父節點，所以我們建立一個新的空 `Weak<Node>` 參考實例。

此時，當我們嘗試使用 `upgrade` 方法取得 `leaf` 父節點的參考時，我們得到一個 `None` 值。我們從第一個 `println!` 語句的輸出中看到這一點：

```
leaf parent = None
```

當我們建立 `branch` 節點時，它的 `parent` 欄位也會有一個新的 `Weak<Node>` 參考，因為 `branch` 沒有父節點。我們仍然將 `leaf` 作為 `branch` 的子節點之一。一旦我們在 `branch` 中擁有 `Node` 實例，我們就可以修改 `leaf`，給它一個指向其父節點的 `Weak<Node>` 參考。我們在 `leaf` 的 `parent` 欄位中的 `RefCell<Weak<Node>>` 上使用 `borrow_mut` 方法，然後我們使用 `Rc::downgrade` 函數從 `branch` 中的 `Rc<Node>` 建立一個指向 `branch` 的 `Weak<Node>` 參考。

當我們再次印出 `leaf` 的父節點時，這次我們會得到一個持有 `branch` 的 `Some` variant：現在 `leaf` 可以存取其父節點了！當我們印出 `leaf` 時，我們也避免了最終導致 stack overflow 的循環，就像範例 15-26 中那樣；`Weak<Node>` 參考會被印出為 `(Weak)`：

```
leaf parent = Some(Node { value: 5, parent: RefCell { value: (Weak) },
children: RefCell { value: [Node { value: 3, parent: RefCell { value: (Weak) },
children: RefCell { value: [] } }] } })
```

沒有無限輸出表明此程式碼未建立參考循環。我們也可以透過查看呼叫 `Rc::strong_count` 和 `Rc::weak_count` 得到的值來判斷這一點。

#### 視覺化 strong_count 和 weak_count 的變化

讓我們看看 `Rc<Node>` 實例的 `strong_count` 和 `weak_count` 值如何變化，透過建立一個新的內部作用域並將 `branch` 的建立移到該作用域中。這樣做，我們可以了解當 `branch` 被建立，然後當它超出作用域時被 drop 會發生什麼。這些修改如範例 15-29 所示。

src/main.rs

```rust
fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!(
        "leaf strong = {}, weak = {}",
        Rc::strong_count(&leaf),
        Rc::weak_count(&leaf),
    );

    {
        let branch = Rc::new(Node {
            value: 5,
            parent: RefCell::new(Weak::new()),
            children: RefCell::new(vec![Rc::clone(&leaf)]),
        });

        *leaf.parent.borrow_mut() = Rc::downgrade(&branch);

        println!(
            "branch strong = {}, weak = {}",
            Rc::strong_count(&branch),
            Rc::weak_count(&branch),
        );

        println!(
            "leaf strong = {}, weak = {}",
            Rc::strong_count(&leaf),
            Rc::weak_count(&leaf),
        );
    }

    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());
    println!(
        "leaf strong = {}, weak = {}",
        Rc::strong_count(&leaf),
        Rc::weak_count(&leaf),
    );
}
```

範例 15-29：在內部作用域中建立 `branch` 並檢查強弱參考計數

`leaf` 建立後，其 `Rc<Node>` 的強計數為 1，弱計數為 0。在內部作用域中，我們建立 `branch` 並將其與 `leaf` 關聯，此時當我們印出計數時，`branch` 中的 `Rc<Node>` 將具有強計數 1 和弱計數 1（因為 `leaf.parent` 使用 `Weak<Node>` 指向 `branch`）。當我們印出 `leaf` 中的計數時，我們將看到其強計數為 2，因為 `branch` 現在儲存了 `leaf` 的 `Rc<Node>` 的複製在 `branch.children` 中，但弱計數仍為 0。

當內部作用域結束時，`branch` 超出作用域，`Rc<Node>` 的強計數減為 0，因此其 `Node` 被 drop。`leaf.parent` 的弱計數 1 對於 `Node` 是否被 drop 沒有影響，所以我們沒有任何記憶體洩漏！

如果我們在作用域結束後嘗試存取 `leaf` 的父節點，我們會再次得到 `None`。在程式結束時，`leaf` 中的 `Rc<Node>` 的強計數為 1，弱計數為 0，因為變數 `leaf` 現在是 `Rc<Node>` 的唯一參考。

所有管理計數和值 drop 的邏輯都內建於 `Rc<T>` 和 `Weak<T>` 及其 `Drop` trait 的實作中。透過在 `Node` 的定義中指定從子節點到其父節點的關係應該是 `Weak<T>` 參考，你就能夠讓父節點指向子節點，反之亦然，而不會建立參考循環和記憶體洩漏。

## 總結

本章涵蓋了如何使用智慧型指標來提供與 Rust 預設使用一般參考所提供的不同的保證和權衡。`Box<T>` 類型具有已知大小並指向在 heap 上分配的資料。`Rc<T>` 類型追蹤 heap 上資料的參考數量，以便該資料可以有多個 owner。`RefCell<T>` 類型及其內部可變性為我們提供了一種類型，當我們需要一個不可變類型但需要更改該類型的內部值時，我們可以使用它；它還在 runtime 而非 compile time 強制執行 borrowing 規則。

本章也討論了 `Deref` 和 `Drop` trait，它們實現了智慧型指標的許多功能。我們探索了可能導致記憶體洩漏的參考循環，以及如何使用 `Weak<T>` 預防它們。

如果本章引起了你的興趣，並且你想要實作你自己的智慧型指標，請查看《The Rustonomicon》位於 _https://doc.rust-lang.org/book/nomicon/index.html_ 以獲取更多有用的資訊。

接下來，我們將討論 Rust 中的並行性。你甚至會學到一些新的智慧型指標。
