<!-- DO NOT EDIT THIS FILE.

This file is periodically generated from the content in the `/src/`
directory, so all fixes need to be made in `/src/`.
-->

[TOC]

# 進階功能

到目前為止，你已經學會了 Rust 程式語言最常用的部分。在我們進行第 21 章的最後一個專案之前，我們將探討一些你可能偶爾會遇到、但並非每天都會使用的語言面向。你可以將本章作為參考，以便在你遇到任何未知事物時查閱。這裡介紹的功能在非常特定的情況下很有用。雖然你可能不會經常使用它們，但我們希望確保你對 Rust 提供的所有功能都有所掌握。

在本章中，我們將涵蓋：

- Unsafe Rust：如何選擇退出 Rust 的某些保證，並承擔手動維護這些保證的責任
- 進階 trait：關聯型別、預設型別參數、完全限定語法、supertrait，以及與 trait 相關的 newtype 模式
- 進階型別：更多關於 newtype 模式、型別別名、never 型別和動態大小型別的內容
- 進階函式與閉包：函式指標與回傳閉包
- Macro：在編譯時期定義程式碼來產生更多程式碼的方法

這是一系列豐富的 Rust 功能，總有適合你的！讓我們深入探討吧！

## Unsafe Rust

到目前為止我們討論過的所有程式碼，都在編譯時期強制執行了 Rust 的記憶體安全保證。然而，Rust 內部隱藏了第二種語言，它不強制執行這些記憶體安全保證：它被稱為 _unsafe Rust_，其運作方式與一般的 Rust 完全相同，但給了我們額外的超能力。

Unsafe Rust 之所以存在，是因為靜態分析本質上是保守的。當編譯器試圖判斷程式碼是否遵守保證時，拒絕一些有效的程式，總比接受一些無效的程式要好。雖然程式碼*可能*是正確的，但如果 Rust 編譯器沒有足夠的資訊來確信這一點，它就會拒絕該程式碼。在這些情況下，你可以使用 unsafe 程式碼告訴編譯器：「相信我，我知道我在做什麼。」不過要小心，使用 unsafe Rust 的風險自負：如果你不正確地使用 unsafe 程式碼，可能會因為記憶體不安全而發生問題，例如 null 指標的 dereferencing。

Rust 擁有 unsafe 這個另一面的另一個原因是，底層的電腦硬體本質上就是不安全的。如果 Rust 不讓你進行 unsafe 的操作，你就無法完成某些任務。Rust 需要讓你能夠進行低階系統程式設計，例如直接與作業系統互動，甚至撰寫你自己的作業系統。處理低階系統程式設計是這門語言的目標之一。讓我們來探索一下我們能用 unsafe Rust 做些什麼，以及如何去做。

### Unsafe 的超能力

要切換到 unsafe Rust，請使用 `unsafe` 關鍵字，然後開始一個新的區塊來存放 unsafe 程式碼。在 unsafe Rust 中，你可以執行五種在安全 Rust 中無法執行的操作，我們稱之為_unsafe 超能力_。這些超能力包括：

1. Dereference 一個 raw pointer
2. 呼叫一個 unsafe 的函式或方法
3. 存取或修改一個可變的 static 變數
4. 實作一個 unsafe trait
5. 存取 `union` 的欄位

很重要的一點是，`unsafe` 並不會關閉 borrow checker 或停用 Rust 的任何其他安全檢查：如果你在 unsafe 程式碼中使用一個 reference，它仍然會被檢查。`unsafe` 關鍵字只讓你能夠存取這五個功能，而編譯器不會對這些功能進行記憶體安全檢查。你在 unsafe 區塊內仍然能獲得一定程度的安全性。

此外，`unsafe` 並不意味著區塊內的程式碼必然危險，或者一定會有記憶體安全問題：其意圖是，作為程式設計師，你將確保 `unsafe` 區塊內的程式碼會以有效的方式存取記憶體。

人是會犯錯的，錯誤總會發生，但透過要求這五種 unsafe 操作必須放在以 `unsafe` 標註的區塊內，你就會知道任何與記憶體安全相關的錯誤都必定在 `unsafe` 區塊內。保持 `unsafe` 區塊盡可能小；當你日後調查記憶體 bug 時，你會感謝自己的。

為了盡可能隔離 unsafe 程式碼，最好將這些程式碼封裝在一個安全的抽象層中，並提供一個安全的 API，我們將在本章稍後討論 unsafe 函式和方法時探討這一點。標準函式庫的一部分是作為經過審核的 unsafe 程式碼的安全抽象來實作的。將 unsafe 程式碼包裝在安全的抽象中，可以防止 `unsafe` 的使用洩漏到你或你的使用者可能想要使用以 `unsafe` 程式碼實現的功能的所有地方，因為使用安全的抽象是安全的。

讓我們依序看看這五種 unsafe 超能力。我們也會看一些為 unsafe 程式碼提供安全介面的抽象。

### Dereferencing 一個 Raw Pointer

在第四章的「懸置參照」中，我們提到編譯器會確保 reference 永遠有效。Unsafe Rust 有兩種新的型別，稱為 _raw pointers_，與 reference 類似。如同 reference，raw pointers 可以是不可變或可變的，分別寫作 `*const T` 和 `*mut T`。星號不是 dereference 運算子；它是型別名稱的一部分。在 raw pointers 的情境下，_immutable_ 意指指標在被 dereference 後不能直接被賦值。

與 reference 和 smart pointers 不同，raw pointers：

- 允許忽略 borrowing 規則，可以同時擁有指向同一位置的不可變和可變指標，或多個可變指標
- 不保證指向有效的記憶體
- 允許為 null
- 不實作任何自動清理

透過選擇退出讓 Rust 強制執行這些保證，你可以放棄保證的安全性，以換取更高的效能，或能夠與 Rust 的保證不適用的另一種語言或硬體介接。

範例 20-1 展示了如何建立一個不可變和一個可變的 raw pointer。

```rust
    let mut num = 5;

    let r1 = &raw const num;
    let r2 = &raw mut num;
```

範例 20-1：使用 raw borrow 運算子建立 raw pointers

請注意，我們在這段程式碼中沒有包含 `unsafe` 關鍵字。我們可以在安全的程式碼中建立 raw pointers；只是我們不能在 `unsafe` 區塊之外 dereference raw pointers，你稍後會看到。

我們使用 raw borrow 運算子建立了 raw pointers：`&raw const num` 建立了一個 `*const i32` 的不可變 raw pointer，而 `&raw mut num` 則建立了一個 `*mut i32` 的可變 raw pointer。因為我們是直接從一個區域變數建立它們，所以我們知道這些特定的 raw pointers 是有效的，但我們不能對任何 raw pointer 都做這樣的假設。

為了證明這一點，接下來我們將建立一個我們無法那麼確定其有效性的 raw pointer，使用 `as` 關鍵字來轉換一個值，而不是使用 raw borrow 運算子。範例 20-2 展示了如何建立一個指向記憶體中任意位置的 raw pointer。嘗試使用任意記憶體是未定義的行為：該位址可能有資料，也可能沒有，編譯器可能會優化程式碼，使其沒有記憶體存取，或者程式可能會因分段錯誤而終止。通常，沒有好的理由這樣寫程式碼，尤其是在可以使用 raw borrow 運算子的情況下，但這是可能的。

```rust
let address = 0x012345usize;
let r = address as *const i32;
```

範例 20-2：建立一個指向任意記憶體位址的 raw pointer

回想一下，我們可以在安全程式碼中建立 raw pointers，但我們不能_dereference_ raw pointers 並讀取所指向的資料。在範例 20-3 中，我們在一個 raw pointer 上使用 dereference 運算子 `*`，這需要一個 `unsafe` 區塊。

```rust
    let mut num = 5;

    let r1 = &raw const num;
    let r2 = &raw mut num;

    unsafe {
        println!("r1 is: {}", *r1);
        println!("r2 is: {}", *r2);
    }
```

範例 20-3：在 `unsafe` 區塊內 dereference raw pointers

建立一個指標本身沒有害處；只有當我們試圖存取它所指向的值時，才可能處理到無效的值。

另外請注意，在範例 20-1 和 20-3 中，我們建立了 `*const i32` 和 `*mut i32` 兩個 raw pointers，它們都指向同一個記憶體位置，也就是 `num` 的儲存位置。如果我們試圖建立一個 `num` 的不可變 reference 和一個可變 reference，程式碼將無法編譯，因為 Rust 的 ownership 規則不允許在有任何不可變 reference 的同時存在一個可變 reference。使用 raw pointers，我們可以建立一個指向同一位置的可變指標和一個不可變指標，並透過可變指標改變資料，這可能會造成 data race。要小心！

既然有這麼多危險，你為什麼會想用 raw pointers 呢？一個主要的應用場景是與 C 程式碼介接時，你將在下一節看到。另一個情況是當你建立 borrow checker 無法理解的安全抽象時。我們將介紹 unsafe 函式，然後看一個使用 unsafe 程式碼的安全抽象的例子。

### 呼叫 Unsafe 函式或方法

你可以在 unsafe 區塊中執行的第二種操作是呼叫 unsafe 函式。Unsafe 函式和方法看起來與一般函式和方法完全一樣，只是在定義的其他部分之前多了一個 `unsafe`。在這個情境中，`unsafe` 關鍵字表示該函式有一些我們在呼叫它時需要遵守的要求，因為 Rust 無法保證我們已經滿足了這些要求。透過在 `unsafe` 區塊內呼叫一個 unsafe 函式，我們是在表示我們已經閱讀了這個函式的說明文件，並且我們為遵守該函式的契約負責。

這是一個名為 `dangerous` 的 unsafe 函式，它在函式主體中什麼也沒做：

```rust
    unsafe fn dangerous() {}

    unsafe {
        dangerous();
    }
```

我們必須在一個獨立的 `unsafe` 區塊內呼叫 `dangerous` 函式。如果我們試圖在沒有 `unsafe` 區塊的情況下呼叫 `dangerous`，我們會得到一個錯誤：

```text
$ cargo run
   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)
error[E0133]: call to unsafe function `dangerous` is unsafe and requires unsafe block
 --> src/main.rs:4:5
  |
4 |     dangerous();
  |     ^^^^^^^^^^^ call to unsafe function
  |
  = note: consult the function's documentation for information on how to avoid undefined behavior

For more information about this error, try `rustc --explain E0133`.
error: could not compile `unsafe-example` (bin "unsafe-example") due to 1 previous error
```

透過 `unsafe` 區塊，我們向 Rust 斷言我們已經閱讀了函式的說明文件，我們理解如何正確使用它，並且我們已經驗證我們正在履行函式的契約。

要在 `unsafe` 函式的主體中執行 unsafe 操作，你仍然需要使用 `unsafe` 區塊，就像在一般函式中一樣，如果你忘了，編譯器會警告你。這有助於我們將 `unsafe` 區塊保持得盡可能小，因為 unsafe 操作可能並非在整個函式主體中都需要。

#### 為 Unsafe 程式碼建立安全的抽象

僅僅因為一個函式包含 unsafe 程式碼，並不意味著我們需要將整個函式標記為 unsafe。事實上，將 unsafe 程式碼包裝在一個安全的函式中是一種常見的抽象。舉例來說，讓我們研究一下標準函式庫中的 `split_at_mut` 函式，它需要一些 unsafe 程式碼。我們將探討如何實現它。這個安全的方法定義在可變的 slice 上：它接收一個 slice，並透過在給定索引處分割 slice，將其變成兩個。範例 20-4 展示了如何使用 `split_at_mut`。

```rust
    let mut v = vec![1, 2, 3, 4, 5, 6];

    let r = &mut v[..];

    let (a, b) = r.split_at_mut(3);

    assert_eq!(a, &mut [1, 2, 3]);
    assert_eq!(b, &mut [4, 5, 6]);
```

範例 20-4：使用安全的 `split_at_mut` 函式

我們無法僅用安全的 Rust 來實現這個函式。一個可能的嘗試如範例 20-5 所示，但它無法編譯。為簡單起見，我們將 `split_at_mut` 實作為一個函式而非方法，並且只適用於 `i32` 值的 slice，而不是泛型 `T`。

```rust
fn split_at_mut(values: &mut [i32], mid: usize) -> (&mut [i32], &mut [i32]) {
    let len = values.len();

    assert!(mid <= len);

    (&mut values[..mid], &mut values[mid..])
}
```

範例 20-5：一個僅使用安全 Rust 的 `split_at_mut` 嘗試實作

這個函式首先取得 slice 的總長度。然後它斷言作為參數給定的索引在 slice 的範圍內，方法是檢查它是否小於或等於長度。這個斷言意味著，如果我們傳遞一個大於長度的索引來分割 slice，函式會在嘗試使用該索引之前 panic。

然後我們在一個 tuple 中回傳兩個可變的 slice：一個從原始 slice 的開頭到 `mid` 索引，另一個從 `mid` 到 slice 的結尾。

當我們嘗試編譯範例 20-5 中的程式碼時，會得到一個錯誤：

```text
$ cargo run
   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)
error[E0499]: cannot borrow `*values` as mutable more than once at a time
 --> src/main.rs:6:31
  |
1 | fn split_at_mut(values: &mut [i32], mid: usize) -> (&mut [i32], &mut [i32]) {
  |                         - let's call the lifetime of this reference `'1`
...
6 |     (&mut values[..mid], &mut values[mid..])
  |     --------------------------^^^^^^--------
  |     |     |                   |
  |     |     |                   second mutable borrow occurs here
  |     |     first mutable borrow occurs here
  |     returning this value requires that `*values` is borrowed for `'1`
  |
  = help: use `.split_at_mut(position)` to obtain two mutable non-overlapping sub-slices

For more information about this error, try `rustc --explain E0499`.
error: could not compile `unsafe-example` (bin "unsafe-example") due to 1 previous error
```

Rust 的 borrow checker 無法理解我們正在借用 slice 的不同部分；它只知道我們從同一個 slice 借用了兩次。借用 slice 的不同部分基本上是沒問題的，因為這兩個 slice 沒有重疊，但 Rust 不夠聰明，無法知道這一點。當我們知道程式碼是正確的，但 Rust 不知道時，就是時候使用 unsafe 程式碼了。

範例 20-6 展示了如何使用 `unsafe` 區塊、一個 raw pointer，以及一些對 unsafe 函式的呼叫，來讓 `split_at_mut` 的實作能夠運作。

```rust
use std::slice;

fn split_at_mut(values: &mut [i32], mid: usize) -> (&mut [i32], &mut [i32]) {
    let len = values.len();
    let ptr = values.as_mut_ptr();

    assert!(mid <= len);

    unsafe {
        (
            slice::from_raw_parts_mut(ptr, mid),
            slice::from_raw_parts_mut(ptr.add(mid), len - mid),
        )
    }
}
```

範例 20-6：在 `split_at_mut` 函式的實作中使用 unsafe 程式碼

回想第四章的「Slice 型別」，一個 slice 是一個指向某些資料的指標以及 slice 的長度。我們使用 `len` 方法來取得 slice 的長度，並使用 `as_mut_ptr` 方法來存取 slice 的 raw pointer。在這種情況下，因為我們有一個指向 `i32` 值的可變 slice，`as_mut_ptr` 會回傳一個型別為 `*mut i32` 的 raw pointer，我們將它儲存在 `ptr` 變數中。

我們保留了 `mid` 索引在 slice 範圍內的斷言。然後我們進入 unsafe 程式碼：`slice::from_raw_parts_mut` 函式接受一個 raw pointer 和一個長度，並建立一個 slice。我們用這個函式來建立一個從 `ptr` 開始，長度為 `mid` 的 slice。然後我們在 `ptr` 上呼叫 `add` 方法，以 `mid` 作為參數，得到一個從 `mid` 開始的 raw pointer，並使用那個指標以及 `mid` 之後剩餘的項目數量作為長度來建立一個 slice。

函式 `slice::from_raw_parts_mut` 是 unsafe 的，因為它接受一個 raw pointer，並且必須相信這個指標是有效的。raw pointer 上的 `add` 方法也是 unsafe 的，因為它必須相信偏移後的位置也是一個有效的指標。因此，我們必須在呼叫 `slice::from_raw_parts_mut` 和 `add` 的地方加上 `unsafe` 區塊，才能呼叫它們。透過檢視程式碼並加入 `mid` 必須小於或等於 `len` 的斷言，我們可以判斷 `unsafe` 區塊內使用的所有 raw pointers 都會是有效的指標，指向 slice 內的資料。這是一個可接受且適當的 `unsafe` 用法。

請注意，我們不需要將產生的 `split_at_mut` 函式標記為 `unsafe`，我們可以從安全的 Rust 程式碼中呼叫這個函式。我們為 unsafe 程式碼建立了一個安全的抽象，其函式實作以一種安全的方式使用了 `unsafe` 程式碼，因為它只從這個函式有權存取的資料中建立有效的指標。

相比之下，範例 20-7 中 `slice::from_raw_parts_mut` 的用法在 slice 被使用時很可能會崩潰。這段程式碼取一個任意的記憶體位置，並建立一個長度為 10,000 的 slice。

```rust
    use std::slice;

    let address = 0x01234usize;
    let r = address as *mut i32;

    let values: &[i32] = unsafe { slice::from_raw_parts_mut(r, 10000) };
```

範例 20-7：從任意記憶體位置建立一個 slice

我們並不擁有這個任意位置的記憶體，也無法保證這段程式碼建立的 slice 包含有效的 `i32` 值。試圖將 `values` 當作一個有效的 slice 來使用會導致未定義的行為。

#### 使用 extern 函式呼叫外部程式碼

有時候你的 Rust 程式碼可能需要與用其他語言撰寫的程式碼互動。為此，Rust 有一個 `extern` 關鍵字，它有助於建立和使用_外部函式介面 (Foreign Function Interface, FFI)_，這是一種讓程式語言定義函式，並讓另一種（外部）程式語言能夠呼叫這些函式的方式。

範例 20-8 展示了如何設定與 C 標準函式庫中的 `abs` 函式的整合。在 `extern` 區塊內宣告的函式，從 Rust 程式碼中呼叫通常是 unsafe 的，所以 `extern` 區塊也必須標記為 `unsafe`。原因在於其他語言不強制執行 Rust 的規則和保證，而 Rust 無法檢查它們，所以確保安全的責任就落在程式設計師身上。

src/main.rs

```rust
unsafe extern "C" {
    fn abs(input: i32) -> i32;
}

fn main() {
    unsafe {
        println!("Absolute value of -3 according to C: {}", abs(-3));
    }
}
```

範例 20-8：宣告並呼叫一個在其他語言中定義的 `extern` 函式

在 `unsafe extern "C"` 區塊內，我們列出了我們想要呼叫的其他語言的外部函式的名稱和簽名。`"C"` 部分定義了外部函式使用哪種_應用程式二進位介面 (application binary interface, ABI)_：ABI 定義了如何在組譯層級呼叫函式。`"C"` ABI 是最常見的，並遵循 C 程式語言的 ABI。關於 Rust 支援的所有 ABI 的資訊，可以在 Rust 參考手冊的 _https://doc.rust-lang.org/book/../reference/items/external-blocks.html#abi_ 中找到。

在 `unsafe extern` 區塊內宣告的每個項目都是隱含的 unsafe。然而，有些 FFI 函式是安全的。例如，C 標準函式庫的 `abs` 函式沒有任何記憶體安全考量，我們知道它可以被任何 `i32` 呼叫。在這種情況下，我們可以使用 `safe` 關鍵字來說明這個特定的函式是安全的，即使它在一個 `unsafe extern` 區塊內。一旦我們做了這個改變，呼叫它就不再需要一個 `unsafe` 區塊，如範例 20-9 所示。

src/main.rs

```rust
unsafe extern "C" {
    safe fn abs(input: i32) -> i32;
}

fn main() {
    println!("Absolute value of -3 according to C: {}", abs(-3));
}
```

範例 20-9：在 `unsafe extern` 區塊內明確將函式標記為 `safe` 並安全地呼叫它

將函式標記為 `safe` 並不會使其本質上變得安全！相反地，這就像你向 Rust 做的一個承諾，保證它是安全的。你仍然有責任確保這個承諾被遵守！

#### 從其他語言呼叫 Rust 函式

我們也可以使用 `extern` 來建立一個介面，讓其他語言能夠呼叫 Rust 函式。我們不是建立一個完整的 `extern` 區塊，而是在相關函式的 `fn` 關鍵字前加上 `extern` 關鍵字並指定要使用的 ABI。我們還需要加上 `#[unsafe(no_mangle)]` 註解，告訴 Rust 編譯器不要對這個函式的名稱進行 name mangling。_Mangling_ 是指編譯器將我們給函式的名稱改成一個不同的名稱，這個新名稱包含更多資訊供編譯過程的其他部分使用，但對人類來說較不具可讀性。每種程式語言的編譯器對名稱的 mangling 方式都略有不同，所以為了讓一個 Rust 函式能被其他語言命名，我們必須停用 Rust 編譯器的名稱 mangling。這是不安全的，因為沒有內建的 mangling，函式庫之間可能會有名稱衝突，所以我們有責任確保我們選擇的名稱在沒有 mangling 的情況下匯出是安全的。

在下面的範例中，我們讓 `call_from_c` 函式可以從 C 程式碼中存取，在它被編譯成共享函式庫並從 C 連結之後：

```rust
#[unsafe(no_mangle)]
pub extern "C" fn call_from_c() {
    println!("Just called a Rust function from C!");
}
```

這種 `extern` 的用法只需要在屬性中使用 `unsafe`，而不需要在 `extern` 區塊中使用。

### 存取或修改一個可變的 Static 變數

在本書中，我們還沒有談過全域變數，Rust 確實支援它，但它可能與 Rust 的 ownership 規則產生問題。如果兩個 thread 正在存取同一個可變的全域變數，可能會導致 data race。

在 Rust 中，全域變數被稱為 _static_ 變數。範例 20-10 展示了一個以 string slice 為值的 static 變數的宣告和使用範例。

src/main.rs

```rust
static HELLO_WORLD: &str = "Hello, world!";

fn main() {
    println!("value is: {HELLO_WORLD}");
}
```

範例 20-10：定義和使用一個不可變的 static 變數

Static 變數與我們在第三章「常數」中討論過的常數相似。按照慣例，static 變數的名稱使用 `SCREAMING_SNAKE_CASE`。Static 變數只能儲存具有 `'static` lifetime 的 reference，這意味著 Rust 編譯器可以推斷出 lifetime，我們不需要明確地標註它。存取一個不可變的 static 變數是安全的。

常數和不可變 static 變數之間的一個細微差別是，static 變數中的值在記憶體中有一個固定的位址。使用該值將始終存取相同的資料。另一方面，常數則允許在每次使用時複製其資料。另一個區別是 static 變數可以是可變的。存取和修改可變的 static 變數是*unsafe*的。範例 20-11 展示了如何宣告、存取和修改一個名為 `COUNTER` 的可變 static 變數。

src/main.rs

```rust
static mut COUNTER: u32 = 0;

/// SAFETY: Calling this from more than a single thread at a time is undefined
/// behavior, so you *must* guarantee you only call it from a single thread at
/// a time.
unsafe fn add_to_count(inc: u32) {
    unsafe {
        COUNTER += inc;
    }
}

fn main() {
    unsafe {
        // SAFETY: This is only called from a single thread in `main`.
        add_to_count(3);
        println!("COUNTER: {}", *(&raw const COUNTER));
    }
}
```

範例 20-11：讀取或寫入一個可變的 static 變數是 unsafe 的

和一般變數一樣，我們使用 `mut` 關鍵字來指定可變性。任何讀取或寫入 `COUNTER` 的程式碼都必須在 `unsafe` 區塊內。範例 20-11 的程式碼可以編譯並印出 `COUNTER: 3`，如同我們所預期的，因為它是單一 thread。讓多個 thread 存取 `COUNTER` 很可能會導致 data races，所以這是未定義的行為。因此，我們需要將整個函式標記為 `unsafe` 並記錄安全限制，這樣任何呼叫該函式的人都知道他們可以安全地做什麼和不能做什麼。

每當我們撰寫一個 unsafe 函式時，慣例是寫一個以 `SAFETY` 開頭的註解，解釋呼叫者需要做什麼才能安全地呼叫該函式。同樣地，每當我們執行一個 unsafe 操作時，慣例是寫一個以 `SAFETY` 開頭的註解，解釋安全規則是如何被遵守的。

此外，編譯器預設會透過一個 compiler lint 來拒絕任何試圖建立可變 static 變數 reference 的行為。你必須透過新增 `#[allow(static_mut_refs)]` 註解來明確選擇退出該 lint 的保護，或者透過使用其中一個 raw borrow 運算子建立的 raw pointer 來存取可變 static 變數。這包括 reference 是隱形建立的情況，例如在這段程式碼列表中的 `println!` 中使用時。要求對 static 可變變數的 reference 必須透過 raw pointer 建立，有助於讓使用它們的安全要求更加明顯。

對於全域可存取的可變資料，很難確保沒有 data races，這就是為什麼 Rust 認為可變 static 變數是 unsafe 的。在可能的情況下，最好使用我們在第 16 章中討論的並行技術和 thread-safe 的 smart pointers，這樣編譯器就能檢查來自不同 thread 的資料存取是否安全地進行。

### 實作一個 Unsafe Trait

我們可以使用 `unsafe` 來實作一個 unsafe trait。當一個 trait 的至少一個方法有某些編譯器無法驗證的不變性 (invariant) 時，該 trait 就是 unsafe 的。我們透過在 `trait` 之前加上 `unsafe` 關鍵字來宣告一個 trait 是 `unsafe`，並將該 trait 的實作也標記為 `unsafe`，如範例 20-12 所示。

```rust
unsafe trait Foo {
    // methods go here
}

unsafe impl Foo for i32 {
    // method implementations go here
}
```

範例 20-12：定義並實作一個 unsafe trait

透過使用 `unsafe impl`，我們承諾我們會遵守編譯器無法驗證的不變性。

舉例來說，回想一下我們在第 16 章「透過 `Send` 和 `Sync` Traits 擴展並行性」中討論的 `Send` 和 `Sync` marker traits：如果我們的型別完全由其他實作了 `Send` 和 `Sync` 的型別組成，編譯器會自動為我們實作這些 traits。如果我們實作了一個包含未實作 `Send` 或 `Sync` 的型別（例如 raw pointers），並且我們想要將該型別標記為 `Send` 或 `Sync`，我們就必須使用 `unsafe`。Rust 無法驗證我們的型別是否遵守了可以安全地在 thread 間傳遞或從多個 thread 存取的保證；因此，我們需要手動進行這些檢查，並用 `unsafe` 來表示。

### 存取 Union 的欄位

最後一個只能用 `unsafe` 執行的操作是存取 union 的欄位。_union_ 類似於 `struct`，但在一個特定實例中一次只使用一個宣告的欄位。Union 主要用於與 C 程式碼中的 union 介接。存取 union 欄位是 unsafe 的，因為 Rust 無法保證目前儲存在 union 實例中的資料型別。你可以在 Rust 參考手冊的 _https://doc.rust-lang.org/book/../reference/items/unions.html_ 中學習更多關於 union 的知識。

### 使用 Miri 檢查 Unsafe 程式碼

在撰寫 unsafe 程式碼時，你可能會想檢查你所寫的是否真的安全和正確。最好的方法之一是使用 Miri，這是一個官方的 Rust 工具，用於偵測未定義的行為。Borrow checker 是一個在編譯時期運作的*靜態*工具，而 Miri 是一個在執行時期運作的*動態*工具。它透過執行你的程式或其測試套件來檢查你的程式碼，並在你的程式碼違反它所理解的 Rust 運作規則時進行偵測。

使用 Miri 需要 nightly build 的 Rust（我們在附錄 G：Rust 如何製作和「Nightly Rust」中有更多討論）。你可以透過輸入 `rustup +nightly component add miri` 來安裝 nightly 版本的 Rust 和 Miri 工具。這不會改變你的專案使用的 Rust 版本；它只是將該工具新增到你的系統中，以便你在需要時使用。你可以透過輸入 `cargo +nightly miri run` 或 `cargo +nightly miri test` 來在專案上執行 Miri。

為了說明這有多大幫助，讓我們看看當我們對範例 20-7 執行它時會發生什麼。

```text
$ cargo +nightly miri run
   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.01s
     Running `file:///home/.rustup/toolchains/nightly-aarch64-apple-darwin/bin/cargo-miri runner target/miri/aarch64-apple-darwin/debug/unsafe-example`
warning: integer-to-pointer cast
 --> src/main.rs:6:13
  |
6 |     let r = address as *mut i32;
  |             ^^^^^^^^^^^^^^^^^^^ integer-to-pointer cast
  |
  = help: this program is using integer-to-pointer casts or (equivalently) `ptr::with_exposed_provenance`, which means that Miri might miss pointer bugs in this program
  = help: see https://doc.rust-lang.org/nightly/std/ptr/fn.with_exposed_provenance.html for more details on that operation
  = help: to ensure that Miri does not miss bugs in your program, use Strict Provenance APIs (https://doc.rust-lang.org/nightly/std/ptr/index.html#strict-provenance, https://crates.io/crates/sptr) instead
  = help: you can then set `MIRIFLAGS=-Zmiri-strict-provenance` to ensure you are not relying on `with_exposed_provenance` semantics
  = help: alternatively, `MIRIFLAGS=-Zmiri-permissive-provenance` disables this warning
  = note: BACKTRACE:
  = note: inside `main` at src/main.rs:6:13: 6:32

error: Undefined Behavior: pointer not dereferenceable: pointer must be dereferenceable for 40000 bytes, but got 0x1234[noalloc] which is a dangling pointer (it has no provenance)
 --> src/main.rs:8:35
  |
8 |     let values: &[i32] = unsafe { slice::from_raw_parts_mut(r, 10000) };
  |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Undefined Behavior occurred here
  |
  = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior
  = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information
  = note: BACKTRACE:
  = note: inside `main` at src/main.rs:8:35: 8:70

note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace

error: aborting due to 1 previous error; 1 warning emitted
```

Miri 正確地警告我們，我們正在將一個整數轉換為一個指標，這可能是一個問題，但 Miri 無法偵測到是否有問題，因為它不知道這個指標是如何產生的。然後，Miri 在範例 20-7 有未定義行為的地方回傳一個錯誤，因為我們有一個懸置指標。多虧了 Miri，我們現在知道有未定義行為的風險，我們可以思考如何讓程式碼變得安全。在某些情況下，Miri 甚至可以提供關於如何修復錯誤的建議。

Miri 並不能捕捉到你在撰寫 unsafe 程式碼時可能犯的所有錯誤。Miri 是一個動態分析工具，所以它只捕捉實際運行的程式碼中的問題。這意味著你需要將它與良好的測試技術結合使用，以增加你對所寫的 unsafe 程式碼的信心。Miri 也沒有涵蓋所有可能導致你的程式碼不健全的方式。

換句話說：如果 Miri *確實*捕捉到問題，你就知道有 bug，但僅僅因為 Miri *沒有*捕捉到 bug，並不意味著沒有問題。不過它能捕捉到很多問題。試著在本章的其他 unsafe 程式碼範例上運行它，看看它會說什麼！

你可以在 Miri 的 GitHub 儲存庫 _https://github.com/rust-lang/miri_ 了解更多關於 Miri 的資訊。

### 何時使用 Unsafe 程式碼

使用 `unsafe` 來執行前面討論的五種超能力之一並不是錯誤的，甚至不會被人詬病，但要寫出正確的 `unsafe` 程式碼更為棘手，因為編譯器無法幫助維護記憶體安全。當你有理由使用 `unsafe` 程式碼時，你可以這麼做，而明確的 `unsafe` 註解使得在問題發生時更容易追蹤問題的來源。每當你撰寫 unsafe 程式碼時，你可以使用 Miri 來幫助你更有信心地確認你所寫的程式碼遵守了 Rust 的規則。

要更深入地探討如何有效地使用 unsafe Rust，請閱讀 Rust 的官方指南《Rustonomicon》，網址為 _https://doc.rust-lang.org/nomicon/_。

## 進階 Trait

我們在第 10 章的「Trait：定義共享行為」中首次介紹了 trait，但我們沒有討論更進階的細節。現在你對 Rust 有了更多的了解，我們可以深入探討這些細節。

<!-- Old link, do not remove -->

<a id="specifying-placeholder-types-in-trait-definitions-with-associated-types"></a>

### 關聯型別

_關聯型別 (Associated types)_ 將一個型別佔位符與一個 trait 連接起來，使得 trait 方法的定義可以在其簽名中使用這些佔位符型別。Trait 的實作者將為特定的實作指定要使用的具體型別來取代佔位符型別。這樣，我們就可以定義一個使用某些型別的 trait，而不需要在 trait 被實作之前確切知道這些型別是什麼。

我們已經將本章中大部分的進階功能描述為很少需要。關聯型別介於兩者之間：它們的使用頻率比書中其他部分解釋的功能要少，但比本章討論的許多其他功能要常見。

一個帶有關聯型別的 trait 的例子是標準函式庫提供的 `Iterator` trait。關聯型別名為 `Item`，代表實作 `Iterator` trait 的型別所迭代的值的型別。`Iterator` trait 的定義如範例 20-13 所示。

```rust
pub trait Iterator {
    type Item;

    fn next(&mut self) -> Option<Self::Item>;
}
```

範例 20-13：帶有關聯型別 `Item` 的 `Iterator` trait 的定義

型別 `Item` 是一個佔位符，`next` 方法的定義顯示它將回傳 `Option<Self::Item>` 型別的值。`Iterator` trait 的實作者將為 `Item` 指定具體的型別，而 `next` 方法將回傳一個包含該具體型別值的 `Option`。

關聯型別看起來可能與泛型（generics）的概念相似，因為後者允許我們定義一個函式而無需指定它可以處理哪些型別。為了檢視這兩個概念之間的差異，我們將看一個在名為 `Counter` 的型別上實作 `Iterator` trait 的例子，該實作指定 `Item` 型別為 `u32`：

src/lib.rs

```rust
impl Iterator for Counter {
    type Item = u32;

    fn next(&mut self) -> Option<Self::Item> {
        // --snip--
```

這個語法看起來與泛型的語法相當。那麼為什麼不直接用泛型來定義 `Iterator` trait，如範例 20-14 所示呢？

```rust
pub trait Iterator<T> {
    fn next(&mut self) -> Option<T>;
}
```

範例 20-14：一個使用泛型來定義 `Iterator` trait 的假設性定義

差別在於，當使用泛型時，如範例 20-14 所示，我們必須在每個實作中註解型別；因為我們也可以為 `Counter` 實作 `Iterator<String>` 或任何其他型別，所以 `Counter` 可以有多個 `Iterator` 的實作。換句話說，當一個 trait 有一個泛型參數時，它可以為一個型別實作多次，每次改變泛型參數的具體型別。當我們在 `Counter` 上使用 `next` 方法時，我們必須提供型別註解來指示我們想要使用哪個 `Iterator` 的實作。

使用關聯型別時，我們不需要註解型別，因為我們不能為一個型別多次實作一個 trait。在範例 20-13 中，使用關聯型別的定義，我們只能選擇一次 `Item` 的型別是什麼，因為只能有一個 `impl Iterator for Counter`。我們不需要在每次呼叫 `Counter` 的 `next` 時都指定我們想要一個 `u32` 值的 iterator。

關聯型別也成為 trait 契約的一部分：trait 的實作者必須提供一個型別來代表關聯型別的佔位符。關聯型別通常有一個描述該型別將如何使用的名稱，並且在 API 文件中記錄關聯型別是一個好的做法。

### 預設泛型型別參數與運算子重載

當我們使用泛型型別參數時，我們可以為泛型型別指定一個預設的具體型別。這消除了 trait 實作者在預設型別可行的情況下指定具體型別的需要。你可以在宣告泛型型別時使用 `<PlaceholderType=ConcreteType>` 語法來指定預設型別。

一個很好的例子是_運算子重載 (operator overloading)_，在這種情況下，你可以自訂一個運算子（例如 `+`）在特定情況下的行為。

Rust 不允許你建立自己的運算子或重載任意的運算子。但是你可以透過實作與運算子相關的 trait 來重載 `std::ops` 中列出的操作和對應的 trait。例如，在範例 20-15 中，我們重載 `+` 運算子來將兩個 `Point` 實例相加。我們透過在 `Point` struct 上實作 `Add` trait 來做到這一點。

src/main.rs

```rust
use std::ops::Add;

#[derive(Debug, Copy, Clone, PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Output = Point;

    fn add(self, other: Point) -> Point {
        Point {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

fn main() {
    assert_eq!(
        Point { x: 1, y: 0 } + Point { x: 2, y: 3 },
        Point { x: 3, y: 3 }
    );
}
```

範例 20-15：實作 `Add` trait 來為 `Point` 實例重載 `+` 運算子

`add` 方法將兩個 `Point` 實例的 `x` 值相加，以及兩個 `Point` 實例的 `y` 值相加，來建立一個新的 `Point`。`Add` trait 有一個名為 `Output` 的關聯型別，它決定了 `add` 方法回傳的型別。

這段程式碼中的預設泛型型別在 `Add` trait 內部。這是它的定義：

```rust
trait Add<Rhs=Self> {
    type Output;

    fn add(self, rhs: Rhs) -> Self::Output;
}
```

這段程式碼應該看起來大致熟悉：一個帶有一個方法和一個關聯型別的 trait。新的部分是 `Rhs=Self`：這個語法被稱為_預設型別參數 (default type parameters)_。`Rhs` 泛型型別參數（「right-hand side」的縮寫）定義了 `add` 方法中 `rhs` 參數的型別。如果我們在實作 `Add` trait 時沒有為 `Rhs` 指定一個具體的型別，`Rhs` 的型別將預設為 `Self`，也就是我們正在為其實作 `Add` 的型別。

當我們為 `Point` 實作 `Add` 時，我們使用了 `Rhs` 的預設值，因為我們想要將兩個 `Point` 實例相加。讓我們來看一個實作 `Add` trait 的例子，在這個例子中我們想要自訂 `Rhs` 型別，而不是使用預設值。

我們有兩個 struct，`Millimeters` 和 `Meters`，它們持有不同單位的值。這種將現有型別包裝在另一個 struct 中的薄層稱為 _newtype pattern_，我們在「使用 Newtype Pattern 實作外部 Trait」一節中有更詳細的描述。我們想要將毫米單位的值加到公尺單位的值上，並讓 `Add` 的實作正確地進行轉換。我們可以為 `Millimeters` 實作 `Add`，並將 `Meters` 作為 `Rhs`，如範例 20-16 所示。

src/lib.rs

```rust
use std::ops::Add;

struct Millimeters(u32);
struct Meters(u32);

impl Add<Meters> for Millimeters {
    type Output = Millimeters;

    fn add(self, other: Meters) -> Millimeters {
        Millimeters(self.0 + (other.0 * 1000))
    }
}
```

範例 20-16：在 `Millimeters` 上實作 `Add` trait 以將 `Millimeters` 和 `Meters` 相加

為了將 `Millimeters` 和 `Meters` 相加，我們指定 `impl Add<Meters>` 來設定 `Rhs` 型別參數的值，而不是使用預設的 `Self`。

你主要會用兩種方式使用預設型別參數：

1. 在不破壞現有程式碼的情況下擴展一個型別
2. 允許在大多數使用者不需要的特定情況下進行自訂

標準函式庫的 `Add` trait 是第二種用途的例子：通常你會將兩個相同型別相加，但 `Add` trait 提供了超出此範圍的自訂能力。在 `Add` trait 定義中使用預設型別參數意味著你大多數時候不必指定額外的參數。換句話說，不需要一些實作的樣板程式碼，使得使用該 trait 更為容易。

第一種用途與第二種相似，但方向相反：如果你想為現有的 trait 新增一個型別參數，你可以給它一個預設值，以便在不破壞現有實作程式碼的情況下擴展 trait 的功能。

<!-- Old link, do not remove -->

<a id="fully-qualified-syntax-for-disambiguation-calling-methods-with-the-same-name"></a>

### 區分同名方法

在 Rust 中，沒有任何東西可以阻止一個 trait 擁有一個與另一個 trait 的方法同名的方法，Rust 也沒有阻止你在同一個型別上實作這兩個 trait。直接在型別上實作一個與 trait 方法同名的方法也是可能的。

當呼叫同名方法時，你需要告訴 Rust 你想用哪一個。考慮範例 20-17 中的程式碼，我們定義了兩個 trait，`Pilot` 和 `Wizard`，它們都有一個名為 `fly` 的方法。然後我們在 `Human` 型別上實作了這兩個 trait，而 `Human` 型別本身也已經實作了一個名為 `fly` 的方法。每個 `fly` 方法做的事情都不同。

src/main.rs

```rust
trait Pilot {
    fn fly(&self);
}

trait Wizard {
    fn fly(&self);
}

struct Human;

impl Pilot for Human {
    fn fly(&self) {
        println!("This is your captain speaking.");
    }
}

impl Wizard for Human {
    fn fly(&self) {
        println!("Up!");
    }
}

impl Human {
    fn fly(&self) {
        println!("*waving arms furiously*");
    }
}
```

範例 20-17：定義了兩個帶有 `fly` 方法的 trait，並在 `Human` 型別上實作，同時 `Human` 也直接實作了一個 `fly` 方法。

當我們在 `Human` 的一個實例上呼叫 `fly` 時，編譯器預設會呼叫直接在該型別上實作的方法，如範例 20-18 所示。

src/main.rs

```rust
fn main() {
    let person = Human;
    person.fly();
}
```

範例 20-18：在 `Human` 的一個實例上呼叫 `fly`

執行這段程式碼將會印出 `*waving arms furiously*`，這表示 Rust 呼叫了直接在 `Human` 上實作的 `fly` 方法。

要呼叫 `Pilot` trait 或 `Wizard` trait 的 `fly` 方法，我們需要使用更明確的語法來指定我們指的是哪個 `fly` 方法。範例 20-19 展示了這種語法。

src/main.rs

```rust
fn main() {
    let person = Human;
    Pilot::fly(&person);
    Wizard::fly(&person);
    person.fly();
}
```

範例 20-19：指定我們想要呼叫哪個 trait 的 `fly` 方法

在方法名前指定 trait 名稱，可以向 Rust 闡明我們想要呼叫哪個 `fly` 的實作。我們也可以寫 `Human::fly(&person)`，這與我們在範例 20-19 中使用的 `person.fly()` 是等效的，但如果我們不需要消除歧義，這樣寫會比較長。

執行這段程式碼會印出以下內容：

```text
$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.46s
     Running `target/debug/traits-example`
This is your captain speaking.
Up!
*waving arms furiously*
```

因為 `fly` 方法接受一個 `self` 參數，如果我們有兩個*型別*都實作了同一個_trait_，Rust 可以根據 `self` 的型別來判斷要使用哪個 trait 的實作。

然而，不是方法的關聯函式沒有 `self` 參數。當有多個型別或 trait 定義了同名且非方法的函式時，除非你使用完全限定語法，否則 Rust 不一定知道你指的是哪個型別。例如，在範例 20-20 中，我們為一個動物收容所建立了一個 trait，該收容所希望將所有幼犬命名為 Spot。我們建立了一個 `Animal` trait，帶有一個關聯的非方法函式 `baby_name`。`Animal` trait 被實作在 `Dog` struct 上，我們也在 `Dog` 上直接提供了一個關聯的非方法函式 `baby_name`。

src/main.rs

```rust
trait Animal {
    fn baby_name() -> String;
}

struct Dog;

impl Dog {
    fn baby_name() -> String {
        String::from("Spot")
    }
}

impl Animal for Dog {
    fn baby_name() -> String {
        String::from("puppy")
    }
}

fn main() {
    println!("A baby dog is called a {}", Dog::baby_name());
}
```

範例 20-20：一個帶有關聯函式的 trait，以及一個同名關聯函式且也實作了該 trait 的型別

我們在 `Dog` 上定義的 `baby_name` 關聯函式中實作了將所有小狗命名為 Spot 的程式碼。`Dog` 型別也實作了 `Animal` trait，該 trait 描述了所有動物共有的特性。幼犬被稱為 puppies，這在 `Dog` 上實作 `Animal` trait 的 `baby_name` 函式中有所體現，該函式與 `Animal` trait 相關聯。

在 `main` 函式中，我們呼叫 `Dog::baby_name` 函式，這會直接呼叫在 `Dog` 上定義的關聯函式。這段程式碼會印出以下內容：

```text
$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.54s
     Running `target/debug/traits-example`
A baby dog is called a Spot
```

這不是我們想要的輸出。我們想要呼叫的是我們在 `Dog` 上實作的 `Animal` trait 的 `baby_name` 函式，這樣程式碼才會印出 `A baby dog is called a puppy`。我們在範例 20-19 中使用的指定 trait 名稱的技巧在這裡沒有幫助；如果我們將 `main` 改成範例 20-21 中的程式碼，我們會得到一個編譯錯誤。

src/main.rs

```rust
fn main() {
    println!("A baby dog is called a {}", Animal::baby_name());
}
```

範例 20-21：試圖呼叫 `Animal` trait 的 `baby_name` 函式，但 Rust 不知道要用哪個實作

因為 `Animal::baby_name` 沒有 `self` 參數，而且可能有其他型別也實作了 `Animal` trait，所以 Rust 無法判斷我們想要哪個 `Animal::baby_name` 的實作。我們會得到這個編譯器錯誤：

```text
$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
error[E0790]: cannot call associated function on trait without specifying the corresponding `impl` type
  --> src/main.rs:20:43
   |
2  |     fn baby_name() -> String;
   |     ------------------------- `Animal::baby_name` defined here
...
20 |     println!("A baby dog is called a {}", Animal::baby_name());
   |                                           ^^^^^^^^^^^^^^^^^^^ cannot call associated function of trait
   |
help: use the fully-qualified path to the only available implementation
   |
20 |     println!("A baby dog is called a {}", <Dog as Animal>::baby_name());
   |                                           +++++++       +

For more information about this error, try `rustc --explain E0790`.
error: could not compile `traits-example` (bin "traits-example") due to 1 previous error
```

為了消除歧義並告訴 Rust 我們想要使用 `Dog` 對 `Animal` 的實作，而不是其他型別對 `Animal` 的實作，我們需要使用完全限定語法。範例 20-22 展示了如何使用完全限定語法。

src/main.rs

```rust
fn main() {
    println!("A baby dog is called a {}", <Dog as Animal>::baby_name());
}
```

範例 20-22：使用完全限定語法來指定我們想要呼叫在 `Dog` 上實作的 `Animal` trait 的 `baby_name` 函式

我們在角括號內提供了一個型別註解給 Rust，這表示我們想要呼叫在 `Dog` 上實作的 `Animal` trait 的 `baby_name` 方法，方法是說我們希望在這個函式呼叫中將 `Dog` 型別視為 `Animal`。現在這段程式碼將會印出我們想要的內容：

```text
$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/traits-example`
A baby dog is called a puppy
```

一般來說，完全限定語法的定義如下：

```rust
<Type as Trait>::function(receiver_if_method, next_arg, ...);
```

對於非方法的關聯函式，不會有 `receiver`：只會有其他參數的列表。你可以在任何呼叫函式或方法的地方使用完全限定語法。然而，只要 Rust 能從程式中的其他資訊推斷出來，你就可以省略這個語法中的任何部分。你只需要在有多個同名實作，且 Rust 需要幫助來識別你想要呼叫哪個實作的情況下，才需要使用這種更冗長的語法。

<!-- Old link, do not remove -->

<a id="using-supertraits-to-require-one-traits-functionality-within-another-trait"></a>

### 使用 Supertrait

有時候你可能會寫一個依賴於另一個 trait 的 trait 定義：要讓一個型別實作第一個 trait，你希望要求該型別也實作第二個 trait。你會這樣做，是為了讓你的 trait 定義可以使用第二個 trait 的關聯項目。你的 trait 定義所依賴的 trait 稱為你 trait 的 _supertrait_。

舉例來說，假設我們想建立一個 `OutlinePrint` trait，它有一個 `outline_print` 方法，可以將給定的值格式化後印出，使其被星號框起來。也就是說，給定一個實作了標準函式庫 trait `Display` 以產生 `(x, y)` 的 `Point` struct，當我們在一個 `x` 為 `1`、`y` 為 `3` 的 `Point` 實例上呼叫 `outline_print` 時，它應該印出以下內容：

```text
**********
*        *
* (1, 3) *
*        *
**********
```

在 `outline_print` 方法的實作中，我們想要使用 `Display` trait 的功能。因此，我們需要指定 `OutlinePrint` trait 只對那些也實作了 `Display` 並提供 `OutlinePrint` 所需功能的型別有效。我們可以在 trait 定義中透過指定 `OutlinePrint: Display` 來做到這一點。這個技巧類似於為 trait 添加 trait bound。範例 20-23 展示了 `OutlinePrint` trait 的一個實作。

src/main.rs

```rust
use std::fmt;

trait OutlinePrint: fmt::Display {
    fn outline_print(&self) {
        let output = self.to_string();
        let len = output.len();
        println!("{}", "*".repeat(len + 4));
        println!("*{}*", " ".repeat(len + 2));
        println!("* {output} *");
        println!("*{}*", " ".repeat(len + 2));
        println!("{}", "*".repeat(len + 4));
    }
}
```

範例 20-23：實作需要 `Display` 功能的 `OutlinePrint` trait

因為我們已經指定 `OutlinePrint` 需要 `Display` trait，所以我們可以使用 `to_string` 函式，這個函式會為任何實作 `Display` 的型別自動實作。如果我們試圖在不加上冒號並在 trait 名稱後指定 `Display` trait 的情況下使用 `to_string`，我們會得到一個錯誤，說在當前作用域中找不到名為 `to_string` 的方法給 `&Self` 型別。

讓我們看看當我們試圖在一個未實作 `Display` 的型別上實作 `OutlinePrint` 時會發生什麼，例如 `Point` struct：

src/main.rs

```rust
struct Point {
    x: i32,
    y: i32,
}

impl OutlinePrint for Point {}
```

我們會得到一個錯誤，說需要 `Display` 但未實作：

```text
$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
error[E0277]: `Point` doesn't implement `std::fmt::Display`
  --> src/main.rs:20:23
   |
20 | impl OutlinePrint for Point {}
   |                       ^^^^^ `Point` cannot be formatted with the default formatter
   |
   = help: the trait `std::fmt::Display` is not implemented for `Point`
   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
note: required by a bound in `OutlinePrint`
  --> src/main.rs:3:21
   |
3  | trait OutlinePrint: fmt::Display {
   |                     ^^^^^^^^^^^^ required by this bound in `OutlinePrint`

error[E0277]: `Point` doesn't implement `std::fmt::Display`
  --> src/main.rs:24:7
   |
24 |     p.outline_print();
   |       ^^^^^^^^^^^^^ `Point` cannot be formatted with the default formatter
   |
   = help: the trait `std::fmt::Display` is not implemented for `Point`
   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
note: required by a bound in `OutlinePrint::outline_print`
  --> src/main.rs:3:21
   |
3  | trait OutlinePrint: fmt::Display {
   |                     ^^^^^^^^^^^^ required by this bound in `OutlinePrint::outline_print`
4  |     fn outline_print(&self) {
   |        ------------- required by a bound in this associated function

For more information about this error, try `rustc --explain E0277`.
error: could not compile `traits-example` (bin "traits-example") due to 2 previous errors
```

要修正這個問題，我們在 `Point` 上實作 `Display`，以滿足 `OutlinePrint` 所需的約束，像這樣：

src/main.rs

```rust
use std::fmt;

impl fmt::Display for Point {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "({}, {})", self.x, self.y)
    }
}
```

然後，在 `Point` 上實作 `OutlinePrint` trait 將會成功編譯，我們就可以在 `Point` 實例上呼叫 `outline_print`，將它顯示在星號框線內。

<!-- Old link, do not remove -->

<a id="using-the-newtype-pattern-to-implement-external-traits-on-external-types"></a>

### 使用 Newtype Pattern 在外部型別上實作外部 Trait

在第 10 章的「在型別上實作 Trait」中，我們提到了孤兒規則（orphan rule），該規則規定我們只能在一個型別上實作一個 trait，前提是該 trait 或該型別，或兩者都位於我們自己的 crate 中。可以使用 _newtype pattern_ 來繞過這個限制，這涉及到在一個 tuple struct 中建立一個新的型別。（我們在第五章的「使用無名欄位的 Tuple Struct 建立不同型別」中介紹過 tuple struct。）這個 tuple struct 將只有一個欄位，並且是我們想要實作 trait 的型別的一個薄層包裝。然後這個包裝型別就位於我們自己的 crate 中，我們就可以在這個包裝上實作 trait。_Newtype_ 這個詞源自 Haskell 程式語言。使用這個模式沒有執行時期的效能損失，包裝型別會在編譯時期被消除。

舉例來說，假設我們想在 `Vec<T>` 上實作 `Display`，但孤兒規則禁止我們直接這麼做，因為 `Display` trait 和 `Vec<T>` 型別都是在我們的 crate 之外定義的。我們可以建立一個 `Wrapper` struct 來持有 `Vec<T>` 的一個實例；然後我們可以在 `Wrapper` 上實作 `Display` 並使用 `Vec<T>` 的值，如範例 20-24 所示。

src/main.rs

```rust
use std::fmt;

struct Wrapper(Vec<String>);

impl fmt::Display for Wrapper {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "[{}]", self.0.join(", "))
    }
}

fn main() {
    let w = Wrapper(vec![String::from("hello"), String::from("world")]);
    println!("w = {w}");
}
```

範例 20-24：建立一個圍繞 `Vec<String>` 的 `Wrapper` 型別以實作 `Display`

`Display` 的實作使用 `self.0` 來存取內部的 `Vec<T>`，因為 `Wrapper` 是一個 tuple struct，而 `Vec<T>` 是 tuple 中索引為 0 的項目。然後我們就可以在 `Wrapper` 上使用 `Display` trait 的功能。

使用這種技術的缺點是 `Wrapper` 是一個新的型別，所以它不具備它所持有的值的方法。我們必須在 `Wrapper` 上直接實作 `Vec<T>` 的所有方法，讓這些方法代理給 `self.0`，這樣我們才能將 `Wrapper` 完全當作 `Vec<T>` 來使用。如果我們希望新 型別擁有內部型別的所有方法，一個解決方案是在 `Wrapper` 上實作 `Deref` trait 來回傳內部型別（我們在第十五章「透過 `Deref` 將智慧指標當作一般參考」中討論過實作 `Deref` trait）。如果我們不希望 `Wrapper` 型別擁有內部型別的所有方法——例如，為了限制 `Wrapper` 型別的行為——我們就必須手動實作我們想要的方法。

即使不涉及 trait，這個 newtype pattern 也很有用。讓我們轉移焦點，看看一些與 Rust 型別系統互動的進階方法。

## 進階型別

Rust 型別系統有一些我們到目前為止提到過但還沒討論過的特性。我們將從討論 newtypes 開始，檢視為什麼 newtypes 作為型別很有用。然後我們將轉向型別別名（type aliases），這個特性與 newtypes 相似，但語意上略有不同。我們還將討論 `!` 型別和動態大小型別。

### 使用 Newtype Pattern 確保型別安全與抽象化

本節假設你已經閱讀了前面的「使用 Newtype Pattern 實作外部 Trait」一節。Newtype pattern 對於除了我們已經討論過的任務之外，還有其他用途，包括靜態地強制值永遠不會被混淆，以及指示值的單位。你在範例 20-16 中看到了一個使用 newtypes 來指示單位的例子：回想一下，`Millimeters` 和 `Meters` struct 將 `u32` 值包裝在一個 newtype 中。如果我們寫一個函式，其參數型別為 `Millimeters`，那麼一個不小心試圖用 `Meters` 型別的值或一個普通的 `u32` 來呼叫該函式的程式將無法編譯。

我們也可以使用 newtype pattern 來抽象化一個型別的一些實作細節：新的型別可以暴露一個與私有內部型別的 API 不同的公開 API。

Newtypes 也可以隱藏內部實作。例如，我們可以提供一個 `People` 型別來包裝一個 `HashMap<i32, String>`，它儲存一個人的 ID 與其姓名的關聯。使用 `People` 的程式碼只會與我們提供的公開 API 互動，例如一個將姓名字串加入 `People` 集合的方法；該程式碼不需要知道我們在內部為姓名分配了一個 `i32` ID。Newtype pattern 是一種輕量級的方式來實現封裝以隱藏實作細節，我們在第 18 章的「隱藏實作細節的封裝」中討論過這一點。

### 使用型別別名建立型別同義詞

Rust 提供了宣告_型別別名 (type alias)_ 的能力，為現有的型別賦予另一個名稱。為此，我們使用 `type` 關鍵字。例如，我們可以為 `i32` 建立一個別名 `Kilometers`，像這樣：

```rust
type Kilometers = i32;
```

現在，別名 `Kilometers` 是 `i32` 的一個_同義詞_；與我們在範例 20-16 中建立的 `Millimeters` 和 `Meters` 型別不同，`Kilometers` 不是一個獨立的新型別。型別為 `Kilometers` 的值將被視為與 `i32` 型別的值相同：

```rust
    type Kilometers = i32;

    let x: i32 = 5;
    let y: Kilometers = 5;

    println!("x + y = {}", x + y);
```

因為 `Kilometers` 和 `i32` 是相同的型別，我們可以將這兩種型別的值相加，也可以將 `Kilometers` 的值傳遞給接受 `i32` 參數的函式。然而，使用這種方法，我們無法獲得前面討論的 newtype pattern 所帶來的型別檢查好處。換句話說，如果我們在某處混淆了 `Kilometers` 和 `i32` 的值，編譯器不會給我們錯誤。

型別同義詞的主要用途是減少重複。例如，我們可能有一個冗長的型別，像這樣：

```rust
Box<dyn Fn() + Send + 'static>
```

在函式簽名和型別註解中到處寫這個冗長的型別可能很繁瑣且容易出錯。想像一下，一個專案中充滿了像範例 20-25 中那樣的程式碼。

```rust
    let f: Box<dyn Fn() + Send + 'static> = Box::new(|| println!("hi"));

    fn takes_long_type(f: Box<dyn Fn() + Send + 'static>) {
        // --snip--
    }

    fn returns_long_type() -> Box<dyn Fn() + Send + 'static> {
        // --snip--
    }
```

範例 20-25：在許多地方使用一個冗長的型別

型別別名可以透過減少重複來使這段程式碼更易於管理。在範例 20-26 中，我們為這個冗長的型別引入了一個名為 `Thunk` 的別名，並可以用更短的別名 `Thunk` 來取代所有使用該型別的地方。

```rust
    type Thunk = Box<dyn Fn() + Send + 'static>;

    let f: Thunk = Box::new(|| println!("hi"));

    fn takes_long_type(f: Thunk) {
        // --snip--
    }

    fn returns_long_type() -> Thunk {
        // --snip--
    }
```

範例 20-26：引入一個型別別名 `Thunk` 以減少重複

這段程式碼變得更容易閱讀和撰寫了！為型別別名選擇一個有意義的名稱也可以幫助傳達你的意圖（_thunk_ 是一個指稍後評估的程式碼的詞，所以它是一個適合用於儲存的閉包的名稱）。

型別別名也常用於 `Result<T, E>` 型別以減少重複。考慮標準函式庫中的 `std::io` 模組。I/O 操作通常會回傳一個 `Result<T, E>` 來處理操作失敗的情況。這個函式庫有一個 `std::io::Error` struct，代表所有可能的 I/O 錯誤。`std::io` 中的許多函式都會回傳 `Result<T, E>`，其中 `E` 是 `std::io::Error`，例如 `Write` trait 中的這些函式：

```rust
use std::fmt;
use std::io::Error;

pub trait Write {
    fn write(&mut self, buf: &[u8]) -> Result<usize, Error>;
    fn flush(&mut self) -> Result<(), Error>;

    fn write_all(&mut self, buf: &[u8]) -> Result<(), Error>;
    fn write_fmt(&mut self, fmt: fmt::Arguments) -> Result<(), Error>;
}
```

`Result<..., Error>` 重複了很多次。因此，`std::io` 有這樣一個型別別名宣告：

```rust
type Result<T> = std::result::Result<T, std::io::Error>;
```

因為這個宣告在 `std::io` 模組中，我們可以使用完全限定的別名 `std::io::Result<T>`；也就是說，一個 `E` 已被填入為 `std::io::Error` 的 `Result<T, E>`。`Write` trait 的函式簽名最終看起來像這樣：

```rust
pub trait Write {
    fn write(&mut self, buf: &[u8]) -> Result<usize>;
    fn flush(&mut self) -> Result<()>;

    fn write_all(&mut self, buf: &[u8]) -> Result<()>;
    fn write_fmt(&mut self, fmt: fmt::Arguments) -> Result<()>;
}
```

這個型別別名有兩個好處：它讓程式碼更容易撰寫，*並且*它為我們提供了一個跨越所有 `std::io` 的一致介面。因為它是一個別名，它就只是一個 `Result<T, E>`，這意味著我們可以在它上面使用任何適用於 `Result<T, E>` 的方法，以及像 `?` 運算子這樣的特殊語法。

### 永不回傳的 Never 型別

Rust 有一個特殊的型別叫做 `!`，在型別理論術語中被稱為_空型別 (empty type)_，因為它沒有任何值。我們比較喜歡稱它為 _never type_，因為當一個函式永遠不會回傳時，它會取代回傳型別的位置。這裡有一個例子：

```rust
fn bar() -> ! {
    // --snip--
}
```

這段程式碼可以讀作「函式 `bar` 回傳 never」。回傳 never 的函式被稱為_發散函式 (diverging functions)_。我們無法建立 `!` 型別的值，所以 `bar` 永遠不可能回傳。

但是，一個你永遠無法為其建立值的型別有什麼用呢？回想一下範例 2-5 中的程式碼，那是猜數字遊戲的一部分；我們在範例 20-27 中重現了其中的一小部分。

```rust
let guess: u32 = match guess.trim().parse() {
    Ok(num) => num,
    Err(_) => continue,
};
```

範例 20-27：一個 `match`，其中一個分支以 `continue` 結尾

當時，我們跳過了這段程式碼的一些細節。在第六章的「`match` 控制流程建構」中，我們討論過 `match` 的所有分支都必須回傳相同的型別。所以，例如，下面的程式碼是行不通的：

```rust
let guess = match guess.trim().parse() {
    Ok(_) => 5,
    Err(_) => "hello",
};
```

在這段程式碼中，`guess` 的型別必須同時是整數*和*字串，而 Rust 要求 `guess` 只能有一種型別。那麼 `continue` 回傳什麼呢？在範例 20-27 中，我們怎麼能夠從一個分支回傳 `u32`，而另一個分支以 `continue` 結尾呢？

你可能已經猜到了，`continue` 的值是 `!`。也就是說，當 Rust 計算 `guess` 的型別時，它會看兩個 match 分支，前者是 `u32` 型別的值，後者是 `!` 型別的值。因為 `!` 永遠不可能有值，所以 Rust 決定 `guess` 的型別是 `u32`。

描述這種行為的正式方式是，`!` 型別的表達式可以被強制轉換成任何其他型別。我們被允許用 `continue` 來結束這個 `match` 分支，因為 `continue` 不會回傳一個值；相反地，它將控制權移回迴圈的頂部，所以在 `Err` 的情況下，我們從未給 `guess` 賦值。

Never 型別對於 `panic!` macro 也很有用。回想一下我們在 `Option<T>` 值上呼叫的 `unwrap` 函式，它會產生一個值或 panic，其定義如下：

```rust
impl<T> Option<T> {
    pub fn unwrap(self) -> T {
        match self {
            Some(val) => val,
            None => panic!("called `Option::unwrap()` on a `None` value"),
        }
    }
}
```

在這段程式碼中，發生的事情與範例 20-27 中的 `match` 相同：Rust 看到 `val` 的型別是 `T`，而 `panic!` 的型別是 `!`，所以整個 `match` 表達式的結果是 `T`。這段程式碼之所以能運作，是因為 `panic!` 不會產生一個值；它會結束程式。在 `None` 的情況下，我們不會從 `unwrap` 回傳一個值，所以這段程式碼是有效的。

最後一個型別為 `!` 的表達式是 `loop`：

```rust
    print!("forever ");

    loop {
        print!("and ever ");
    }
```

在這裡，迴圈永遠不會結束，所以 `!` 是這個表達式的值。然而，如果我們包含一個 `break`，情況就不同了，因為迴圈會在到達 `break` 時終止。

### 動態大小型別與 Sized Trait

Rust 需要知道其型別的某些細節，例如為特定型別的值分配多少空間。這使得其型別系統的一個角落起初有點令人困惑：_動態大小型別 (dynamically sized types)_ 的概念。有時被稱為 _DSTs_ 或 _unsized types_，這些型別讓我們可以使用那些大小只能在執行時期知道的值來撰寫程式碼。

讓我們深入探討一個名為 `str` 的動態大小型別的細節，我們在整本書中都在使用它。沒錯，不是 `&str`，而是 `str` 本身就是一個 DST。在許多情況下，例如儲存使用者輸入的文字時，我們直到執行時期才知道字串的長度。這意味著我們無法建立一個 `str` 型別的變數，也無法接受一個 `str` 型別的參數。考慮以下程式碼，它無法運作：

```rust
let s1: str = "Hello there!";
let s2: str = "How's it going?";
```

Rust 需要知道為任何特定型別的值分配多少記憶體，而且一個型別的所有值都必須使用相同數量的記憶體。如果 Rust 允許我們寫這段程式碼，這兩個 `str` 值就需要佔用相同的空間。但它們的長度不同：`s1` 需要 12 個位元組的儲存空間，而 `s2` 需要 15 個。這就是為什麼不可能建立一個持有動態大小型別的變數。

那我們該怎麼辦呢？在這種情況下，你已經知道答案了：我們將 `s1` 和 `s2` 的型別設為 `&str` 而不是 `str`。回想一下第四章的「字串切片」，slice 資料結構只儲存 slice 的起始位置和長度。所以，雖然 `&T` 是一個單一的值，儲存 `T` 所在的記憶體位址，但 `&str` 是*兩個*值：`str` 的位址和它的長度。因此，我們可以在編譯時期知道 `&str` 值的大小：它是 `usize` 長度的兩倍。也就是說，我們總是知道 `&str` 的大小，不管它所引用的字串有多長。一般來說，這就是動態大小型別在 Rust 中的使用方式：它們有一個額外的元數據，儲存動態資訊的大小。動態大小型別的黃金法則是，我們必須始終將動態大小型別的值放在某種指標後面。

我們可以將 `str` 與各種指標結合：例如，`Box<str>` 或 `Rc<str>`。事實上，你以前見過這個，只是用了不同的動態大小型別：trait。每個 trait 都是一個動態大小型別，我們可以用 trait 的名稱來引用它。在第 18 章的「使用 Trait 物件來抽象化共享行為」中，我們提到要將 trait 作為 trait objects 使用，我們必須將它們放在指標後面，例如 `&dyn Trait` 或 `Box<dyn Trait>`（`Rc<dyn Trait>` 也可以）。

為了處理 DSTs，Rust 提供了 `Sized` trait 來判斷一個型別的大小是否在編譯時期已知。這個 trait 會自動為所有在編譯時期大小已知的東西實作。此外，Rust 會隱式地為每個泛型函式加上一個 `Sized` 的 bound。也就是說，一個像這樣的泛型函式定義：

```rust
fn generic<T>(t: T) {
    // --snip--
}
```

實際上被視為我們寫了這個：

```rust
fn generic<T: Sized>(t: T) {
    // --snip--
}
```

預設情況下，泛型函式只能對那些在編譯時期大小已知的型別運作。然而，你可以使用以下特殊語法來放寬這個限制：

```rust
fn generic<T: ?Sized>(t: &T) {
    // --snip--
}
```

`?Sized` 的 trait bound 意指「`T` 可能是也可能不是 `Sized`」，這個標記覆寫了泛型型別必須在編譯時期大小已知的預設值。`?Trait` 語法有此意義的只適用於 `Sized`，不適用於任何其他 trait。

另外請注意，我們將 `t` 參數的型別從 `T` 改為 `&T`。因為這個型別可能不是 `Sized`，我們需要透過某種指標來使用它。在這種情況下，我們選擇了 reference。

接下來，我們來談談函式和閉包！

## 進階函式與閉包

本節探討一些與函式和閉包相關的進階功能，包括函式指標和回傳閉包。

### 函式指標

我們已經討論過如何將閉包傳遞給函式；你也可以將一般的函式傳遞給函式！當你想要傳遞一個你已經定義好的函式，而不是定義一個新的閉包時，這個技巧很有用。函式會被強制轉換成 `fn` 型別（小寫的 _f_），不要與 `Fn` 閉包 trait 混淆。`fn` 型別被稱為_函式指標 (function pointer)_。用函式指標傳遞函式將允許你將函式作為其他函式的參數。

指定一個參數是函式指標的語法與閉包的語法相似，如範例 20-28 所示，我們定義了一個函式 `add_one`，它將其參數加 1。函式 `do_twice` 接受兩個參數：一個指向任何接受 `i32` 參數並回傳 `i32` 的函式的函式指標，以及一個 `i32` 值。`do_twice` 函式呼叫函式 `f` 兩次，將 `arg` 值傳遞給它，然後將兩次函式呼叫的結果相加。`main` 函式用 `add_one` 和 `5` 作為參數呼叫 `do_twice`。

src/main.rs

```rust
fn add_one(x: i32) -> i32 {
    x + 1
}

fn do_twice(f: fn(i32) -> i32, arg: i32) -> i32 {
    f(arg) + f(arg)
}

fn main() {
    let answer = do_twice(add_one, 5);

    println!("The answer is: {answer}");
}
```

範例 20-28：使用 `fn` 型別來接受一個函式指標作為參數

這段程式碼會印出 `The answer is: 12`。我們指定 `do_twice` 中的參數 `f` 是一個 `fn`，它接受一個 `i32` 型別的參數並回傳一個 `i32`。然後我們可以在 `do_twice` 的主體中呼叫 `f`。在 `main` 中，我們可以將函式名稱 `add_one` 作為第一個參數傳遞給 `do_twice`。

與閉包不同，`fn` 是一個型別而不是一個 trait，所以我們直接將 `fn` 指定為參數型別，而不是宣告一個帶有 `Fn` trait 之一作為 trait bound 的泛型型別參數。

函式指標實作了所有三個閉包 trait (`Fn`, `FnMut`, 和 `FnOnce`)，這意味著你總是可以在一個期望閉包的函式中傳遞一個函式指標作為參數。最好是使用泛型型別和其中一個閉包 trait 來撰寫函式，這樣你的函式就可以接受函式或閉包。

話雖如此，一個你只想接受 `fn` 而不接受閉包的例子是與不具備閉包的外部程式碼介接時：C 函式可以接受函式作為參數，但 C 沒有閉包。

舉一個你可以使用內聯定義的閉包或命名函式的例子，讓我們看看標準函式庫中 `Iterator` trait 提供的 `map` 方法的用法。要使用 `map` 方法將一個數字向量轉換成一個字串向量，我們可以使用一個閉包，如範例 20-29 所示。

```rust
let list_of_numbers = vec![1, 2, 3];
let list_of_strings: Vec<String> =
    list_of_numbers.iter().map(|i| i.to_string()).collect();
```

範例 20-29：使用閉包與 `map` 方法將數字轉換為字串

或者我們可以將一個函式命名為 `map` 的參數，而不是閉包。範例 20-30 展示了這會是什麼樣子。

```rust
let list_of_numbers = vec![1, 2, 3];
let list_of_strings: Vec<String> =
    list_of_numbers.iter().map(ToString::to_string).collect();
```

範例 20-30：使用 `String::to_string` 函式與 `map` 方法將數字轉換為字串

請注意，我們必須使用我們在「進階 Trait」中討論過的完全限定語法，因為有多個名為 `to_string` 的函式可用。

在這裡，我們使用的是 `ToString` trait 中定義的 `to_string` 函式，標準函式庫已經為任何實作 `Display` 的型別實作了這個 trait。

回想一下第六章的「Enum 值」，我們定義的每個 enum variant 的名稱也會成為一個初始化函式。我們可以將這些初始化函式作為實作了閉包 trait 的函式指標來使用，這意味著我們可以將初始化函式指定為接受閉包的方法的參數，如範例 20-31 所示。

```rust
    enum Status {
        Value(u32),
        Stop,
    }

    let list_of_statuses: Vec<Status> = (0u32..20).map(Status::Value).collect();
```

範例 20-31：使用 enum 初始化器與 `map` 方法從數字建立 `Status` 實例

在這裡，我們使用 `Status::Value` 的初始化函式，為 `map` 所呼叫的範圍中的每個 `u32` 值建立 `Status::Value` 實例。有些人偏好這種風格，有些人則偏好使用閉包。它們會編譯成相同的程式碼，所以使用對你來說更清晰的風格即可。

### 回傳閉包

閉包是由 trait 來表示的，這意味著你不能直接回傳閉包。在大多數你可能想回傳 trait 的情況下，你可以改用實作該 trait 的具體型別作為函式的回傳值。然而，對於閉包，你通常不能這麼做，因為它們沒有一個可以回傳的具體型別；例如，如果閉包從其作用域中捕獲了任何值，你就不被允許使用函式指標 `fn` 作為回傳型別。

相反地，你通常會使用我們在第 10 章學到的 `impl Trait` 語法。你可以使用 `Fn`、`FnOnce` 和 `FnMut` 來回傳任何函式型別。例如，範例 20-32 中的程式碼可以正常編譯。

```rust
fn returns_closure() -> impl Fn(i32) -> i32 {
    |x| x + 1
}
```

範例 20-32：使用 `impl Trait` 語法從函式回傳閉包

然而，正如我們在第 13 章的「閉包型別推斷與註解」中指出的，每個閉包也都是自己獨特的型別。如果你需要處理多個簽名相同但實作不同的函式，你需要為它們使用一個 trait object。考慮一下如果你寫了像範例 20-33 所示的程式碼會發生什麼。

src/main.rs

```rust
fn main() {
    let handlers = vec![returns_closure(), returns_initialized_closure(123)];
    for handler in handlers {
        let output = handler(5);
        println!("{output}");
    }
}

fn returns_closure() -> impl Fn(i32) -> i32 {
    |x| x + 1
}

fn returns_initialized_closure(init: i32) -> impl Fn(i32) -> i32 {
    move |x| x + init
}
```

範例 20-33：建立一個由回傳 `impl Fn` 型別的函式所定義的 `Vec<T>` 閉包

這裡我們有兩個函式，`returns_closure` 和 `returns_initialized_closure`，它們都回傳 `impl Fn(i32) -> i32`。請注意，它們回傳的閉包是不同的，即使它們實作了相同的型別。如果我們試圖編譯這個，Rust 會告訴我們這樣行不通：

```text
$ cargo build
   Compiling functions-example v0.1.0 (file:///projects/functions-example)
error[E0308]: mismatched types
  --> src/main.rs:2:44
   |
2  |     let handlers = vec![returns_closure(), returns_initialized_closure(123)];
   |                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected opaque type, found a different opaque type
...
9  | fn returns_closure() -> impl Fn(i32) -> i32 {
   |                         ------------------- the expected opaque type
...
13 | fn returns_initialized_closure(init: i32) -> impl Fn(i32) -> i32 {
   |                                              ------------------- the found opaque type
   |
   = note: expected opaque type `impl Fn(i32) -> i32` (opaque type at <src/main.rs:9:25>)
              found opaque type `impl Fn(i32) -> i32` (opaque type at <src/main.rs:13:46>)
   = note: distinct uses of `impl Trait` result in different opaque types

For more information about this error, try `rustc --explain E0308`.
error: could not compile `functions-example` (bin "functions-example") due to 1 previous error
```

錯誤訊息告訴我們，每當我們回傳一個 `impl Trait` 時，Rust 就會建立一個獨特的_不透明型別 (opaque type)_，這是一種我們無法看到 Rust 為我們建構的細節，也無法猜測 Rust 會產生什麼型別來自己寫的型別。所以即使這些函式回傳的閉包實作了相同的 trait，`Fn(i32) -> i32`，Rust 為每個函式產生的不透明型別是不同的。（這類似於 Rust 為不同的 async 區塊產生不同的具體型別，即使它們有相同的輸出型別，正如我們在第 17 章的「處理任意數量的 Future」中所見。）我們已經看過幾次這個問題的解決方案了：我們可以使用一個 trait object，如範例 20-34 所示。

```rust
fn returns_closure() -> Box<dyn Fn(i32) -> i32> {
    Box::new(|x| x + 1)
}

fn returns_initialized_closure(init: i32) -> Box<dyn Fn(i32) -> i32> {
    Box::new(move |x| x + init)
}
```

範例 20-34：建立一個由回傳 `Box<dyn Fn>` 的函式定義的 `Vec<T>` 閉包，使它們具有相同的型別

這段程式碼可以正常編譯。關於 trait objects 的更多資訊，請參考第 18 章的「使用 Trait 物件允許不同型別的值」一節。

接下來，讓我們看看 macro！

## Macro

我們在本書中一直使用像 `println!` 這樣的 macro，但我們還沒有完全探討什麼是 macro 以及它是如何運作的。術語 _macro_ 指的是 Rust 中的一系列功能：使用 `macro_rules!` 的_宣告式 (declarative)_ macro，以及三種_程序式 (procedural)_ macro：

- 自訂 `#[derive]` macro，指定使用 `derive` 屬性在 struct 和 enum 上新增的程式碼
- 屬性類 macro，定義可用於任何項目的自訂屬性
- 函式類 macro，看起來像函式呼叫，但操作於指定為其參數的 token

我們將依次討論這些，但首先，讓我們看看當我們已經有函式時，為什麼還需要 macro。

### Macro 與函式之間的差異

基本上，macro 是一種撰寫程式碼來產生其他程式碼的方式，這被稱為_元程式設計 (metaprogramming)_。在附錄 C 中，我們討論了 `derive` 屬性，它會為你產生各種 trait 的實作。我們在整本書中也使用了 `println!` 和 `vec!` macro。所有這些 macro 都會*展開*以產生比你手動撰寫的程式碼更多的程式碼。

元程式設計對於減少你需要撰寫和維護的程式碼量很有用，這也是函式的角色之一。然而，macro 有一些函式沒有的額外能力。

函式簽名必須宣告函式所擁有的參數數量和型別。另一方面，macro 可以接受可變數量的參數：我們可以呼叫 `println!("hello")` 帶一個參數，或 `println!("hello {}", name)` 帶兩個參數。此外，macro 在編譯器解釋程式碼的意義之前被展開，所以 macro 可以，例如，在給定的型別上實作一個 trait。函式不能，因為它在執行時期被呼叫，而 trait 需要在編譯時期實作。

實作 macro 而非函式的缺點是，macro 的定義比函式定義更複雜，因為你在寫 Rust 程式碼來產生 Rust 程式碼。由於這種間接性，macro 定義通常比函式定義更難閱讀、理解和維護。

macro 和函式之間的另一個重要區別是，你必須在檔案中呼叫 macro *之前*定義它們或將它們帶入作用域，而函式則可以在任何地方定義並在任何地方呼叫。

### 使用 macro_rules! 的宣告式 Macro 進行通用元程式設計

在 Rust 中，最廣泛使用的 macro 形式是_宣告式 macro (declarative macro)_。這些有時也被稱為「範例 macro」、「`macro_rules!` macro」或簡稱「macro」。在其核心，宣告式 macro 允許你寫出類似於 Rust `match` 表達式的東西。如第六章所述，`match` 表達式是控制結構，它接受一個表達式，將表達式的結果值與模式進行比較，然後執行與匹配模式相關聯的程式碼。Macro 也會將一個值與與特定程式碼相關聯的模式進行比較：在這種情況下，該值是傳遞給 macro 的字面 Rust 原始碼；模式與該原始碼的結構進行比較；而與每個模式相關聯的程式碼，在匹配時，會取代傳遞給 macro 的程式碼。這一切都發生在編譯期間。

要定義一個 macro，你使用 `macro_rules!` 結構。讓我們透過看看 `vec!` macro 是如何定義的來探索如何使用 `macro_rules!`。第八章介紹了我們如何使用 `vec!` macro 來建立一個帶有特定值的新 vector。例如，下面的 macro 建立了一個包含三個整數的新 vector：

```rust
let v: Vec<u32> = vec![1, 2, 3];
```

我們也可以使用 `vec!` macro 來建立一個包含兩個整數的 vector 或一個包含五個 string slice 的 vector。我們無法使用函式來做同樣的事情，因為我們無法預先知道值的數量或型別。

範例 20-35 展示了一個稍微簡化的 `vec!` macro 的定義。

src/lib.rs

```rust
#[macro_export]
macro_rules! vec {
    ( $( $x:expr ),* ) => {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}
```

範例 20-35：`vec!` macro 定義的簡化版本

> 注意：標準函式庫中 `vec!` macro 的實際定義包含了預先分配正確記憶體量的程式碼。該程式碼是一種優化，我們在這裡不包含它，以使範例更簡單。

`#[macro_export]` 註解表示，每當定義該 macro 的 crate 被帶入作用域時，該 macro 就應該可用。沒有這個註解，該 macro 就無法被帶入作用域。

然後我們用 `macro_rules!` 和我們正在定義的 macro 的名稱開始 macro 的定義，名稱*不*帶驚嘆號。名稱，在這裡是 `vec`，後面跟著表示 macro 定義主體的大括號。

`vec!` 主體中的結構類似於 `match` 表達式的結構。這裡我們有一個分支，模式是 `( $( $x:expr ),* )`，後面跟著 `=>` 和與此模式相關聯的程式碼區塊。如果模式匹配，相關聯的程式碼區塊將被發出。鑑於這是這個 macro 中唯一的模式，只有一種有效的匹配方式；任何其他模式都會導致錯誤。更複雜的 macro 會有多個分支。

macro 定義中的有效模式語法與第 19 章中介紹的模式語法不同，因為 macro 模式是與 Rust 程式碼結構而不是值進行匹配。讓我們來看看範例 20-29 中模式的各個部分是什麼意思；完整的 macro 模式語法，請參閱 Rust 參考手冊 _https://doc.rust-lang.org/book/../reference/macros-by-example.html_。

首先，我們用一對括號來包含整個模式。我們用一個錢字號 (`$`) 來在 macro 系統中宣告一個變數，該變數將包含與模式匹配的 Rust 程式碼。錢字號清楚地表明這是一個 macro 變數，而不是一個普通的 Rust 變數。接下來是一對括號，它捕獲與括號內模式匹配的值，以供在替換程式碼中使用。在 `$()` 內是 `$x:expr`，它匹配任何 Rust 表達式，並給予該表達式名稱 `$x`。

`$()` 後面的逗號表示在每個匹配 `$()` 中程式碼的實例之間必須出現一個字面上的逗號分隔符。`*` 指定該模式匹配零個或多個在 `*` 之前的任何東西。

當我們用 `vec![1, 2, 3];` 呼叫這個 macro 時，`$x` 模式與三個表達式 `1`、`2` 和 `3` 匹配了三次。

現在讓我們看看與這個分支相關的程式碼主體中的模式：`$()*` 內的 `temp_vec.push()` 會根據模式匹配的次數，為每個匹配 `$()` 的部分產生零次或多次。`$x` 會被替換為每個匹配的表達式。當我們用 `vec![1, 2, 3];` 呼叫這個 macro 時，取代這個 macro 呼叫所產生的程式碼將是以下內容：

```rust
{
    let mut temp_vec = Vec::new();
    temp_vec.push(1);
    temp_vec.push(2);
    temp_vec.push(3);
    temp_vec
}
```

我們定義了一個可以接受任意數量、任意型別參數的 macro，並且可以產生程式碼來建立一個包含指定元素的 vector。

要了解更多關於如何撰寫 macro 的資訊，請參考線上文件或其他資源，例如 Daniel Keep 開始、Lukas Wirth 繼續的《The Little Book of Rust Macros》，網址為 _https://veykril.github.io/tlborm/_。

### 程序式 Macro 從屬性產生程式碼

第二種 macro 形式是程序式 macro，它的行為更像一個函式（並且是一種程序）。_程序式 macro_ 接受一些程式碼作為輸入，對該程式碼進行操作，並產生一些程式碼作為輸出，而不是像宣告式 macro 那樣與模式匹配並用其他程式碼替換程式碼。三種程序式 macro 分別是自訂 `derive`、屬性類和函式類，它們的運作方式都相似。

在建立程序式 macro 時，定義必須位於它們自己的 crate 中，並具有特殊的 crate 型別。這是出於複雜的技術原因，我們希望未來能消除這一點。在範例 20-36 中，我們展示了如何定義一個程序式 macro，其中 `some_attribute` 是使用特定 macro 種類的佔位符。

src/lib.rs

```rust
use proc_macro;

#[some_attribute]
pub fn some_name(input: TokenStream) -> TokenStream {
}
```

範例 20-36：定義一個程序式 macro 的範例

定義程序式 macro 的函式接受一個 `TokenStream` 作為輸入，並產生一個 `TokenStream` 作為輸出。`TokenStream` 型別由 Rust 內建的 `proc_macro` crate 定義，代表一個 token 序列。這是 macro 的核心：macro 操作的原始碼構成了輸入的 `TokenStream`，而 macro 產生的程式碼是輸出的 `TokenStream`。該函式還有一個附加的屬性，指定我們正在建立哪種程序式 macro。我們可以在同一個 crate 中擁有多種程序式 macro。

讓我們看看不同種類的程序式 macro。我們將從自訂 `derive` macro 開始，然後解釋使其他形式不同的微小差異。

### 如何撰寫自訂 derive Macro

讓我們建立一個名為 `hello_macro` 的 crate，它定義了一個名為 `HelloMacro` 的 trait，帶有一個名為 `hello_macro` 的關聯函式。我們不會讓我們的使用者為他們的每個型別實作 `HelloMacro` trait，而是提供一個程序式 macro，這樣使用者就可以用 `#[derive(HelloMacro)]` 來標註他們的型別，以獲得 `hello_macro` 函式的預設實作。預設實作將印出 `Hello, Macro! My name is TypeName!`，其中 `TypeName` 是定義了這個 trait 的型別的名稱。換句話說，我們將寫一個 crate，讓另一個程式設計師能夠使用我們的 crate 來寫出像範例 20-37 這樣的程式碼。

src/main.rs

```rust
use hello_macro::HelloMacro;
use hello_macro_derive::HelloMacro;

#[derive(HelloMacro)]
struct Pancakes;

fn main() {
    Pancakes::hello_macro();
}
```

範例 20-37：當使用我們的程序式 macro 時，我們 crate 的使用者將能夠撰寫的程式碼

當我們完成後，這段程式碼將印出 `Hello, Macro! My name is Pancakes!`。第一步是建立一個新的函式庫 crate，像這樣：

```text
$ cargo new hello_macro --lib
```

接下來，在範例 20-38 中，我們將定義 `HelloMacro` trait 及其關聯函式。

src/lib.rs

```rust
pub trait HelloMacro {
    fn hello_macro();
}
```

範例 20-38：一個我們將與 `derive` macro 一起使用的簡單 trait

我們有一個 trait 和它的函式。此時，我們的 crate 使用者可以實作這個 trait 來達到期望的功能，如範例 20-39 所示。

src/main.rs

```rust
use hello_macro::HelloMacro;

struct Pancakes;

impl HelloMacro for Pancakes {
    fn hello_macro() {
        println!("Hello, Macro! My name is Pancakes!");
    }
}

fn main() {
    Pancakes::hello_macro();
}
```

範例 20-39：如果使用者手動實作 `HelloMacro` trait 會是什麼樣子

然而，他們需要為每個想要與 `hello_macro` 一起使用的型別撰寫實作區塊；我們希望免去他們這項工作。

此外，我們還無法提供一個帶有預設實作的 `hello_macro` 函式，該實作會印出實作該 trait 的型別的名稱：Rust 沒有反射功能，所以它無法在執行時期查找型別的名稱。我們需要一個 macro 在編譯時期產生程式碼。

下一步是定義程序式 macro。在撰寫本文時，程序式 macro 需要在它們自己的 crate 中。最終，這個限制可能會被解除。組織 crate 和 macro crate 的慣例如下：對於一個名為 `foo` 的 crate，一個自訂 `derive` 程序式 macro crate 被稱為 `foo_derive`。讓我們在 `hello_macro` 專案內開始一個名為 `hello_macro_derive` 的新 crate：

```text
$ cargo new hello_macro_derive --lib
```

我們的兩個 crate 關係密切，所以我們在 `hello_macro` crate 的目錄內建立程序式 macro crate。如果我們在 `hello_macro` 中改變了 trait 的定義，我們也必須在 `hello_macro_derive` 中改變程序式 macro 的實作。這兩個 crate 將需要分開發布，使用這些 crate 的程式設計師將需要將兩者都作為依賴項加入，並將它們都帶入作用域。我們也可以讓 `hello_macro` crate 使用 `hello_macro_derive` 作為依賴項，並重新匯出程序式 macro 的程式碼。然而，我們組織專案的方式使得程式設計師即使不想要 `derive` 功能，也可以使用 `hello_macro`。

我們需要將 `hello_macro_derive` crate 宣告為一個程序式 macro crate。我們還需要 `syn` 和 `quote` crate 的功能，你稍後會看到，所以我們需要將它們作為依賴項加入。將以下內容加入到 `hello_macro_derive` 的 _Cargo.toml_ 檔案中：

hello_macro_derive/Cargo.toml

```toml
[lib]
proc-macro = true

[dependencies]
syn = "2.0"
quote = "1.0"
```

要開始定義程序式 macro，將範例 20-40 中的程式碼放入 `hello_macro_derive` crate 的 _src/lib.rs_ 檔案中。請注意，這段程式碼在我們加入 `impl_hello_macro` 函式的定義之前無法編譯。

hello_macro_derive/src/lib.rs

```rust
use proc_macro::TokenStream;
use quote::quote;

#[proc_macro_derive(HelloMacro)]
pub fn hello_macro_derive(input: TokenStream) -> TokenStream {
    // Construct a representation of Rust code as a syntax tree
    // that we can manipulate.
    let ast = syn::parse(input).unwrap();

    // Build the trait implementation.
    impl_hello_macro(&ast)
}
```

範例 20-40：大多數程序式 macro crate 處理 Rust 程式碼所需的程式碼

請注意，我們已經將程式碼分為 `hello_macro_derive` 函式，它負責解析 `TokenStream`，和 `impl_hello_macro` 函式，它負責轉換語法樹：這使得撰寫程序式 macro 更為方便。外部函式（在這裡是 `hello_macro_derive`）中的程式碼對於你看到或建立的幾乎每個程序式 macro crate 都會是相同的。你在內部函式（在這裡是 `impl_hello_macro`）主體中指定的程式碼將根據你的程序式 macro 的目的而有所不同。

我們介紹了三個新的 crate：`proc_macro`、`syn` 位於 _https://crates.io/crates/syn_<!--ignore -->，和 `quote`。`proc_macro` crate 是 Rust 內建的，所以我們不需要在 _Cargo.toml_ 的依賴項中加入它。`proc_macro` crate 是編譯器的 API，讓我們可以從我們的程式碼中讀取和操作 Rust 程式碼。

`syn` crate 將 Rust 程式碼從字串解析成一個我們可以進行操作的資料結構。`quote` crate 則將 `syn` 資料結構轉回 Rust 程式碼。這些 crate 使得解析任何我們可能想要處理的 Rust 程式碼變得簡單得多：為 Rust 程式碼撰寫一個完整的解析器並非易事。

當我們函式庫的使用者在一個型別上指定 `#[derive(HelloMacro)]` 時，`hello_macro_derive` 函式將被呼叫。這之所以可能，是因為我們在這裡用 `proc_macro_derive` 註解了 `hello_macro_derive` 函式，並指定了名稱 `HelloMacro`，這與我們的 trait 名稱相符；這是大多數程序式 macro 遵循的慣例。

`hello_macro_derive` 函式首先將 `input` 從 `TokenStream` 轉換為一個我們可以解釋和操作的資料結構。這就是 `syn` 發揮作用的地方。`syn` 中的 `parse` 函式接受一個 `TokenStream` 並回傳一個 `DeriveInput` struct，代表解析後的 Rust 程式碼。範例 20-41 展示了我們從解析 `struct Pancakes;` 字串得到的 `DeriveInput` struct 的相關部分。

```
DeriveInput {
    // --snip--

    ident: Ident {
        ident: "Pancakes",
        span: #0 bytes(95..103)
    },
    data: Struct(
        DataStruct {
            struct_token: Struct,
            fields: Unit,
            semi_token: Some(
                Semi
            )
        }
    )
}
```

範例 20-41：當解析範例 20-37 中帶有 macro 屬性的程式碼時，我們得到的 `DeriveInput` 實例

這個 struct 的欄位顯示我們解析的 Rust 程式碼是一個 unit struct，其 `ident`（_identifier_，意即名稱）為 `Pancakes`。這個 struct 上還有更多欄位用於描述各種 Rust 程式碼；請查看 `syn` 文件中關於 `DeriveInput` 的說明，網址為 _https://docs.rs/syn/2.0/syn/struct.DeriveInput.html_ 以獲取更多資訊。

我們很快就會定義 `impl_hello_macro` 函式，這將是我們建構想要包含的新 Rust 程式碼的地方。但在我們這麼做之前，請注意我們的 `derive` macro 的輸出也是一個 `TokenStream`。回傳的 `TokenStream` 會被加到我們 crate 使用者所寫的程式碼中，所以當他們編譯他們的 crate 時，他們將會得到我們在修改後的 `TokenStream` 中提供的額外功能。

你可能已經注意到，如果 `syn::parse` 函式呼叫失敗，我們會呼叫 `unwrap` 來讓 `hello_macro_derive` 函式 panic。我們的程序式 macro 在出錯時必須 panic，因為 `proc_macro_derive` 函式必須回傳 `TokenStream` 而不是 `Result`，以符合程序式 macro API 的要求。我們透過使用 `unwrap` 簡化了這個例子；在生產程式碼中，你應該使用 `panic!` 或 `expect` 來提供更具體的錯誤訊息，說明出了什麼問題。

現在我們有了將標註的 Rust 程式碼從 `TokenStream` 轉換為 `DeriveInput` 實例的程式碼，讓我們來產生在標註型別上實作 `HelloMacro` trait 的程式碼，如範例 20-42 所示。

hello_macro_derive/src/lib.rs

```rust
fn impl_hello_macro(ast: &syn::DeriveInput) -> TokenStream {
    let name = &ast.ident;
    let generated = quote! {
        impl HelloMacro for #name {
            fn hello_macro() {
                println!("Hello, Macro! My name is {}!", stringify!(#name));
            }
        }
    };
    generated.into()
}
```

範例 20-42：使用解析後的 Rust 程式碼實作 `HelloMacro` trait

我們使用 `ast.ident` 得到一個包含標註型別名稱（識別符）的 `Ident` struct 實例。範例 20-41 中的 struct 顯示，當我們對範例 20-37 中的程式碼執行 `impl_hello_macro` 函式時，我們得到的 `ident` 的 `ident` 欄位值將是 `"Pancakes"`。因此，範例 20-42 中的 `name` 變數將包含一個 `Ident` struct 實例，當它被印出時，將是字串 `"Pancakes"`，也就是範例 20-37 中 struct 的名稱。

`quote!` macro 讓我們可以定義我們想要回傳的 Rust 程式碼。編譯器期望的東西與 `quote!` macro 執行的直接結果不同，所以我們需要將它轉換成 `TokenStream`。我們透過呼叫 `into` 方法來做到這一點，它會消耗這個中間表示，並回傳所需 `TokenStream` 型別的值。

`quote!` macro 還提供了一些非常酷的模板機制：我們可以輸入 `#name`，`quote!` 會用變數 `name` 中的值來取代它。你甚至可以做一些類似於一般 macro 運作方式的重複。請查看 `quote` crate 的文件，網址為 _https://docs.rs/quote_，以獲得詳盡的介紹。

我們希望我們的程序式 macro 為使用者標註的型別產生 `HelloMacro` trait 的實作，這可以透過使用 `#name` 來實現。Trait 的實作有一個函式 `hello_macro`，其主體包含了我們想要提供的功能：印出 `Hello, Macro! My name is`，然後是標註型別的名稱。

這裡使用的 `stringify!` macro 是 Rust 內建的。它接受一個 Rust 表達式，例如 `1 + 2`，並在編譯時期將該表達式轉換成一個字串字面值，例如 `"1 + 2"`。這與 `format!` 或 `println!` macro 不同，後者會評估表達式，然後將結果轉換成 `String`。`#name` 輸入有可能是要字面上印出的表達式，所以我們使用 `stringify!`。使用 `stringify!` 也能在編譯時期將 `#name` 轉換成字串字面值，從而節省一次分配。

至此，`cargo build` 應該能在 `hello_macro` 和 `hello_macro_derive` 中成功完成。讓我們將這些 crate 連接到範例 20-37 的程式碼中，看看程序式 macro 的實際效果！在你的 _projects_ 目錄下使用 `cargo new pancakes` 建立一個新的二進位專案。我們需要在 `pancakes` crate 的 _Cargo.toml_ 中將 `hello_macro` 和 `hello_macro_derive` 作為依賴項加入。如果你要將你的 `hello_macro` 和 `hello_macro_derive` 版本發布到 crates.io，它們將是常規依賴項；如果不是，你可以將它們指定為 `path` 依賴項，如下所示：

```toml
[dependencies]
hello_macro = { path = "../hello_macro" }
hello_macro_derive = { path = "../hello_macro/hello_macro_derive" }
```

將範例 20-37 的程式碼放入 _src/main.rs_，然後執行 `cargo run`：它應該會印出 `Hello, Macro! My name is Pancakes!`。來自程序式 macro 的 `HelloMacro` trait 實作被包含了，而不需要 `pancakes` crate 去實作它；`#[derive(HelloMacro)]` 新增了 trait 的實作。

接下來，讓我們探討其他種類的程序式 macro 與自訂 `derive` macro 有何不同。

### 屬性類 Macro

屬性類 macro (Attribute-like macros) 與自訂 `derive` macro 相似，但它們不是為 `derive` 屬性產生程式碼，而是允許你建立新的屬性。它們也更靈活：`derive` 只適用於 struct 和 enum；屬性則可以應用於其他項目，例如函式。這是一個使用屬性類 macro 的例子。假設你有一個名為 `route` 的屬性，用於在使用 web 應用框架時標註函式：

```rust
#[route(GET, "/")]
fn index() {
```

這個 `#[route]` 屬性將由框架定義為一個程序式 macro。該 macro 定義函式的簽名將如下所示：

```rust
#[proc_macro_attribute]
pub fn route(attr: TokenStream, item: TokenStream) -> TokenStream {
```

在這裡，我們有兩個 `TokenStream` 型別的參數。第一個是屬性的內容：`GET, "/"` 部分。第二個是屬性附加到的項目的主體：在這種情況下，是 `fn index() {}` 和函式主體的其餘部分。

除此之外，屬性類 macro 的運作方式與自訂 `derive` macro 相同：你建立一個帶有 `proc-macro` crate 型別的 crate，並實作一個產生你想要程式碼的函式！

### 函式類 Macro

函式類 macro (Function-like macros) 定義了看起來像函式呼叫的 macro。與 `macro_rules!` macro 相似，它們比函式更靈活；例如，它們可以接受未知數量的參數。然而，`macro_rules!` macro 只能使用我們稍早在「使用 `macro_rules!` 的宣告式 Macro 進行通用元程式設計」中討論的類 match 語法來定義。函式類 macro 接受一個 `TokenStream` 參數，其定義使用 Rust 程式碼來操作該 `TokenStream`，就像其他兩種程序式 macro 一樣。一個函式類 macro 的例子是一個 `sql!` macro，它可能被這樣呼叫：

```rust
let sql = sql!(SELECT * FROM posts WHERE id=1);
```

這個 macro 會解析內部的 SQL 語句並檢查其語法是否正確，這比 `macro_rules!` macro 所能做的處理要複雜得多。`sql!` macro 的定義會像這樣：

```rust
#[proc_macro]
pub fn sql(input: TokenStream) -> TokenStream {
```

這個定義與自訂 `derive` macro 的簽名相似：我們接收括號內的 token，並回傳我們想要產生的程式碼。

## 總結

呼！現在你的工具箱裡有了一些你可能不常使用，但你會知道在非常特定的情況下可用的 Rust 功能。我們介紹了幾個複雜的主題，這樣當你在錯誤訊息建議中或在別人的程式碼中遇到它們時，你將能夠辨認這些概念和語法。將本章作為參考，引導你找到解決方案。

接下來，我們將把整本書中討論過的所有內容付諸實踐，再做一個專案！
