<!-- DO NOT EDIT THIS FILE.

This file is periodically generated from the content in the `/src/`
directory, so all fixes need to be made in `/src/`.
-->

[TOC]

# 進階功能

至此，你已經學會了 Rust 程式語言中最常用的部分。在我們於第 21 章再做一個專案之前，我們將先看看你偶爾可能會遇到，但不一定每天都會用到的一些語言特性。你可以將本章作為參考，以備你不時之需。這裡介紹的功能在非常特定的情況下才有用。雖然你可能不常使用它們，但我們希望確保你對 Rust 所提供的所有功能都有所掌握。

在本章中，我們將介紹：

* Unsafe Rust：如何選擇不使用 Rust 的一些保證，並承擔手動維護這些保證的責任
* 進階 traits：關聯型別 (associated types)、預設型別參數、完全限定語法 (fully qualified syntax)、supertraits，以及與 trait 相關的 newtype pattern
* 進階型別：更多關於 newtype pattern、型別別名 (type aliases)、never type 和動態大小型別 (dynamically sized types)
* 進階函式與閉包：函式指標 (function pointers) 和回傳閉包
* Macros：在編譯時定義更多程式碼的方法

這是 Rust 功能的百科全書，每個 Rust 開發者都能從中受益！讓我們深入探討吧！

## Unsafe Rust

我們到目前為止討論過的所有程式碼，其 Rust 記憶體安全保證都是在編譯時強制執行的。然而，Rust 內部隱藏著另一種語言，它不強制執行這些記憶體安全保證：它被稱為 *unsafe Rust*，其運作方式與一般 Rust 相同，但賦予我們額外的超能力。

Unsafe Rust 之所以存在，是因為靜態分析本質上是保守的。當編譯器嘗試判斷程式碼是否符合保證時，它寧願拒絕一些有效的程式，也不願接受一些無效的程式。儘管程式碼*可能*沒問題，但如果 Rust 編譯器沒有足夠的資訊來確定，它就會拒絕該程式碼。在這些情況下，你可以使用 unsafe 程式碼來告訴編譯器：「相信我，我知道我在做什麼。」然而，請注意，使用 unsafe Rust 需自擔風險：如果你錯誤地使用 unsafe 程式碼，可能會因記憶體不安全而導致問題，例如 null pointer dereferencing。

Rust 還有一個 unsafe 分身的原因是，底層的電腦硬體本質上就是不安全的。如果 Rust 不允許你執行 unsafe 操作，你就無法完成某些任務。Rust 需要允許你進行底層系統程式設計，例如直接與作業系統互動，甚至編寫自己的作業系統。與底層系統程式設計協作是該語言的目標之一。讓我們來探索一下我們能用 unsafe Rust 做什麼，以及如何做到。

### Unsafe 超能力

要切換到 unsafe Rust，請使用 `unsafe` 關鍵字，然後開始一個包含 unsafe 程式碼的新 block。你可以在 unsafe Rust 中執行五種在 safe Rust 中無法執行的動作，我們稱之為 *unsafe 超能力*。這些超能力包括：

1. Dereference 原始指標 (raw pointer)
1. 呼叫 unsafe 函式或方法
1. 存取或修改可變的 static 變數
1. 實作 unsafe trait
1. 存取 `union` 的欄位

重要的是要理解 `unsafe` 並不會關閉 borrow checker 或禁用 Rust 的任何其他安全檢查：如果你在 unsafe 程式碼中使用 reference，它仍然會被檢查。`unsafe` 關鍵字只賦予你存取這五個特性的權限，而這些特性則不受編譯器的記憶體安全檢查。你仍然會在 `unsafe` block 內部獲得一定程度的安全性。

此外，`unsafe` 不代表該 block 內的程式碼必然危險或一定會發生記憶體安全問題：其用意是，身為程式設計師，你將確保 `unsafe` block 內的程式碼會以有效的方式存取記憶體。

人難免犯錯，錯誤總會發生，但透過要求這五個 unsafe 操作必須位於帶有 `unsafe` 標註的 block 內，你就會知道任何與記憶體安全相關的錯誤都必須發生在 `unsafe` block 內。請保持 `unsafe` block 盡可能小；當你日後調查記憶體錯誤時，你會因此而慶幸。

為了盡可能隔離 unsafe 程式碼，最好將此類程式碼封裝在一個安全的抽象中，並提供一個安全的 API，我們將在本章後面討論 unsafe 函式和方法時詳細介紹。標準函式庫的某些部分就是透過對經過審計的 unsafe 程式碼進行安全抽象來實作的。將 unsafe 程式碼包裝在安全抽象中，可以防止 `unsafe` 的使用洩漏到你或你的使用者可能希望使用 `unsafe` 程式碼實作的功能的所有地方，因為使用安全抽象是安全的。

讓我們逐一檢視這五個 unsafe 超能力。我們還將探討一些為 unsafe 程式碼提供安全介面的抽象。

### Dereferencing 原始指標

在第 4 章的「[Dangling References](https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html#dangling-references)」中，我們提到編譯器會確保 reference 總是有效的。Unsafe Rust 有兩種新的型別，稱為 *原始指標 (raw pointers)*，它們與 reference 類似。與 reference 一樣，原始指標可以是 immutable 或 mutable，分別寫作 `*const T` 和 `*mut T`。星號不是 dereference operator；它是型別名稱的一部分。在原始指標的上下文中，*immutable* 表示指標在 dereferenced 後不能直接被賦值。

與 reference 和 smart pointers 不同，原始指標：

* 允許忽略借用規則，可以同時擁有 immutable 和 mutable 指標，或多個 mutable 指標指向同一位置
* 不保證指向有效的記憶體
* 允許為 null
* 不實作任何自動清理

透過選擇不讓 Rust 強制執行這些保證，你可以放棄保證的安全性，以換取更高的效能，或與 Rust 的保證不適用的其他語言或硬體介接的能力。

程式碼清單 20-1 顯示了如何建立 immutable 和 mutable 原始指標。

```rust
    let mut num = 5;

    let r1 = &raw const num;
    let r2 = &raw mut num;
```

程式碼清單 20-1：使用原始借用運算子建立原始指標

請注意，我們沒有在此程式碼中包含 `unsafe` 關鍵字。我們可以在 safe 程式碼中建立原始指標；只是我們不能在 `unsafe` block 外部 dereference 原始指標，如你稍後將看到的那樣。

我們使用原始借用運算子建立原始指標：`&raw const num` 建立一個 `*const i32` 的 immutable 原始指標，而 `&raw mut num` 建立一個 `*mut i32` 的 mutable 原始指標。因為我們直接從 local 變數建立它們，所以我們知道這些特定的原始指標是有效的，但我們不能對任何原始指標都做出這樣的假設。

為了證明這一點，接下來我們將建立一個我們無法確定其有效性的原始指標，方法是使用關鍵字 `as` 來 cast 值，而不是使用原始借用運算子。程式碼清單 20-2 顯示了如何建立指向記憶體中任意位置的原始指標。嘗試使用任意記憶體是 undefined 的：該位址可能有資料，也可能沒有；編譯器可能會最佳化程式碼，使其不存取記憶體；或者程式可能會因 segmentation fault 而終止。通常，沒有充分的理由編寫這樣的程式碼，尤其是在可以使用原始借用運算子的情況下，但這是可能的。

```rust
    let address = 0x012345usize;
    let r = address as *const i32;
```

程式碼清單 20-2：建立指向任意記憶體位址的原始指標

回想一下，我們可以在 safe 程式碼中建立原始指標，但我們不能 *dereference* 原始指標並讀取所指向的資料。在程式碼清單 20-3 中，我們在原始指標上使用了 dereference operator `*`，這需要一個 `unsafe` block。

```rust
    let mut num = 5;

    let r1 = &raw const num;
    let r2 = &raw mut num;

    unsafe {
        println!("r1 is: {}", *r1);
        println!("r2 is: {}", *r2);
    }
```

程式碼清單 20-3：在 `unsafe` block 內 dereferencing 原始指標

建立指標並無害處；只有當我們嘗試存取其指向的值時，我們才可能最終處理無效值。

另請注意，在程式碼清單 20-1 和 20-3 中，我們建立了 `*const i32` 和 `*mut i32` 原始指標，它們都指向相同的記憶體位置，其中儲存了 `num`。如果我們嘗試改為建立 `num` 的 immutable 和 mutable reference，程式碼將不會編譯，因為 Rust 的 ownership 規則不允許同時存在 mutable reference 和任何 immutable reference。使用原始指標，我們可以建立指向相同位置的 mutable 指標和 immutable 指標，並透過 mutable 指標更改資料，潛在地產生 data race。務必小心！

既然有這麼多危險，你為什麼還要使用原始指標呢？一個主要的使用案例是與 C 程式碼介接時，如你將在下一節中看到的。另一個案例是建立 borrow checker 無法理解的安全抽象。我們將介紹 unsafe 函式，然後看看一個使用 unsafe 程式碼的安全抽象範例。

### 呼叫 Unsafe 函式或方法

你可以在 unsafe block 中執行的第二種類型的操作是呼叫 unsafe 函式。Unsafe 函式和方法看起來與一般函式和方法完全相同，但在定義的其餘部分之前多了一個 `unsafe` 關鍵字。此上下文中的 `unsafe` 關鍵字表示函式具有我們在呼叫此函式時需要遵守的要求，因為 Rust 無法保證我們已滿足這些要求。透過在 `unsafe` block 內呼叫 unsafe 函式，我們表示我們已閱讀此函式的說明文件，並承擔遵守函式契約的責任。

這是一個名為 `dangerous` 的 unsafe 函式，其函式體沒有做任何事情：

```rust
    unsafe fn dangerous() {}

    unsafe {
        dangerous();
    }
```

我們必須在單獨的 `unsafe` block 內呼叫 `dangerous` 函式。如果我們嘗試在沒有 `unsafe` block 的情況下呼叫 `dangerous`，我們會得到一個錯誤：

```
$ cargo run
   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)
error[E0133]: call to unsafe function `dangerous` is unsafe and requires unsafe block
 --> src/main.rs:4:5
  |
4 |     dangerous();
  |     ^^^^^^^^^^^ call to unsafe function
  |
  = note: consult the function's documentation for information on how to avoid undefined behavior

For more information about this error, try `rustc --explain E0133`.
error: could not compile `unsafe-example` (bin "unsafe-example") due to 1 previous error
```

有了 `unsafe` block，我們向 Rust 斷言我們已閱讀了函式的說明文件，我們了解如何正確使用它，並且我們已驗證我們正在履行函式的契約。

要在 `unsafe` 函式的主體中執行 unsafe 操作，你仍然需要使用 `unsafe` block，就像在一般函式中一樣，如果你忘記了，編譯器會警告你。這有助於我們盡可能地縮小 `unsafe` block 的範圍，因為 unsafe 操作可能不需要遍及整個函式主體。

#### 建立安全抽象以包裝 Unsafe 程式碼

僅僅因為一個函式包含 unsafe 程式碼，並不代表我們需要將整個函式標記為 unsafe。事實上，將 unsafe 程式碼包裝在安全函式中是一種常見的抽象。舉例來說，讓我們研究標準函式庫中的 `split_at_mut` 函式，它需要一些 unsafe 程式碼。我們將探討如何實作它。這個安全方法是在 mutable slices 上定義的：它接受一個 slice 並透過在給定索引處將 slice 分割成兩個。程式碼清單 20-4 顯示了如何使用 `split_at_mut`。

```rust
    let mut v = vec![1, 2, 3, 4, 5, 6];

    let r = &mut v[..];

    let (a, b) = r.split_at_mut(3);

    assert_eq!(a, &mut [1, 2, 3]);
    assert_eq!(b, &mut [4, 5, 6]);
```

程式碼清單 20-4：使用安全的 `split_at_mut` 函式

我們無法僅使用 safe Rust 實作此函式。嘗試可能類似程式碼清單 20-5，但它無法編譯。為簡化起見，我們將 `split_at_mut` 實作為函式而不是方法，並且僅適用於 `i32` 值的 slices，而不是通用型別 `T`。

```rust
fn split_at_mut(values: &mut [i32], mid: usize) -> (&mut [i32], &mut [i32]) {
    let len = values.len();

    assert!(mid <= len);

    (&mut values[..mid], &mut values[mid..])
}
```

程式碼清單 20-5：嘗試僅使用 safe Rust 實作 `split_at_mut`

這個函式首先取得 slice 的總長度。然後它透過檢查參數所給定的索引是否小於或等於長度，來斷言該索引是否在 slice 內。此斷言表示如果我們傳遞一個大於長度來分割 slice 的索引，函式將在嘗試使用該索引之前 panic。

然後我們在一個 tuple 中回傳兩個 mutable slices：一個從原始 slice 的開頭到 `mid` 索引，另一個從 `mid` 到 slice 的結尾。

當我們嘗試編譯程式碼清單 20-5 中的程式碼時，我們會得到一個錯誤：

```
$ cargo run
   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)
error[E0499]: cannot borrow `*values` as mutable more than once at a time
 --> src/main.rs:6:31
  |
1 | fn split_at_mut(values: &mut [i32], mid: usize) -> (&mut [i32], &mut [i32]) {
  |                         - let's call the lifetime of this reference `'1`
...
6 |     (&mut values[..mid], &mut values[mid..])
  |     --------------------------^^^^^^--------
  |     |     |                   |
  |     |     |                   second mutable borrow occurs here
  |     |     first mutable borrow occurs here
  |     returning this value requires that `*values` is borrowed for `'1`
  |
  = help: use `.split_at_mut(position)` to obtain two mutable non-overlapping sub-slices

For more information about this error, try `rustc --explain E0499`.
error: could not compile `unsafe-example` (bin "unsafe-example") due to 1 previous error
```

Rust 的 borrow checker 無法理解我們正在借用 slice 的不同部分；它只知道我們正在從同一個 slice 借用兩次。借用 slice 的不同部分本質上是沒問題的，因為這兩個 slices 不重疊，但 Rust 不夠聰明，無法知道這一點。當我們知道程式碼沒問題，但 Rust 不知道時，就是使用 unsafe 程式碼的時候了。

程式碼清單 20-6 顯示了如何使用 `unsafe` block、原始指標以及一些 unsafe 函式呼叫來使 `split_at_mut` 的實作生效。

```rust
use std::slice;

fn split_at_mut(values: &mut [i32], mid: usize) -> (&mut [i32], &mut [i32]) {
    let len = values.len();
    let ptr = values.as_mut_ptr();

    assert!(mid <= len);

    unsafe {
        (
            slice::from_raw_parts_mut(ptr, mid),
            slice::from_raw_parts_mut(ptr.add(mid), len - mid),
        )
    }
}
```

程式碼清單 20-6：在 `split_at_mut` 函式實作中使用 unsafe 程式碼

回想一下第 4 章「[Slice 型別](https://doc.rust-lang.org/book/ch04-03-slices.html#the-slice-type)」中的內容，一個 slice 是一個指向某些資料的指標和 slice 的長度。我們使用 `len` 方法來取得 slice 的長度，並使用 `as_mut_ptr` 方法來存取 slice 的原始指標。在這個案例中，因為我們有一個指向 `i32` 值的 mutable slice，`as_mut_ptr` 會回傳型別為 `*mut i32` 的原始指標，我們將其儲存在 `ptr` 變數中。

我們保留 `mid` 索引在 slice 內的斷言。然後我們進入 unsafe 程式碼：`slice::from_raw_parts_mut` 函式接受一個原始指標和一個長度，並建立一個 slice。我們使用這個函式建立一個從 `ptr` 開始、長度為 `mid` 個項目的 slice。然後我們在 `ptr` 上呼叫 `add` 方法，以 `mid` 作為參數來取得一個從 `mid` 開始的原始指標，並使用該指標和 `mid` 之後的剩餘項目數作為長度來建立一個 slice。

函式 `slice::from_raw_parts_mut` 是 unsafe 的，因為它接受一個原始指標，並且必須相信這個指標是有效的。原始指標上的 `add` 方法也是 unsafe 的，因為它必須相信 offset 位置也是一個有效的指標。因此，我們必須在對 `slice::from_raw_parts_mut` 和 `add` 的呼叫周圍放置一個 `unsafe` block，以便我們可以呼叫它們。透過查看程式碼並添加 `mid` 必須小於或等於 `len` 的斷言，我們可以判斷在 `unsafe` block 內使用的所有原始指標都將是 slice 內資料的有效指標。這是一個可接受且適當的 `unsafe` 用法。

請注意，我們不需要將產生的 `split_at_mut` 函式標記為 `unsafe`，我們可以從 safe Rust 呼叫此函式。我們已經透過一個函式實作，該函式以安全的方式使用 `unsafe` 程式碼，因為它僅從該函式有權存取的資料中建立有效指標，從而為 unsafe 程式碼建立了一個安全抽象。

相反地，程式碼清單 20-7 中 `slice::from_raw_parts_mut` 的使用，當 slice 被使用時，很可能會導致程式崩潰。這段程式碼取得一個任意的記憶體位置，並建立一個長度為 10,000 個項目的 slice。

```rust
    use std::slice;

    let address = 0x01234usize;
    let r = address as *mut i32;

    let values: &[i32] = unsafe { slice::from_raw_parts_mut(r, 10000) };
```

程式碼清單 20-7：從任意記憶體位置建立 slice

我們不擁有這個任意位置的記憶體，而且無法保證這段程式碼建立的 slice 包含有效的 `i32` 值。嘗試將 `values` 視為有效的 slice 使用會導致 undefined behavior。

#### 使用 extern 函式呼叫外部程式碼

有時你的 Rust 程式碼可能需要與以其他語言編寫的程式碼互動。為此，Rust 有一個 `extern` 關鍵字，可以促進 *外部函式介面 (Foreign Function Interface，FFI)* 的建立和使用，這是一種程式語言定義函式並啟用不同的（外部）程式語言來呼叫這些函式的方式。

程式碼清單 20-8 展示了如何設定與 C 標準函式庫中 `abs` 函式的整合。在 `extern` block 中宣告的函式通常在 Rust 程式碼中呼叫是不安全的，因此 `extern` block 也必須標記為 `unsafe`。原因在於其他語言不強制執行 Rust 的規則和保證，Rust 也無法檢查它們，因此確保安全的責任落在了程式設計師身上。

src/main.rs

```rust
unsafe extern "C" {
    fn abs(input: i32) -> i32;
}

fn main() {
    unsafe {
        println!("Absolute value of -3 according to C: {}", abs(-3));
    }
}
```

程式碼清單 20-8：宣告和呼叫在另一種語言中定義的 `extern` 函式

在 `unsafe extern "C"` block 內，我們列出了我們想要呼叫的其他語言的外部函式的名稱和簽名。`"C"` 部分定義了外部函式使用的 *應用程式二進位介面 (application binary interface, ABI)*：ABI 定義了如何在組譯層級呼叫函式。`"C"` ABI 是最常見的，並遵循 C 程式語言的 ABI。有關 Rust 支援的所有 ABI 的資訊可在 Rust Reference 的 *[../reference/items/external-blocks.html#abi](https://doc.rust-lang.org/reference/items/external-blocks.html#abi)* 中找到。

在 `unsafe extern` block 中宣告的每個項目都是隱式 unsafe 的。然而，有些 FFI 函式*是*安全的呼叫。例如，C 標準函式庫中的 `abs` 函式沒有任何記憶體安全考量，我們知道它可以與任何 `i32` 呼叫。在這種情況下，我們可以使 `safe` 關鍵字來表示這個特定函式即使在 `unsafe extern` block 中也是安全的呼叫。一旦我們進行了該變更，呼叫它就不再需要 `unsafe` block，如程式碼清單 20-9 所示。

src/main.rs

```rust
unsafe extern "C" {
    safe fn abs(input: i32) -> i32;
}

fn main() {
    println!("Absolute value of -3 according to C: {}", abs(-3));
}
```

程式碼清單 20-9：在 `unsafe extern` block 中明確將函式標記為 `safe` 並安全地呼叫它

將函式標記為 `safe` 本身並不會使其變得安全！相反地，這就像你對 Rust 許下一個它是安全的承諾。確保這個承諾被遵守仍然是你的責任！

#### 從其他語言呼叫 Rust 函式

我們也可以使用 `extern` 來建立一個介面，讓其他語言能夠呼叫 Rust 函式。我們不需要建立一個完整的 `extern` block，只需在相關函式的 `fn` 關鍵字之前加入 `extern` 關鍵字並指定要使用的 ABI。我們還需要加入 `#[unsafe(no_mangle)]` 註解，以告知 Rust 編譯器不要混淆 (mangle) 此函式的名稱。*混淆 (Mangling)* 是指編譯器將我們給函式的名稱變更為另一個名稱，其中包含更多資訊供編譯過程的其他部分使用，但可讀性較差。每個程式語言編譯器混淆名稱的方式略有不同，因此要讓 Rust 函式可由其他語言命名，我們必須禁用 Rust 編譯器的名稱混淆。這是不安全的，因為在沒有內建混淆的情況下，函式庫之間可能會發生名稱衝突，因此我們有責任確保我們選擇的名稱在沒有混淆的情況下安全地匯出。

在以下範例中，我們使 `call_from_c` 函式在編譯為共享函式庫並從 C 連結後，可從 C 程式碼存取：

```rust
#[unsafe(no_mangle)]
pub extern "C" fn call_from_c() {
    println!("Just called a Rust function from C!");
}
```

這種 `extern` 的用法只需要在 attribute 中使用 `unsafe`，而不是在 `extern` block 上。

### 存取或修改可變的 Static 變數

在本書中，我們還沒有討論全域變數 (global variables)，雖然 Rust 支援它們，但它們可能與 Rust 的 ownership 規則產生問題。如果兩個執行緒同時存取同一個可變全域變數，可能會導致 data race。

在 Rust 中，全域變數被稱為 *static 變數*。程式碼清單 20-10 顯示了一個 static 變數的宣告和使用範例，其值為字串 slice。

src/main.rs

```rust
static HELLO_WORLD: &str = "Hello, world!";

fn main() {
    println!("value is: {HELLO_WORLD}");
}
```

程式碼清單 20-10：定義和使用 Immutable Static 變數

Static 變數與我們在第 3 章「[常數](https://doc.rust-lang.org/book/ch03-02-data-types.html#constants)」中討論的常數類似。根據慣例，Static 變數的名稱採用 `SCREAMING_SNAKE_CASE` 命名。Static 變數只能儲存具有 `'static` lifetime 的 reference，這表示 Rust 編譯器可以計算出 lifetime，我們不需要明確地標註它。存取 immutable static 變數是安全的。

常數和 immutable static 變數之間的一個細微差異是，static 變數中的值在記憶體中具有固定位址。使用該值將始終存取相同的資料。另一方面，常數允許在使用時複製其資料。另一個差異是 static 變數可以是 mutable 的。存取和修改 mutable static 變數是 *unsafe* 的。程式碼清單 20-11 顯示了如何宣告、存取和修改一個名為 `COUNTER` 的 mutable static 變數。

src/main.rs

```rust
static mut COUNTER: u32 = 0;

/// SAFETY: Calling this from more than a single thread at a time is undefined
/// behavior, so you *must* guarantee you only call it from a single thread at
/// a time.
unsafe fn add_to_count(inc: u32) {
    unsafe {
        COUNTER += inc;
    }
}

fn main() {
    unsafe {
        // SAFETY: This is only called from a single thread in `main`.
        add_to_count(3);
        println!("COUNTER: {}", *(&raw const COUNTER));
    }
}
```

程式碼清單 20-11：讀取或寫入可變的 static 變數是不安全的。

與一般變數一樣，我們使用 `mut` 關鍵字來指定可變性。任何從 `COUNTER` 讀取或寫入的程式碼都必須位於 `unsafe` block 內。程式碼清單 20-11 編譯並印出 `COUNTER: 3`，這符合我們的預期，因為它是單執行緒的。多個執行緒存取 `COUNTER` 很可能會導致 data race，因此它是 undefined behavior。因此，我們需要將整個函式標記為 `unsafe`，並記載安全限制，以便任何呼叫該函式的人都知道他們可以安全地做什麼和不允許做什麼。

無論何時編寫 unsafe 函式，習慣上都會以 `SAFETY` 開頭撰寫註解，並解釋呼叫者需要做什麼才能安全地呼叫函式。同樣地，無論何時執行 unsafe 操作，習慣上都會以 `SAFETY` 開頭撰寫註解，以解釋安全規則是如何遵守的。

此外，編譯器預設會透過編譯器 lint 拒絕任何嘗試透過 mutable static 變數建立 reference 的行為。你必須明確地選擇不使用該 lint 的保護，方法是添加 `#[allow(static_mut_refs)]` 註解，或者透過使用其中一個原始借用運算子建立的原始指標存取 mutable static 變數。這包括 reference 無形中建立的情況，例如在程式碼清單中的 `println!` 中使用時。要求透過原始指標建立對 static mutable 變數的 reference 有助於使使用它們的安全要求更加明顯。

由於可變資料是全域可存取的，很難確保沒有 data race，這就是為什麼 Rust 將 mutable static 變數視為 unsafe 的原因。在可能的情況下，最好使用我們在第 16 章中討論的[並行技術和執行緒安全 smart pointers](https://doc.rust-lang.org/book/ch16-00-concurrency.html)，以便編譯器檢查來自不同執行緒的資料存取是否安全。

### 實作 Unsafe Trait

我們可以利用 `unsafe` 來實作 unsafe trait。當 trait 的至少一個方法具有編譯器無法驗證的 invariant 時，該 trait 就是 unsafe 的。我們透過在 `trait` 之前添加 `unsafe` 關鍵字，並也將 trait 的實作標記為 `unsafe`，如程式碼清單 20-12 所示。

```rust
unsafe trait Foo {
    // methods go here
}

unsafe impl Foo for i32 {
    // method implementations go here
}
```

程式碼清單 20-12：定義和實作 unsafe trait

透過使用 `unsafe impl`，我們承諾將遵守編譯器無法驗證的 invariant。

舉例來說，回想一下我們在第 16 章「[使用 `Send` 和 `Sync` Traits 擴充並行性](https://doc.rust-lang.org/book/ch16-04-extensible-concurrency-with-traits.html#extensible-concurrency-with-the-send-and-sync-traits)」中討論的 `Send` 和 `Sync` 標記 traits：如果我們的型別完全由實作 `Send` 和 `Sync` 的其他型別組成，編譯器會自動實作這些 traits。如果我們實作一個包含未實作 `Send` 或 `Sync` 的型別（例如原始指標）的型別，並且我們想要將該型別標記為 `Send` 或 `Sync`，我們就必須使用 `unsafe`。Rust 無法驗證我們的型別是否遵守了可以安全地在執行緒之間傳送或從多個執行緒存取的保證；因此，我們需要手動執行這些檢查，並透過 `unsafe` 指示出來。

### 存取 Union 的欄位

最後一個只有在 `unsafe` 下才能執行的動作是存取 union 的欄位。*Union* 類似於 `struct`，但每次在特定 instance 中只會使用一個宣告的欄位。Union 主要用於與 C 程式碼中的 union 介面。存取 union 欄位是不安全的，因為 Rust 無法保證目前儲存在 union instance 中的資料型別。你可以在 Rust Reference 的 *[../reference/items/unions.html](https://doc.rust-lang.org/reference/items/unions.html)* 中了解更多關於 union 的資訊。

### 使用 Miri 檢查 Unsafe 程式碼

編寫 unsafe 程式碼時，你可能想檢查你所編寫的程式碼是否確實安全且正確。最好的方法之一就是使用 Miri，這是一個用於偵測 undefined behavior 的官方 Rust 工具。借用檢查器 (borrow checker) 是一個在編譯時運作的*靜態*工具，而 Miri 是一個在執行時運作的*動態*工具。它透過執行你的程式或其測試套件來檢查你的程式碼，並在你違反它所理解的 Rust 運作規則時偵測到。

使用 Miri 需要 Rust 的 nightly build (我們在附錄 G「[Rust 如何製作以及 Nightly Rust](https://doc.rust-lang.org/book/appendix-07-nightly-rust.html)」中對此有更多討論)。你可以透過輸入 `rustup +nightly component add miri` 來安裝 Rust 的 nightly 版本和 Miri 工具。這不會改變你的專案使用的 Rust 版本；它只是將工具添加到你的系統中，以便你可以在需要時使用它。你可以透過輸入 `cargo +nightly miri run` 或 `cargo +nightly miri test` 在專案上執行 Miri。

作為一個例子，讓我們看看當我們對程式碼清單 20-7 執行它時會發生什麼。

```
$ cargo +nightly miri run
   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.01s
     Running `file:///home/.rustup/toolchains/nightly-aarch64-apple-darwin/bin/cargo-miri runner target/miri/aarch64-apple-darwin/debug/unsafe-example`
warning: integer-to-pointer cast
 --> src/main.rs:6:13
  |
6 |     let r = address as *mut i32;
  |             ^^^^^^^^^^^^^^^^^^^ integer-to-pointer cast
  |
  = help: this program is using integer-to-pointer casts or (equivalently) `ptr::with_exposed_provenance`, which means that Miri might miss pointer bugs in this program
  = help: see https://doc.rust-lang.org/nightly/std/ptr/fn.with_exposed_provenance.html for more details on that operation
  = help: to ensure that Miri does not miss bugs in your program, use Strict Provenance APIs (https://doc.rust-lang.org/nightly/std/ptr/index.html#strict-provenance, https://crates.io/crates/sptr) instead
  = help: you can then set `MIRIFLAGS=-Zmiri-strict-provenance` to ensure you are not relying on `with_exposed_provenance` semantics
  = help: alternatively, `MIRIFLAGS=-Zmiri-permissive-provenance` disables this warning
  = note: BACKTRACE:
  = note: inside `main` at src/main.rs:6:13: 6:32

error: Undefined Behavior: pointer not dereferenceable: pointer must be dereferenceable for 40000 bytes, but got 0x1234[noalloc] which is a dangling pointer (it has no provenance)
 --> src/main.rs:8:35
  |
8 |     let values: &[i32] = unsafe { slice::from_raw_parts_mut(r, 10000) };
  |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Undefined Behavior occurred here
  |
  = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior
  = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information
  = note: BACKTRACE:
  = note: inside `main` at src/main.rs:8:35: 8:70

note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace

error: aborting due to 1 previous error; 1 warning emitted

```

Miri 正確地警告我們正在將一個整數 cast 為指標，這可能是一個問題，但 Miri 無法偵測它是否存在問題，因為它不知道指標是如何產生的。然後，Miri 會回傳一個錯誤，指出程式碼清單 20-7 存在 undefined behavior，因為我們有一個 dangling pointer。感謝 Miri，我們現在知道存在 undefined behavior 的風險，我們可以思考如何使程式碼安全。在某些情況下，Miri 甚至可以就如何修正錯誤提出建議。

Miri 並不能捕獲你在編寫 unsafe 程式碼時可能出錯的所有問題。Miri 是一種動態分析工具，因此它只捕獲實際執行的程式碼中的問題。這意味著你需要將它與良好的測試技術結合使用，以增加你對所編寫的 unsafe 程式碼的信心。Miri 也不涵蓋程式碼可能不健全的所有可能方式。

換句話說：如果 Miri *確實*捕獲到一個問題，你就知道存在 bug，但僅僅因為 Miri *沒有*捕獲到 bug 並不代表沒有問題。儘管如此，它還是可以捕獲很多問題。試著在這些章節的其他 unsafe 程式碼範例上執行它，看看它會說什麼！

你可以在 Miri 的 GitHub 儲存庫 *[https://github.com/rust-lang/miri](https://github.com/rust-lang/miri)* 中了解更多資訊。

### 何時使用 Unsafe 程式碼

使用 `unsafe` 來使用我們剛才討論的五個超能力並沒有錯，甚至也沒有被禁止，但要正確地編寫 `unsafe` 程式碼會更棘手，因為編譯器無法幫助維護記憶體安全性。當你有理由使用 `unsafe` 程式碼時，你可以這樣做，而且明確的 `unsafe` 註解使得在問題發生時更容易追蹤問題來源。無論何時編寫 unsafe 程式碼，你都可以使用 Miri 來幫助你更確信所編寫的程式碼遵守了 Rust 的規則。

要更深入地探索如何有效地使用 unsafe Rust，請閱讀 Rust 的官方指南，即 Rustonomicon，網址為 *[https://doc.rust-lang.org/nomicon/](https://doc.rust-lang.org/nomicon/)*。

## 進階 Traits

我們首次在第 10 章「[Traits：定義共用行為](https://doc.rust-lang.org/book/ch10-02-traits.html#traits-defining-shared-behavior)」中介紹了 traits，但我們沒有討論更進階的細節。現在你對 Rust 有了更多了解，我們可以深入探討其細微之處了。

<a id="specifying-placeholder-types-in-trait-definitions-with-associated-types"></a>

### 關聯型別 (Associated Types)

*關聯型別 (Associated types)* 將型別 placeholder 與 trait 連接起來，以便 trait 方法定義可以在其簽名中使用這些 placeholder 型別。trait 的實作者將指定要使用的具體型別，而不是特定實作的 placeholder 型別。這樣，我們就可以定義一個使用某些型別的 trait，而無需在 trait 實作之前確切知道這些型別是什麼。

我們將本章中的大多數進階功能描述為很少需要。關聯型別介於中間：它們比書中其餘部分解釋的功能使用頻率更低，但比本章討論的許多其他功能更常用。

帶有關聯型別的 trait 的一個範例是標準函式庫提供的 `Iterator` trait。關聯型別名為 `Item`，代表實作 `Iterator` trait 的型別正在迭代的值的型別。`Iterator` trait 的定義如程式碼清單 20-13 所示。

```rust
pub trait Iterator {
    type Item;

    fn next(&mut self) -> Option<Self::Item>;
}
```

程式碼清單 20-13：具有關聯型別 `Item` 的 `Iterator` trait 的定義

型別 `Item` 是一個 placeholder，而 `next` 方法的定義顯示它將回傳 `Option<Self::Item>` 型別的值。`Iterator` trait 的實作者將為 `Item` 指定具體型別，而 `next` 方法將回傳包含該具體型別值的 `Option`。

關聯型別可能看起來與泛型 (generics) 的概念類似，因為泛型允許我們在不指定其可以處理的型別的情況下定義函式。為了檢視這兩個概念之間的差異，我們將查看在名為 `Counter` 的型別上實作 `Iterator` trait 的情況，該型別指定 `Item` 型別為 `u32`：

src/lib.rs

```rust
impl Iterator for Counter {
    type Item = u32;

    fn next(&mut self) -> Option<Self::Item> {
        // --snip--
```

這種語法看起來與泛型語法類似。那麼為什麼不只用泛型來定義 `Iterator` trait，如程式碼清單 20-14 所示呢？

```rust
pub trait Iterator<T> {
    fn next(&mut self) -> Option<T>;
}
```

程式碼清單 20-14：使用泛型來定義 `Iterator` trait 的假設性範例

不同之處在於，當使用泛型（如程式碼清單 20-14 所示）時，我們必須在每個實作中註解型別；因為我們也可以為 `Counter` 實作 `Iterator<String>` 或任何其他型別，所以我們可能為 `Counter` 實作多個 `Iterator`。換句話說，當一個 trait 具有泛型參數時，它可以為一個型別實作多次，每次都變更泛型型別參數的具體型別。當我們在 `Counter` 上使用 `next` 方法時，我們必須提供型別註解以指示我們要使用哪個 `Iterator` 實作。

透過關聯型別，我們不需要註解型別，因為我們無法多次為一個型別實作 trait。在程式碼清單 20-13 中，使用關聯型別的定義，我們只能選擇一次 `Item` 的型別，因為 `impl Iterator for Counter` 只能有一個。我們無需在每次呼叫 `Counter` 上的 `next` 時指定我們要的是 `u32` 值的 iterator。

關聯型別也成為 trait 契約的一部分：trait 的實作者必須提供一個型別來替代關聯型別 placeholder。關聯型別通常有一個描述型別如何使用的名稱，在 API 說明文件中記錄關聯型別是個好習慣。

### 預設泛型型別參數和運算子重載

當我們使用泛型型別參數時，我們可以為泛型型別指定一個預設具體型別。這消除了 trait 實作者在預設型別適用時指定具體型別的需要。你可以在宣告泛型型別時使用 `<PlaceholderType=ConcreteType>` 語法來指定預設型別。

這種技術有用的一個很好的例子是*運算子重載 (operator overloading)*，其中你在特定情況下自訂運算子（例如 `+`）的行為。

Rust 不允許你建立自己的運算子或重載任意運算子。但你可以透過實作與運算子相關的 traits 來重載 `std::ops` 中列出的操作和相應的 traits。例如，在程式碼清單 20-15 中，我們重載 `+` 運算子以將兩個 `Point` 實例相加。我們透過在 `Point` struct 上實作 `Add` trait 來做到這一點。

src/main.rs

```rust
use std::ops::Add;

#[derive(Debug, Copy, Clone, PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Output = Point;

    fn add(self, other: Point) -> Point {
        Point {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

fn main() {
    assert_eq!(
        Point { x: 1, y: 0 } + Point { x: 2, y: 3 },
        Point { x: 3, y: 3 }
    );
}
```

程式碼清單 20-15：實作 `Add` trait 以為 `Point` 實例重載 `+` 運算子

`add` 方法將兩個 `Point` 實例的 `x` 值和兩個 `Point` 實例的 `y` 值相加，以建立一個新的 `Point`。`Add` trait 有一個名為 `Output` 的關聯型別，它決定了 `add` 方法的回傳型別。

此程式碼中的預設泛型型別位於 `Add` trait 中。這是它的定義：

```rust
trait Add<Rhs=Self> {
    type Output;

    fn add(self, rhs: Rhs) -> Self::Output;
}
```

這段程式碼看起來應該大致熟悉：一個帶有一個方法和一個關聯型別的 trait。新的部分是 `Rhs=Self`：這種語法稱為 *default type parameters (預設型別參數)*。`Rhs` 泛型型別參數（“right-hand side” 的縮寫）定義了 `add` 方法中 `rhs` 參數的型別。如果我們在實作 `Add` trait 時沒有為 `Rhs` 指定具體型別，`Rhs` 的型別將預設為 `Self`，也就是我們正在實作 `Add` 的型別。

當我們為 `Point` 實作 `Add` 時，我們使用了 `Rhs` 的預設值，因為我們想要將兩個 `Point` 實例相加。讓我們看一個實作 `Add` trait 的範例，其中我們想要自訂 `Rhs` 型別，而不是使用預設值。

我們有兩個 struct，`Millimeters` 和 `Meters`，分別儲存不同單位的值。這種將現有型別薄包裝在另一個 struct 中的方式稱為 *newtype pattern*，我們將在「[使用 Newtype Pattern 實作外部 Trait](https://doc.rust-lang.org/book/ch20-03-advanced-types.html#using-the-newtype-pattern-to-implement-external-traits-on-external-types)」一節中詳細說明。我們想要將毫米值加到公尺值，並讓 `Add` 的實作正確地進行轉換。我們可以為 `Millimeters` 實作 `Add`，並將 `Meters` 作為 `Rhs`，如程式碼清單 20-16 所示。

src/lib.rs

```rust
use std::ops::Add;

struct Millimeters(u32);
struct Meters(u32);

impl Add<Meters> for Millimeters {
    type Output = Millimeters;

    fn add(self, other: Meters) -> Millimeters {
        Millimeters(self.0 + (other.0 * 1000))
    }
}
```

程式碼清單 20-16：在 `Millimeters` 上實作 `Add` trait 以將 `Millimeters` 和 `Meters` 相加

為了加總 `Millimeters` 和 `Meters`，我們指定 `impl Add<Meters>` 來設定 `Rhs` 型別參數的值，而不是使用預設的 `Self`。

你將主要以兩種方式使用預設型別參數：

1. 擴展型別而不破壞現有程式碼
1. 允許在大多數使用者不需要的特定情況下進行自訂

標準函式庫的 `Add` trait 是第二個目的的範例：通常，你會將兩個相似型別相加，但 `Add` trait 提供了超越此範圍的自訂能力。在 `Add` trait 定義中使用預設型別參數意味著你大多數時候不必指定額外參數。換句話說，不需要一些實作 boilerplate，這使得使用 trait 更容易。

第一個目的是與第二個類似但相反：如果你想向現有 trait 添加型別參數，你可以給它一個預設值，以允許擴展 trait 的功能而不破壞現有的實作程式碼。

<a id="fully-qualified-syntax-for-disambiguation-calling-methods-with-the-same-name"></a>

### 消除同名方法之間的歧義

Rust 中沒有任何東西會阻止一個 trait 擁有與另一個 trait 的方法同名的方法，Rust 也不會阻止你在一個型別上實作這兩個 trait。直接在型別上實作與 trait 方法同名的方法也是可能的。

呼叫同名方法時，你需要告訴 Rust 你要使用哪一個。考慮程式碼清單 20-17 中的程式碼，我們定義了兩個 trait：`Pilot` 和 `Wizard`，它們都包含一個名為 `fly` 的方法。然後我們在 `Human` 型別上實作這兩個 trait，該型別本身也實作了一個名為 `fly` 的方法。每個 `fly` 方法都做不同的事情。

src/main.rs

```rust
trait Pilot {
    fn fly(&self);
}

trait Wizard {
    fn fly(&self);
}

struct Human;

impl Pilot for Human {
    fn fly(&self) {
        println!("This is your captain speaking.");
    }
}

impl Wizard for Human {
    fn fly(&self) {
        println!("Up!");
    }
}

impl Human {
    fn fly(&self) {
        println!("*waving arms furiously*");
    }
}
```

程式碼清單 20-17：定義了兩個帶有 `fly` 方法的 trait，並在 `Human` 型別上實作，且 `Human` 上也直接實作了一個 `fly` 方法。

當我們在 `Human` 實例上呼叫 `fly` 時，編譯器預設會呼叫直接在該型別上實作的方法，如程式碼清單 20-18 所示。

src/main.rs

```rust
fn main() {
    let person = Human;
    person.fly();
}
```

程式碼清單 20-18：在 `Human` 實例上呼叫 `fly`

執行此程式碼將印出 `*waving arms furiously*`，顯示 Rust 直接呼叫了在 `Human` 上實作的 `fly` 方法。

要從 `Pilot` trait 或 `Wizard` trait 呼叫 `fly` 方法，我們需要使用更明確的語法來指定我們指的是哪個 `fly` 方法。程式碼清單 20-19 演示了這種語法。

src/main.rs

```rust
fn main() {
    let person = Human;
    Pilot::fly(&person);
    Wizard::fly(&person);
    person.fly();
}
```

程式碼清單 20-19：指定我們要呼叫哪個 trait 的 `fly` 方法

在方法名稱前指定 trait 名稱可向 Rust 闡明我們要呼叫哪一個 `fly` 實作。我們也可以寫 `Human::fly(&person)`，這與我們在程式碼清單 20-19 中使用的 `person.fly()` 等效，但如果我們不需要消除歧義，這樣寫會長一點。

執行此程式碼會印出以下內容：

```
$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.46s
     Running `target/debug/traits-example`
This is your captain speaking.
Up!
*waving arms furiously*
```

因為 `fly` 方法接受 `self` 參數，如果我們有兩個*型別*都實作一個*trait*，Rust 可以根據 `self` 的型別來判斷要使用哪個 trait 的實作。

然而，不是方法的關聯函式沒有 `self` 參數。當有多個型別或 trait 定義了同名且非方法函式時，除非你使用完全限定語法，否則 Rust 不總是知道你指的是哪個型別。例如，在程式碼清單 20-20 中，我們為一個動物收容所建立一個 trait，該收容所希望將所有幼犬命名為 Spot。我們建立一個 `Animal` trait，其中包含一個關聯的非方法函式 `baby_name`。`Animal` trait 被實作在 `Dog` struct 上，我們也直接在 `Dog` 上提供了關聯的非方法函式 `baby_name`。

src/main.rs

```rust
trait Animal {
    fn baby_name() -> String;
}

struct Dog;

impl Dog {
    fn baby_name() -> String {
        String::from("Spot")
    }
}

impl Animal for Dog {
    fn baby_name() -> String {
        String::from("puppy")
    }
}

fn main() {
    println!("A baby dog is called a {}", Dog::baby_name());
}
```

程式碼清單 20-20：一個帶有相同名稱的關聯函式，且該型別也實作了該 trait 的 trait 和型別

我們在 `Dog` 上定義的 `baby_name` 關聯函式中實作了命名所有幼犬為 Spot 的程式碼。`Dog` 型別也實作了 `Animal` trait，該 trait 描述了所有動物都具有的特性。幼犬被稱為 puppy，這在 `Animal` trait 在 `Dog` 上的實作中，在與 `Animal` trait 相關的 `baby_name` 函式中表達。

在 `main` 函式中，我們呼叫了 `Dog::baby_name` 函式，它直接呼叫了在 `Dog` 上定義的關聯函式。這段程式碼會印出以下內容：

```
$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.54s
     Running `target/debug/traits-example`
A baby dog is called a Spot
```

這個輸出不是我們想要的。我們想要呼叫在 `Dog` 上實作的 `Animal` trait 中的 `baby_name` 函式，這樣程式碼會印出 `A baby dog is called a puppy`。我們在程式碼清單 20-19 中使用的指定 trait 名稱的技術在這裡沒有幫助；如果我們將 `main` 變更為程式碼清單 20-21 中的程式碼，我們會得到編譯錯誤。

src/main.rs

```rust
fn main() {
    println!("A baby dog is called a {}", Animal::baby_name());
}
```

程式碼清單 20-21：嘗試從 `Animal` trait 呼叫 `baby_name` 函式，但 Rust 不知道要使用哪個實作

因為 `Animal::baby_name` 沒有 `self` 參數，並且可能還有其他型別實作 `Animal` trait，所以 Rust 無法判斷我們想要哪個 `Animal::baby_name` 的實作。我們會得到這個編譯錯誤：

```
$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
error[E0790]: cannot call associated function on trait without specifying the corresponding `impl` type
  --> src/main.rs:20:43
   |
2  |     fn baby_name() -> String;
   |     ------------------------- `Animal::baby_name` defined here
...
20 |     println!("A baby dog is called a {}", Animal::baby_name());
   |                                           ^^^^^^^^^^^^^^^^^^^ cannot call associated function of trait
   |
help: use the fully-qualified path to the only available implementation
   |
20 |     println!("A baby dog is called a {}", <Dog as Animal>::baby_name());
   |                                           +++++++       +

For more information about this error, try `rustc --explain E0790`.
error: could not compile `traits-example` (bin "traits-example") due to 1 previous error
```

為了消除歧義並告訴 Rust 我們想使用 `Dog` 的 `Animal` 實作，而不是其他型別的 `Animal` 實作，我們需要使用完全限定語法。程式碼清單 20-22 演示了如何使用完全限定語法。

src/main.rs

```rust
fn main() {
    println!("A baby dog is called a {}", <Dog as Animal>::baby_name());
}
```

程式碼清單 20-22：使用完全限定語法指定我們要呼叫在 `Dog` 上實作的 `Animal` trait 中的 `baby_name` 函式

我們在尖括號內提供了 Rust 的型別註解，這表示我們希望將 `Dog` 型別視為此函式呼叫的 `Animal`，以呼叫在 `Dog` 上實作的 `Animal` trait 中的 `baby_name` 方法。這段程式碼現在將印出我們想要的結果：

```
$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/traits-example`
A baby dog is called a puppy
```

通常，完全限定語法定義如下：

```rust
<Type as Trait>::function(receiver_if_method, next_arg, ...);
```

對於不是方法的關聯函式，不會有 `receiver`：只會有其他參數的列表。你可以在所有呼叫函式或方法的地方使用完全限定語法。然而，你可以省略 Rust 可以從程式中其他資訊推斷出來的任何部分。你只需要在有多個實作使用相同名稱，且 Rust 需要幫助來識別你想要呼叫哪個實作的情況下，才使用這種更詳細的語法。

<a id="using-supertraits-to-require-one-traits-functionality-within-another-trait"></a>

### 使用 Supertraits

有時你可能會編寫一個 trait 定義，該定義依賴於另一個 trait：為了讓型別實作第一個 trait，你希望要求該型別也實作第二個 trait。這樣做是為了讓你的 trait 定義可以使用第二個 trait 的關聯項目。你的 trait 定義所依賴的 trait 被稱為你自己的 trait 的 *supertrait*。

舉例來說，假設我們想要建立一個 `OutlinePrint` trait，其中包含一個 `outline_print` 方法，該方法會將給定的值格式化為星號框起來。也就是說，給定一個實作標準函式庫 `Display` trait 以產生 `(x, y)` 的 `Point` struct，當我們在 `x` 為 `1` 且 `y` 為 `3` 的 `Point` 實例上呼叫 `outline_print` 時，它應該印出以下內容：

```
**********
*        *
* (1, 3) *
*        *
**********
```

在 `outline_print` 方法的實作中，我們想使用 `Display` trait 的功能。因此，我們需要指定 `OutlinePrint` trait 僅適用於也實作 `Display` 並提供 `OutlinePrint` 所需功能的型別。我們可以在 trait 定義中透過指定 `OutlinePrint: Display` 來做到這一點。這種技術類似於為 trait 添加 trait bound。程式碼清單 20-23 顯示了 `OutlinePrint` trait 的實作。

src/main.rs

```rust
use std::fmt;

trait OutlinePrint: fmt::Display {
    fn outline_print(&self) {
        let output = self.to_string();
        let len = output.len();
        println!("{}", "*".repeat(len + 4));
        println!("*{}*", " ".repeat(len + 2));
        println!("* {output} *");
        println!("*{}*", " ".repeat(len + 2));
        println!("{}", "*".repeat(len + 4));
    }
}
```

程式碼清單 20-23：實作需要 `Display` 功能的 `OutlinePrint` trait

因為我們已經指定 `OutlinePrint` 需要 `Display` trait，所以我們可以像任何實作 `Display` 的型別一樣，使用自動實作的 `to_string` 函式。如果我們嘗試在沒有冒號並在 trait 名稱後指定 `Display` trait 的情況下使用 `to_string`，我們將會收到一個錯誤，指出在當前範圍內沒有找到名為 `to_string` 的方法，其型別為 `&Self`。

讓我們看看當我們嘗試在一個沒有實作 `Display` 的型別（例如 `Point` struct）上實作 `OutlinePrint` 時會發生什麼：

src/main.rs

```rust
struct Point {
    x: i32,
    y: i32,
}

impl OutlinePrint for Point {}
```

我們收到一個錯誤，指出需要 `Display` 但未實作：

```
$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
error[E0277]: `Point` doesn't implement `std::fmt::Display`
  --> src/main.rs:20:23
   |
20 | impl OutlinePrint for Point {}
   |                       ^^^^^ `Point` cannot be formatted with the default formatter
   |
   = help: the trait `std::fmt::Display` is not implemented for `Point`
   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
note: required by a bound in `OutlinePrint`
  --> src/main.rs:3:21
   |
3  | trait OutlinePrint: fmt::Display {
   |                     ^^^^^^^^^^^^ required by this bound in `OutlinePrint`

error[E0277]: `Point` doesn't implement `std::fmt::Display`
  --> src/main.rs:24:7
   |
24 |     p.outline_print();
   |       ^^^^^^^^^^^^^ `Point` cannot be formatted with the default formatter
   |
   = help: the trait `std::fmt::Display` is not implemented for `Point`
   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
note: required by a bound in `OutlinePrint::outline_print`
  --> src/main.rs:3:21
   |
3  | trait OutlinePrint: fmt::Display {
   |                     ^^^^^^^^^^^^ required by this bound in `OutlinePrint::outline_print`
4  |     fn outline_print(&self) {
   |        ------------- required by a bound in this associated function

For more information about this error, try `rustc --explain E0277`.
error: could not compile `traits-example` (bin "traits-example") due to 2 previous errors
```

為了解決這個問題，我們在 `Point` 上實作 `Display`，並滿足 `OutlinePrint` 所需的約束，如下所示：

src/main.rs

```rust
use std::fmt;

impl fmt::Display for Point {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "({}, {})", self.x, self.y)
    }
}
```

然後，在 `Point` 上實作 `OutlinePrint` trait 將成功編譯，我們可以在 `Point` 實例上呼叫 `outline_print` 以將其顯示在星號框線內。

<a id="using-the-newtype-pattern-to-implement-external-traits-on-external-types"></a>

### 使用 Newtype Pattern 實作外部 Traits

在第 10 章「[在型別上實作 Trait](https://doc.rust-lang.org/book/ch10-02-traits.html#implementing-a-trait-on-a-type)」中，我們提到 orphan rule，它規定我們只能在 trait 或型別（或兩者）本地於我們的 crate 時，才能在型別上實作 trait。使用 *newtype pattern* 可以繞過這個限制，這涉及在 tuple struct 中建立一個新型別。（我們在第 5 章「[使用不帶命名欄位的 Tuple Struct 建立不同型別](https://doc.rust-lang.org/book/ch05-01-defining-structs.html#using-tuple-structs-without-named-fields-to-create-different-types)」中討論了 tuple structs。）tuple struct 將有一個欄位，並作為我們想要實作 trait 的型別的薄包裝。然後，該包裝型別是我們 crate 的本地型別，我們可以在該包裝上實作 trait。*Newtype* 是一個源自 Haskell 程式語言的術語。使用此 pattern 沒有執行時效能損失，並且包裝型別在編譯時會被省略。

舉例來說，假設我們想在 `Vec<T>` 上實作 `Display`，而 orphan rule 阻止我們直接這樣做，因為 `Display` trait 和 `Vec<T>` 型別都在我們的 crate 外部定義。我們可以建立一個 `Wrapper` struct 來容納 `Vec<T>` 實例；然後我們可以在 `Wrapper` 上實作 `Display` 並使用 `Vec<T>` 值，如程式碼清單 20-24 所示。

src/main.rs

```rust
use std::fmt;

struct Wrapper(Vec<String>);

impl fmt::Display for Wrapper {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "[{}]", self.0.join(", "))
    }
}

fn main() {
    let w = Wrapper(vec![String::from("hello"), String::from("world")]);
    println!("w = {w}");
}
```

程式碼清單 20-24：建立 `Vec<String>` 周圍的 `Wrapper` 型別來實作 `Display`

`Display` 的實作使用 `self.0` 來存取內部的 `Vec<T>`，因為 `Wrapper` 是一個 tuple struct，而 `Vec<T>` 是 tuple 中索引 0 的項目。然後我們可以在 `Wrapper` 上使用 `Display` trait 的功能。

使用這種技術的缺點是 `Wrapper` 是一個新類型，因此它沒有其所持有的值的方法。我們必須直接在 `Wrapper` 上實作 `Vec<T>` 的所有方法，這樣這些方法就會委託給 `self.0`，這將允許我們將 `Wrapper` 完全視為 `Vec<T>`。如果我們希望新類型擁有內部類型的所有方法，那麼在 `Wrapper` 上實作 `Deref` trait 以回傳內部類型將是一個解決方案（我們在第 15 章「[使用 `Deref` 將 Smart Pointers 視為一般 References](https://doc.rust-lang.org/book/ch15-02-deref.html#treating-smart-pointers-like-regular-references-with-deref)」中討論了實作 `Deref` trait）。如果我們不希望 `Wrapper` 類型擁有內部類型的所有方法——例如，為了限制 `Wrapper` 類型的行為——我們必須手動實作我們想要的方法。

這個 newtype pattern 即使在不涉及 trait 的情況下也很有用。讓我們轉換焦點，看看一些與 Rust 的型別系統互動的進階方式。

## 進階型別

Rust 型別系統具有我們目前為止已提及但尚未討論的一些功能。我們將從一般討論 newtypes 開始，因為我們將探討 newtypes 作為型別的用途。然後我們將轉向型別別名，這是一個與 newtypes 類似但語義略有不同的功能。我們還將討論 `!` 型別和動態大小型別。

### 使用 Newtype Pattern 實現型別安全與抽象

本節假設你已閱讀了前一節「[使用 Newtype Pattern 實作外部 Trait](https://doc.rust-lang.org/book/ch20-02-advanced-traits.html#using-the-newtype-pattern-to-implement-external-traits-on-external-types)」。Newtype pattern 除了我們目前為止討論的用途之外，還有助於靜態強制值永不混淆以及指示值的單位。你看到一個使用 newtypes 指示單位值的範例在程式碼清單 20-16 中：回想一下 `Millimeters` 和 `Meters` struct 將 `u32` 值包裝在一個 newtype 中。如果我們編寫一個帶有 `Millimeters` 型別參數的函式，我們將無法編譯一個不小心嘗試使用 `Meters` 型別或純 `u32` 值呼叫該函式的程式。

我們也可以使用 newtype pattern 來抽象化型別的一些實作細節：新類型可以公開一個與私有內部型別的 API 不同的 public API。

Newtypes 也可以隱藏內部實作。例如，我們可以提供一個 `People` 型別來包裝一個 `HashMap<i32, String>`，該 `HashMap` 儲存了與其姓名相關聯的個人 ID。使用 `People` 的程式碼將只與我們提供的 public API 互動，例如將姓名字串添加到 `People` 集合的方法；該程式碼無需知道我們在內部為姓名分配了 `i32` ID。newtype pattern 是一種輕量級的方式來實現封裝以隱藏實作細節，我們在第 18 章「[隱藏實作細節的封裝](https://doc.rust-lang.org/book/ch18-03-advanced-features.html#encapsulation-that-hides-implementation-details)」中討論了這一點。

### 使用型別別名建立型別同義詞

Rust 提供宣告*型別別名 (type alias)* 的功能，為現有型別提供另一個名稱。為此，我們使用 `type` 關鍵字。例如，我們可以像這樣為 `i32` 建立別名 `Kilometers`：

```rust
    type Kilometers = i32;
```

現在別名 `Kilometers` 是 `i32` 的*同義詞*；與我們在程式碼清單 20-16 中建立的 `Millimeters` 和 `Meters` 型別不同，`Kilometers` 不是一個獨立的新型別。型別為 `Kilometers` 的值將被視為與 `i32` 型別的值相同：

```rust
    type Kilometers = i32;

    let x: i32 = 5;
    let y: Kilometers = 5;

    println!("x + y = {}", x + y);
```

因為 `Kilometers` 和 `i32` 是相同的型別，所以我們可以將這兩種型別的值相加，並且可以將 `Kilometers` 值傳遞給接受 `i32` 參數的函式。然而，使用這種方法，我們無法獲得前面討論的 newtype pattern 所帶來的型別檢查好處。換句話說，如果我們在某處混淆了 `Kilometers` 和 `i32` 值，編譯器不會給我們錯誤。

型別同義詞的主要用途是減少重複。例如，我們可能會有一個很長的型別，像這樣：

```rust
Box<dyn Fn() + Send + 'static>
```

在函式簽名和程式碼中到處撰寫這麼長的型別既繁瑣又容易出錯。想像一下，一個專案中充滿了程式碼清單 20-25 這樣的程式碼。

```rust
    let f: Box<dyn Fn() + Send + 'static> = Box::new(|| println!("hi"));

    fn takes_long_type(f: Box<dyn Fn() + Send + 'static>) {
        // --snip--
    }

    fn returns_long_type() -> Box<dyn Fn() + Send + 'static> {
        // --snip--
    }
```

程式碼清單 20-25：在多處使用長型別

型別別名透過減少重複使這段程式碼更容易管理。在程式碼清單 20-26 中，我們為冗長的型別引入了一個名為 `Thunk` 的別名，並可以用較短的別名 `Thunk` 替換所有型別的使用。

```rust
    type Thunk = Box<dyn Fn() + Send + 'static>;

    let f: Thunk = Box::new(|| println!("hi"));

    fn takes_long_type(f: Thunk) {
        // --snip--
    }

    fn returns_long_type() -> Thunk {
        // --snip--
    }
```

程式碼清單 20-26：引入型別別名 `Thunk` 以減少重複

這段程式碼更容易閱讀和撰寫！為型別別名選擇一個有意義的名稱也有助於傳達你的意圖（*thunk* 是一個指稍後會被求值的程式碼的詞，因此它對於儲存的閉包來說是一個恰當的名稱）。

型別別名也常用於 `Result<T, E>` 型別以減少重複。考慮標準函式庫中的 `std::io` 模組。I/O 操作通常回傳 `Result<T, E>` 以處理操作失敗的情況。這個函式庫有一個 `std::io::Error` struct，表示所有可能的 I/O 錯誤。`std::io` 中的許多函式都會回傳 `Result<T, E>`，其中 `E` 是 `std::io::Error`，例如 `Write` trait 中的這些函式：

```rust
use std::fmt;
use std::io::Error;

pub trait Write {
    fn write(&mut self, buf: &[u8]) -> Result<usize, Error>;
    fn flush(&mut self) -> Result<(), Error>;

    fn write_all(&mut self, buf: &[u8]) -> Result<(), Error>;
    fn write_fmt(&mut self, fmt: fmt::Arguments) -> Result<(), Error>;
}
```

`Result<..., Error>` 重複出現很多次。因此，`std::io` 有以下型別別名宣告：

```rust
type Result<T> = std::result::Result<T, std::io::Error>;
```

由於此宣告位於 `std::io` 模組中，我們可以採用完全限定別名 `std::io::Result<T>`；也就是說，一個 `Result<T, E>`，其 `E` 填充為 `std::io::Error`。`Write` trait 函式簽名最終會變成這樣：

```rust
pub trait Write {
    fn write(&mut self, buf: &[u8]) -> Result<usize>;
    fn flush(&mut self) -> Result<()>;

    fn write_all(&mut self, buf: &[u8]) -> Result<()>;
    fn write_fmt(&mut self, fmt: fmt::Arguments) -> Result<()>;
}
```

型別別名有助於兩方面：它使程式碼更容易編寫，並且它為我們提供了所有 `std::io` 中的一致介面。因為它是一個別名，所以它只是另一個 `Result<T, E>`，這表示我們可以將任何適用於 `Result<T, E>` 的方法與它一起使用，以及諸如 `?` 運算子之類的特殊語法。

### 永不回傳的 Never Type

Rust 有一個特殊型別，名為 `!`，在型別理論術語中被稱為*空型別 (empty type)*，因為它沒有值。我們更喜歡稱它為 *never type*，因為當函式永遠不會回傳時，它就代表回傳型別。這是一個範例：

```rust
fn bar() -> ! {
    // --snip--
}
```

這段程式碼讀作「函式 `bar` 永不回傳」。永不回傳的函式稱為*發散函式 (diverging functions)*。我們無法建立 `!` 型別的值，因此 `bar` 永遠不可能回傳。

但是一個你永遠無法建立值的型別有什麼用呢？回想一下程式碼清單 2-5 中的程式碼，它是猜數字遊戲的一部分；我們在這裡程式碼清單 20-27 中複製了一部分。

```rust
        let guess: u32 = match guess.trim().parse() {
            Ok(num) => num,
            Err(_) => continue,
        };
```

程式碼清單 20-27：一個以 `continue` 結尾的 `match` arm

當時，我們跳過了一些程式碼細節。在第 6 章「[`match` 控制流結構](https://doc.rust-lang.org/book/ch06-02-match.html#the-match-control-flow-construct)」中，我們討論過 `match` 的所有 arm 都必須回傳相同的型別。因此，例如，以下程式碼無法運作：

```rust
    let guess = match guess.trim().parse() {
        Ok(_) => 5,
        Err(_) => "hello",
    };
```

此程式碼中 `guess` 的型別必須是整數*和*字串，而 Rust 要求 `guess` 只能有一個型別。那麼 `continue` 回傳什麼？我們如何在程式碼清單 20-27 中允許從一個 arm 回傳 `u32`，而另一個 arm 以 `continue` 結尾呢？

正如你可能猜到的，`continue` 的值是 `!`。也就是說，當 Rust 計算 `guess` 的型別時，它會查看兩個 match arm，前一個的型別是 `u32`，後一個的型別是 `!`。因為 `!` 永遠不能有值，所以 Rust 判斷 `guess` 的型別是 `u32`。

這種行為的正式描述是，型別為 `!` 的表達式可以被強制轉換為任何其他型別。我們允許以 `continue` 結束這個 `match` arm，因為 `continue` 不會回傳值；相反，它將控制權移回迴圈的頂部，因此在 `Err` 情況下，我們從不將值賦給 `guess`。

never type 在 `panic!` macro 中也很有用。回想一下我們在 `Option<T>` 值上呼叫的 `unwrap` 函式，它產生一個值或 panic，其定義如下：

```rust
impl<T> Option<T> {
    pub fn unwrap(self) -> T {
        match self {
            Some(val) => val,
            None => panic!("called `Option::unwrap()` on a `None` value"),
        }
    }
}
```

在這段程式碼中，發生的情況與程式碼清單 20-27 中的 `match` 相同：Rust 看到 `val` 的型別是 `T`，而 `panic!` 的型別是 `!`，因此整個 `match` 表達式的結果是 `T`。這段程式碼之所以有效，是因為 `panic!` 不會產生值；它會終止程式。在 `None` 的情況下，我們不會從 `unwrap` 回傳值，因此這段程式碼是有效的。

最後一個具有 `!` 型別的表達式是 `loop`：

```rust
    print!("forever ");

    loop {
        print!("and ever ");
    }
```

在這裡，迴圈永遠不會結束，所以 `!` 是表達式的值。然而，如果我們包含 `break`，情況就不會是這樣，因為當它到達 `break` 時，迴圈會終止。

### 動態大小型別與 Sized Trait

Rust 需要了解其型別的某些細節，例如為特定型別的值分配多少空間。這使得其型別系統的一個方面在開始時有點令人困惑：*動態大小型別 (dynamically sized types)* 的概念。這些型別有時被稱為 *DSTs* 或 *unsized types*，它們讓你可以編寫程式碼，其中值的大小只能在執行時得知。

讓我們深入探討一個我們在本書中一直在使用的動態大小型別 `str` 的細節。沒錯，不是 `&str`，而是 `str` 本身就是一個 DST。在許多情況下，例如儲存使用者輸入的文字時，我們無法在執行時知道字串的長度。這意味著我們無法建立 `str` 型別的變數，也無法接受 `str` 型別的參數。考慮以下無法運作的程式碼：

```rust
    let s1: str = "Hello there!";
    let s2: str = "How's it going?";
```

Rust 需要知道為特定型別的任何值分配多少記憶體，而且所有相同型別的值都必須使用相同數量的記憶體。如果 Rust 允許我們編寫這段程式碼，這兩個 `str` 值將需要佔用相同的空間。但它們的長度不同：`s1` 需要 12 個位元組的儲存空間，而 `s2` 需要 15 個。這就是為什麼無法建立包含動態大小型別的變數的原因。

那我們該怎麼辦呢？在這種情況下，你已經知道答案了：我們將 `s1` 和 `s2` 的型別從 `str` 改為 `&str`。回想一下第 4 章「[字串 slices](https://doc.rust-lang.org/book/ch04-03-slices.html#string-slices)」中的內容，slice 資料結構只儲存 slice 的起始位置和長度。因此，雖然 `&T` 是一個單一值，儲存 `T` 所在記憶體位址，但 `&str` 是*兩個*值：`str` 的位址和它的長度。因此，我們可以在編譯時知道 `&str` 值的大小：它是 `usize` 長度的兩倍。也就是說，無論它指向的字串有多長，我們總是知道 `&str` 的大小。通常，這是 Rust 中使用動態大小型別的方式：它們具有額外的元資料，儲存動態資訊的大小。動態大小型別的黃金法則是，我們必須始終將動態大小型別的值放在某種指標後面。

我們可以將 `str` 與各種指標結合：例如，`Box<str>` 或 `Rc<str>`。事實上，你之前見過這種情況，但使用的是不同的動態大小型別：traits。每個 trait 都是一個動態大小型別，我們可以透過 trait 的名稱來引用它。在第 17 章「[使用 Trait Objects 抽象共用行為](https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-to-abstract-over-shared-behavior)」中，我們提到要將 traits 作為 trait objects 使用，我們必須將它們放在指標後面，例如 `&dyn Trait` 或 `Box<dyn Trait>`（`Rc<dyn Trait>` 也可以）。

為處理 DST，Rust 提供 `Sized` trait 來判斷型別的大小是否在編譯時已知。此 trait 會自動實作於所有在編譯時大小已知的型別。此外，Rust 會隱式地為每個泛型函式添加 `Sized` 綁定。也就是說，像這樣的泛型函式定義：

```rust
fn generic<T>(t: T) {
    // --snip--
}
```

實際上被視為我們寫了：

```rust
fn generic<T: Sized>(t: T) {
    // --snip--
}
```

預設情況下，泛型函式僅適用於在編譯時已知大小的型別。然而，你可以使用以下特殊語法來放寬此限制：

```rust
fn generic<T: ?Sized>(t: &T) {
    // --snip--
}
```

`?Sized` 上的 trait bound 意味著「`T` 可能或可能不是 `Sized`」，這種表示法會覆寫泛型型別在編譯時必須具有已知大小的預設值。這種含義的 `?Trait` 語法僅適用於 `Sized`，不適用於任何其他 traits。

另請注意，我們將 `t` 參數的型別從 `T` 變更為 `&T`。因為型別可能不是 `Sized`，所以我們需要將它放在某種指標後面。在本例中，我們選擇了 reference。

接下來，我們將討論函式和閉包！

## 進階函式和閉包

本節探討與函式和閉包相關的一些進階功能，包括函式指標和回傳閉包。

### 函式指標

我們已經討論了如何將閉包傳遞給函式；你也可以將一般函式傳遞給函式！當你想要傳遞一個你已經定義的函式，而不是定義一個新的閉包時，這種技術很有用。函式會強制轉換為 `fn` (小寫 *f*) 型別，不要與 `Fn` 閉包 trait 混淆。`fn` 型別稱為*函式指標 (function pointer)*。透過函式指標傳遞函式將允許你將函式作為參數傳遞給其他函式。

指定參數為函式指標的語法與閉包類似，如程式碼清單 20-28 所示，其中我們定義了一個 `add_one` 函式，它將其參數加 1。函式 `do_twice` 接受兩個參數：一個指向任何接受 `i32` 參數並回傳 `i32` 的函式的函式指標，以及一個 `i32` 值。`do_twice` 函式呼叫函式 `f` 兩次，將 `arg` 值傳遞給它，然後將兩個函式呼叫結果相加。`main` 函式使用 `add_one` 和 `5` 作為參數呼叫 `do_twice`。

src/main.rs

```rust
fn add_one(x: i32) -> i32 {
    x + 1
}

fn do_twice(f: fn(i32) -> i32, arg: i32) -> i32 {
    f(arg) + f(arg)
}

fn main() {
    let answer = do_twice(add_one, 5);

    println!("The answer is: {answer}");
}
```

程式碼清單 20-28：使用 `fn` 型別來接受函式指標作為參數

這段程式碼印出 `The answer is: 12`。我們指定 `do_twice` 中的參數 `f` 是一個 `fn`，它接受一個 `i32` 型別的參數並回傳一個 `i32`。然後我們可以在 `do_twice` 的主體中呼叫 `f`。在 `main` 中，我們將函式名稱 `add_one` 作為第一個參數傳遞給 `do_twice`。

與閉包不同，`fn` 是一種型別而不是 trait，因此我們直接將 `fn` 指定為參數型別，而不是宣告一個帶有其中一個 `Fn` trait 作為 trait bound 的泛型型別參數。

函式指標實作了所有三個閉包 trait (`Fn`、`FnMut` 和 `FnOnce`)，這表示你總是可以在期望閉包的函式中將函式指標作為參數傳遞。最好使用泛型型別和其中一個閉包 trait 來編寫函式，這樣你的函式就可以同時接受函式和閉包。

話雖如此，一個你只想接受 `fn` 而不接受閉包的例子是當與不支援閉包的外部程式碼介接時：C 函式可以接受函式作為參數，但 C 沒有閉包。

作為你可以使用 inline 定義的閉包或命名函式範例，讓我們看看標準函式庫中 `Iterator` trait 提供的 `map` 方法的使用。要使用 `map` 方法將數字向量轉換為字串向量，我們可以使用閉包，如程式碼清單 20-29 所示。

```rust
    let list_of_numbers = vec![1, 2, 3];
    let list_of_strings: Vec<String> =
        list_of_numbers.iter().map(|i| i.to_string()).collect();
```

程式碼清單 20-29：使用閉包搭配 `map` 方法將數字轉換為字串

或者，我們可以將一個命名函式作為 `map` 的參數，而不是閉包。程式碼清單 20-30 顯示了這樣做的樣子。

```rust
    let list_of_numbers = vec![1, 2, 3];
    let list_of_strings: Vec<String> =
        list_of_numbers.iter().map(ToString::to_string).collect();
```

程式碼清單 20-30：使用 `String::to_string` 函式搭配 `map` 方法將數字轉換為字串

請注意，我們必須使用我們在「[進階 Trait](https://doc.rust-lang.org/book/ch20-02-advanced-traits.html)」中討論過的完全限定語法，因為有許多可用函式名為 `to_string`。

在這裡，我們使用的是在 `ToString` trait 中定義的 `to_string` 函式，標準函式庫已經為任何實作 `Display` 的型別實作了它。

回想一下第 6 章「[Enum 值](https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html#enum-values)」中的內容，我們定義的每個 enum variant 的名稱也都成為一個初始器函式 (initializer function)。我們可以使用這些初始器函式作為實作閉包 trait 的函式指標，這意味著我們可以將初始器函式指定為接受閉包的方法的參數，如程式碼清單 20-31 所示。

```rust
    enum Status {
        Value(u32),
        Stop,
    }

    let list_of_statuses: Vec<Status> = (0u32..20).map(Status::Value).collect();
```

程式碼清單 20-31：使用 enum 初始器搭配 `map` 方法從數字建立 `Status` 實例

在這裡，我們使用 `Status::Value` 的初始器函式，從 `map` 所呼叫的範圍內的每個 `u32` 值建立 `Status::Value` 實例。有些人喜歡這種風格，有些人則喜歡使用閉包。它們編譯成相同的程式碼，因此請使用你認為更清晰的風格。

### 回傳閉包

閉包由 trait 表示，這表示你無法直接回傳閉包。在大多數你可能想回傳 trait 的情況下，你可以改用實作該 trait 的具體型別作為函式的回傳值。然而，你通常無法對閉包這樣做，因為它們沒有可回傳的具體型別；例如，如果閉包從其範圍內捕獲任何值，你就不允許使用函式指標 `fn` 作為回傳型別。

相反，你通常會使用我們在第 10 章學到的 `impl Trait` 語法。你可以回傳任何函式型別，使用 `Fn`、`FnOnce` 和 `FnMut`。例如，程式碼清單 20-32 將會正常編譯。

```rust
fn returns_closure() -> impl Fn(i32) -> i32 {
    |x| x + 1
}
```

程式碼清單 20-32：使用 `impl Trait` 語法從函式回傳閉包

然而，正如我們在第 13 章「[閉包型別推斷與註解](https://doc.rust-lang.org/book/ch13-01-closures.html#closure-type-inference-and-annotation)」中指出的那樣，每個閉包也都是它自己獨特的型別。如果你需要處理具有相同簽名但不同實作的多個函式，你將需要為它們使用 trait object。考慮一下如果你編寫了程式碼清例 20-33 所示的程式碼會發生什麼。

src/main.rs

```rust
fn main() {
    let handlers = vec![returns_closure(), returns_initialized_closure(123)];
    for handler in handlers {
        let output = handler(5);
        println!("{output}");
    }
}

fn returns_closure() -> impl Fn(i32) -> i32 {
    |x| x + 1
}

fn returns_initialized_closure(init: i32) -> impl Fn(i32) -> i32 {
    move |x| x + init
}
```

程式碼清單 20-33：建立由回傳 `impl Fn` 型別的函式定義的閉包 `Vec<T>`

這裡我們有兩個函式，`returns_closure` 和 `returns_initialized_closure`，它們都回傳 `impl Fn(i32) -> i32`。請注意，它們回傳的閉包是不同的，即使它們實作相同的型別。如果我們嘗試編譯這個，Rust 會告訴我們它無法運作：

```
$ cargo build
   Compiling functions-example v0.1.0 (file:///projects/functions-example)
error[E0308]: mismatched types
  --> src/main.rs:2:44
   |
2  |     let handlers = vec![returns_closure(), returns_initialized_closure(123)];
   |                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected opaque type, found a different opaque type
...
9  | fn returns_closure() -> impl Fn(i32) -> i32 {
   |                         ------------------- the expected opaque type
...
13 | fn returns_initialized_closure(init: i32) -> impl Fn(i32) -> i32 {
   |                                              ------------------- the found opaque type
   |
   = note: expected opaque type `impl Fn(i32) -> i32` (opaque type at <src/main.rs:9:25>)
              found opaque type `impl Fn(i32) -> i32` (opaque type at <src/main.rs:13:46>)
   = note: distinct uses of `impl Trait` result in different opaque types

For more information about this error, try `rustc --explain E0308`.
error: could not compile `functions-example` (bin "functions-example") due to 1 previous error
```

錯誤訊息告訴我們，無論何時我們回傳 `impl Trait`，Rust 都會建立一個獨特的*不透明型別 (opaque type)*，這是一種我們無法深入查看 Rust 為我們建構的細節，也無法猜測 Rust 將生成的型別以自行編寫的型別。所以即使這些函式回傳實作相同 trait 的閉包，`Fn(i32) -> i32`，Rust 為每個函式生成的不透明型別也是不同的。（這類似於 Rust 如何為不同的 async block 產生不同的具體型別，即使它們具有相同的輸出型別，正如我們在第 17 章「[處理任意數量的 Futures](https://doc.rust-lang.org/book/ch17-03-async-io.html#working-with-any-number-of-futures)」中所見。）我們現在已經多次看到這個問題的解決方案：我們可以像程式碼清單 20-34 所示那樣使用 trait object。

```rust
fn returns_closure() -> Box<dyn Fn(i32) -> i32> {
    Box::new(|x| x + 1)
}

fn returns_initialized_closure(init: i32) -> Box<dyn Fn(i32) -> i32> {
    Box::new(move |x| x + init)
}
```

程式碼清單 20-34：建立由回傳 `Box<dyn Fn>` 的函式定義的閉包 `Vec<T>`，因此它們具有相同的型別

這段程式碼會正常編譯。有關 trait object 的更多資訊，請參閱第 17 章「[使用 Trait Objects 允許不同型別的值](https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types)」一節。

接下來，我們來看看 macros！

## Macros

我們在本書中一直使用 `println!` 等 macros，但我們尚未完全探討 macro 是什麼以及它是如何運作的。術語 *macro* 指的是 Rust 中的一系列功能：使用 `macro_rules!` 的*宣告式 (declarative)* macros 以及三種*程序式 (procedural)* macros：

* 自訂的 `#[derive]` macros，指定在 struct 和 enum 上使用 `derive` attribute 添加的程式碼
* 類 attribute macros，定義可套用於任何項目的自訂 attribute
* 類函式 macros，看起來像函式呼叫，但操作其參數中指定的 token

我們將逐一討論這些，但首先，讓我們看看為什麼在已經有函式的情況下，我們還需要 macros。

### Macros 與函式之間的差異

從根本上說，macros 是一種編寫產生其他程式碼的程式碼的方式，這就是所謂的*元程式設計 (metaprogramming)*。在附錄 C 中，我們討論了 `derive` attribute，它為你產生各種 trait 的實作。我們還在本書中使用了 `println!` 和 `vec!` macro。所有這些 macro 都會*展開 (expand)*，以產生比你手動編寫的程式碼更多的程式碼。

元程式設計對於減少你必須編寫和維護的程式碼量很有用，這也是函式的其中一個作用。然而，macros 擁有一些函式沒有的額外能力。

函式簽名必須宣告函式擁有的參數數量和型別。另一方面，macros 可以接受可變數量的參數：我們可以呼叫 `println!("hello")` 帶有一個參數，或者 `println!("hello {}", name)` 帶有兩個參數。此外，macros 在編譯器解釋程式碼的含義之前展開，因此 macro 可以例如在給定型別上實作 trait。函式不能，因為它在執行時被呼叫，而 trait 需要在編譯時實作。

實作 macro 而非函式的缺點在於，macro 定義比函式定義更複雜，因為你正在編寫產生 Rust 程式碼的 Rust 程式碼。由於這種間接性，macro 定義通常比函式定義更難閱讀、理解和維護。

宏和函式之間另一個重要的區別是，你必須在呼叫它們之前在檔案中定義宏或將它們帶入 scope，與函式不同，函式可以在任何地方定義和呼叫。

### 使用 macro_rules! 的宣告式 Macros 進行一般元程式設計

Rust 中最廣泛使用的宏形式是*宣告式宏 (declarative macro)*。這些宏有時也被稱為「範例式宏 (macros by example)」、「`macro_rules!` 宏」或簡稱為「宏」。其核心在於，宣告式宏允許你編寫類似於 Rust `match` 表達式的內容。正如第 6 章所討論的，`match` 表達式是控制結構，它接受一個表達式，將表達式結果值與模式進行比較，然後執行與匹配模式相關聯的程式碼。宏也會將值與與特定程式碼相關聯的模式進行比較：在這種情況下，值是傳遞給宏的字面 Rust 原始碼；模式與原始碼的結構進行比較；與每個匹配模式相關聯的程式碼會取代傳遞給宏的程式碼。這一切都發生在編譯期間。

要定義一個 macro，你使用 `macro_rules!` 構造。讓我們透過查看 `vec!` macro 的定義來探索如何使用 `macro_rules!`。第 8 章介紹了我們如何使用 `vec!` macro 建立一個帶有特定值的新 vector。例如，以下 macro 建立一個包含三個整數的新 vector：

```rust
let v: Vec<u32> = vec![1, 2, 3];
```

我們也可以使用 `vec!` macro 來建立包含兩個整數的 vector 或包含五個字串 slices 的 vector。我們無法使用函式來做同樣的事情，因為我們無法預先知道值的數量或型別。

程式碼清單 20-35 顯示了 `vec!` macro 的稍微簡化的定義。

src/lib.rs

```rust
#[macro_export]
macro_rules! vec {
    ( $( $x:expr ),* ) => {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}
```

程式碼清單 20-35：`vec!` macro 定義的簡化版本

> 注意：標準函式庫中 `vec!` macro 的實際定義包含了預先分配正確記憶體量的程式碼。為了簡化範例，我們在此處未包含該最佳化程式碼。

`#[macro_export]` 註解表示當定義 macro 的 crate 被帶入 scope 時，這個 macro 應該可用。沒有這個註解，macro 就無法被帶入 scope。

然後我們開始 macro 定義，使用 `macro_rules!` 和我們正在定義的 macro 的名稱，*不帶*驚嘆號。此名稱（在此情況下為 `vec`）後面跟著大括號，表示 macro 定義的主體。

`vec!` 主體中的結構與 `match` 表達式的結構類似。這裡我們有一個 `( $( $x:expr ),* )` 模式的 arm，後面接著 `=>` 和與此模式相關聯的程式碼 block。如果模式匹配，相關聯的程式碼 block 將被發出。由於這是此 macro 中唯一的模式，因此只有一種有效的匹配方式；任何其他模式都將導致錯誤。更複雜的 macro 將有多個 arm。

macro 定義中的有效 pattern 語法與第 19 章中介紹的 pattern 語法不同，因為 macro pattern 是針對 Rust 程式碼結構而不是值進行匹配。讓我們逐步了解程式碼清單 20-29 中 pattern 片段的含義；有關完整的 macro pattern 語法，請參閱 Rust Reference 中的 *[../reference/macros-by-example.html](https://doc.rust-lang.org/reference/macros-by-example.html)*。

首先我們使用一組小括號來包含整個模式。我們使用 dollar sign (`$`) 在宏系統中宣告一個變數，該變數將包含與模式匹配的 Rust 程式碼。 dollar sign 清楚地表明這是一個宏變數，而不是一個普通的 Rust 變數。接下來是一組小括號，用於捕獲與小括號內模式匹配的值，以便在替換程式碼中使用。`$()` 內是 `$x:expr`，它匹配任何 Rust 表達式，並將表達式命名為 `$x`。

跟在 `$()` 後面的逗號表示在 `$( )` 中匹配程式碼的每個實例之間必須出現一個字面逗號分隔符。`*` 指定該模式匹配其前面內容的零個或多個。

當我們使用 `vec![1, 2, 3];` 呼叫這個 macro 時，`$x` 模式會匹配三次，分別與三個表達式 `1`、`2` 和 `3` 匹配。

現在讓我們看看與此 arm 相關聯的程式碼主體中的模式：`$()*` 中的 `temp_vec.push()` 會為模式中匹配 `$()` 的每個部分產生，產生零次或多次，取決於模式匹配的次數。`$x` 會被替換為每個匹配的表達式。當我們使用 `vec![1, 2, 3];` 呼叫這個 macro 時，替換此 macro 呼叫產生的程式碼將是以下內容：

```rust
{
    let mut temp_vec = Vec::new();
    temp_vec.push(1);
    temp_vec.push(2);
    temp_vec.push(3);
    temp_vec
}
```

我們已經定義了一個 macro，它可以接受任意數量的任意型別參數，並能生成程式碼來建立一個包含指定元素的 vector。

要了解更多關於如何編寫 macros 的資訊，請查閱線上說明文件或其他資源，例如 Daniel Keep 開創並由 Lukas Wirth 繼續的「[The Little Book of Rust Macros](https://veykril.github.io/tlborm/)」。

### 用於從 Attributes 產生程式碼的程序式 Macros

第二種 macros 形式是程序式 macro，它的行為更像一個函式（並且是一種程序）。*程序式 macros (Procedural macros)* 接受一些程式碼作為輸入，對其進行操作，然後產生一些程式碼作為輸出，而不是像宣告式 macros 那樣匹配模式並用其他程式碼替換程式碼。程序式 macros 有三種：自訂 `derive`、類 attribute 和類函式，它們的工作方式都類似。

當建立程序式 macros 時，定義必須位於其自己的 crate 中，並具有特殊的 crate 型別。這是由於複雜的技術原因，我們希望將來能夠消除。在程式碼清單 20-36 中，我們展示了如何定義一個程序式 macro，其中 `some_attribute` 是使用特定 macro 變體的 placeholder。

src/lib.rs

```rust
use proc_macro;

#[some_attribute]
pub fn some_name(input: TokenStream) -> TokenStream {
}
```

程式碼清單 20-36：定義程序式 Macro 的範例

定義程序式 macro 的函式接受 `TokenStream` 作為輸入，並產生 `TokenStream` 作為輸出。`TokenStream` 型別由 Rust 附帶的 `proc_macro` crate 定義，表示一系列 tokens。這是 macro 的核心：macro 正在操作的原始碼構成輸入 `TokenStream`，而 macro 產生的程式碼是輸出 `TokenStream`。函式還附加了一個 attribute，指定我們正在建立的程序式 macro 的類型。我們可以在同一個 crate 中擁有多種類型的程序式 macro。

讓我們看看不同種類的程序式 macros。我們將從自訂 `derive` macro 開始，然後解釋使其他形式不同的微小差異。

### 如何編寫自訂 derive Macro

讓我們建立一個名為 `hello_macro` 的 crate，它定義一個名為 `HelloMacro` 的 trait，其中包含一個名為 `hello_macro` 的關聯函式。我們不讓使用者為他們的每個型別實作 `HelloMacro` trait，而是提供一個程序式 macro，讓使用者可以用 `#[derive(HelloMacro)]` 標註他們的型別，以獲得 `hello_macro` 函式的預設實作。預設實作將會印出 `Hello, Macro! My name is TypeName!`，其中 `TypeName` 是定義此 trait 的型別名稱。換句話說，我們將編寫一個 crate，讓其他程式設計師能夠使用我們的 crate 編寫類似程式碼清單 20-37 的程式碼。

src/main.rs

```rust
use hello_macro::HelloMacro;
use hello_macro_derive::HelloMacro;

#[derive(HelloMacro)]
struct Pancakes;

fn main() {
    Pancakes::hello_macro();
}
```

程式碼清單 20-37：我們的 crate 使用者在使用我們的程序式 macro 時將能夠編寫的程式碼

這段程式碼完成後，會印出 `Hello, Macro! My name is Pancakes!`。第一步是建立一個新的函式庫 crate，像這樣：

```
$ cargo new hello_macro --lib
```

接下來，在程式碼清單 20-38 中，我們將定義 `HelloMacro` trait 及其關聯函式。

src/lib.rs

```rust
pub trait HelloMacro {
    fn hello_macro();
}
```

程式碼清單 20-38：我們將與 `derive` macro 一起使用的簡單 trait

我們有一個 trait 和它的函式。此時，我們的 crate 使用者可以實作該 trait 來實現所需的功能，如程式碼清單 20-39 所示。

src/main.rs

```rust
use hello_macro::HelloMacro;

struct Pancakes;

impl HelloMacro for Pancakes {
    fn hello_macro() {
        println!("Hello, Macro! My name is Pancakes!");
    }
}

fn main() {
    Pancakes::hello_macro();
}
```

程式碼清單 20-39：如果使用者手動實作 `HelloMacro` trait 會是怎樣

然而，他們需要為他們想與 `hello_macro` 一起使用的每個型別編寫實作 block；我們希望免除他們做這項工作。

此外，我們還無法提供 `hello_macro` 函式的預設實作，它會印出實作 trait 的型別名稱：Rust 沒有 reflection 功能，因此它無法在執行時查找型別的名稱。我們需要一個 macro 在編譯時產生程式碼。

下一步是定義程序式 macro。截至撰寫本文時，程序式 macros 需要位於其自己的 crate 中。最終，此限制可能會被解除。crate 和 macro crate 的結構慣例如下：對於名為 `foo` 的 crate，自訂 `derive` 程序式 macro crate 名為 `foo_derive`。讓我們在 `hello_macro` 專案中建立一個名為 `hello_macro_derive` 的新 crate：

```
$ cargo new hello_macro_derive --lib
```

我們的兩個 crate 緊密相關，因此我們在 `hello_macro` crate 的目錄中建立程序式 macro crate。如果我們在 `hello_macro` 中更改 trait 定義，我們也必須在 `hello_macro_derive` 中更改程序式 macro 的實作。這兩個 crate 需要單獨發布，使用這些 crate 的程式設計師需要將兩者都添加為依賴項並將它們都引入 scope。我們也可以讓 `hello_macro` crate 將 `hello_macro_derive` 作為依賴項並重新匯出程序式 macro 程式碼。然而，我們組織專案的方式使得程式設計師即使不想要 `derive` 功能也可以使用 `hello_macro`。

我們需要將 `hello_macro_derive` crate 宣告為程序式 macro crate。我們還需要 `syn` 和 `quote` crate 的功能，如你稍後將看到的，因此我們需要將它們添加為依賴項。將以下內容添加到 `hello_macro_derive` 的 *Cargo.toml* 檔案中：

hello_macro_derive/Cargo.toml

```toml
[lib]
proc-macro = true

[dependencies]
syn = "2.0"
quote = "1.0"
```

要開始定義程序式 macro，請將程式碼清單 20-40 中的程式碼放入 `hello_macro_derive` crate 的 *src/lib.rs* 檔案中。請注意，此程式碼在我們添加 `impl_hello_macro` 函式的定義之前不會編譯。

hello_macro_derive/src/lib.rs

```rust
use proc_macro::TokenStream;
use quote::quote;
use syn; // Added for clarity, though not strictly required by this snippet

#[proc_macro_derive(HelloMacro)]
pub fn hello_macro_derive(input: TokenStream) -> TokenStream {
    // Construct a representation of Rust code as a syntax tree
    // that we can manipulate.
    let ast = syn::parse(input).unwrap();

    // Build the trait implementation.
    impl_hello_macro(&ast)
}

fn impl_hello_macro(ast: &syn::DeriveInput) -> TokenStream {
    let name = &ast.ident;
    let generated = quote! {
        impl HelloMacro for #name {
            fn hello_macro() {
                println!("Hello, Macro! My name is {}!", stringify!(#name));
            }
        }
    };
    generated.into()
}
```

程式碼清單 20-40：大多數程序式 macro crate 都需要用來處理 Rust 程式碼的程式碼

請注意，我們已將程式碼分成 `hello_macro_derive` 函式（負責解析 `TokenStream`）和 `impl_hello_macro` 函式（負責轉換語法樹）：這使得編寫程序式 macro 更方便。外部函式（在本例中為 `hello_macro_derive`）中的程式碼對於你看到或建立的幾乎每個程序式 macro crate 都會相同。內部函式（在本例中為 `impl_hello_macro`）主體中指定的程式碼將根據你的程序式 macro 的目的而有所不同。

我們引入了三個新的 crate：`proc_macro`、`syn` 位於 *[https://crates.io/crates/syn](https://crates.io/crates/syn)*，以及 `quote`。`proc_macro` crate 隨 Rust 一起提供，因此我們無需將其添加到 *Cargo.toml* 中的依賴項中。`proc_macro` crate 是編譯器的 API，允許我們從程式碼中讀取和操作 Rust 程式碼。

`syn` crate 將 Rust 程式碼從字串解析成我們可以執行操作的資料結構。`quote` crate 將 `syn` 資料結構轉換回 Rust 程式碼。這些 crate 使解析我們可能想要處理的任何 Rust 程式碼變得更加簡單：為 Rust 程式碼編寫一個完整的解析器並不是一項簡單的任務。

當我們函式庫的使用者在型別上指定 `#[derive(HelloMacro)]` 時，`hello_macro_derive` 函式將會被呼叫。這之所以可能，是因為我們已使用 `proc_macro_derive` 標註了這裡的 `hello_macro_derive` 函式，並指定了名稱 `HelloMacro`，這與我們的 trait 名稱相符；這是大多數程序式 macros 遵循的慣例。

`hello_macro_derive` 函式首先將 `input` 從 `TokenStream` 轉換為我們可以解釋並執行操作的資料結構。這就是 `syn` 發揮作用的地方。`syn` 中的 `parse` 函式接受一個 `TokenStream` 並回傳一個 `DeriveInput` struct，表示解析後的 Rust 程式碼。程式碼清單 20-41 顯示了我們解析 `struct Pancakes;` 字串時從 `DeriveInput` struct 中獲得的相關部分。

```
DeriveInput {
    // --snip--

    ident: Ident {
        ident: "Pancakes",
        span: #0 bytes(95..103)
    },
    data: Struct(
        DataStruct {
            struct_token: Struct,
            fields: Unit,
            semi_token: Some(
                Semi
            )
        }
    )
}
```

程式碼清單 20-41：解析程式碼清單 20-37 中帶有宏 attribute 的程式碼時我們得到的 `DeriveInput` 實例

此 struct 的欄位顯示我們解析的 Rust 程式碼是一個單位 struct，其 `ident`（*識別符*，即名稱）為 `Pancakes`。此 struct 上還有更多欄位，用於描述各種 Rust 程式碼；有關更多資訊，請查閱 `syn` 說明文件中關於 `DeriveInput` 的說明：*[https://docs.rs/syn/2.0/syn/struct.DeriveInput.html](https://docs.rs/syn/2.0/syn/struct.DeriveInput.html)*。

很快我們將定義 `impl_hello_macro` 函式，我們將在其中建立我們想要包含的新 Rust 程式碼。但在我們這樣做之前，請注意我們的 `derive` macro 的輸出也是一個 `TokenStream`。回傳的 `TokenStream` 被添加到我們的 crate 使用者編寫的程式碼中，因此當他們編譯他們的 crate 時，他們將獲得我們在修改後的 `TokenStream` 中提供的額外功能。

你可能已經注意到，我們正在呼叫 `unwrap` 以使 `hello_macro_derive` 函式在此處的 `syn::parse` 函式呼叫失敗時 panic。我們的程序式 macro 必須在錯誤時 panic，因為 `proc_macro_derive` 函式必須回傳 `TokenStream` 而不是 `Result`，以符合程序式 macro API。我們透過使用 `unwrap` 簡化了這個範例；在生產程式碼中，你應該使用 `panic!` 或 `expect` 提供有關錯誤的更具體錯誤訊息。

現在我們有了將註解過的 Rust 程式碼從 `TokenStream` 轉換為 `DeriveInput` 實例的程式碼，讓我們產生在註解型別上實作 `HelloMacro` trait 的程式碼，如程式碼清單 20-42 所示。

hello_macro_derive/src/lib.rs

```rust
fn impl_hello_macro(ast: &syn::DeriveInput) -> TokenStream {
    let name = &ast.ident;
    let generated = quote! {
        impl HelloMacro for #name {
            fn hello_macro() {
                println!("Hello, Macro! My name is {}!", stringify!(#name));
            }
        }
    };
    generated.into()
}
```

程式碼清單 20-42：使用解析後的 Rust 程式碼實作 `HelloMacro` trait

我們透過 `ast.ident` 取得包含註解型別名稱（識別符號）的 `Ident` struct 實例。程式碼清單 20-41 中的 struct 顯示，當我們在程式碼清單 20-37 中的程式碼上執行 `impl_hello_macro` 函式時，我們將獲得的 `ident` 將具有 `ident` 欄位，其值為 `"Pancakes"`。因此，程式碼清單 20-42 中的 `name` 變數將包含一個 `Ident` struct 實例，當印出時，它將是字串 `"Pancakes"`，即程式碼清單 20-37 中 struct 的名稱。

`quote!` macro 讓你可以定義你想要回傳的 Rust 程式碼。編譯器期望的結果與 `quote!` macro 執行結果不同，因此我們需要將其轉換為 `TokenStream`。我們透過呼叫 `into` 方法來完成此操作，該方法會消耗這個中間表示並回傳所需 `TokenStream` 型別的值。

`quote!` macro 還提供了一些非常酷的 templating 機制：我們可以輸入 `#name`，然後 `quote!` 會將其替換為變數 `name` 中的值。你甚至可以進行一些與常規 macros 類似的重複。請查閱 `quote` crate 的說明文件 *[https://docs.rs/quote](https://docs.rs/quote)*，以獲得全面介紹。

我們希望我們的程序式 macro 為使用者註解的型別產生一個 `HelloMacro` trait 的實作，我們可以透過使用 `#name` 來取得它。trait 實作有一個函式 `hello_macro`，其主體包含我們想要提供的功能：印出 `Hello, Macro! My name is`，然後是註解型別的名稱。

這裡使用的 `stringify!` macro 是 Rust 內建的。它接受一個 Rust 表達式，例如 `1 + 2`，並在編譯時將該表達式轉換為字串字面值，例如 `"1 + 2"`。這與 `format!` 或 `println!` 不同，後者會計算表達式，然後將結果轉換為 `String`。`#name` 輸入可能是一個字面印出的表達式，因此我們使用 `stringify!`。使用 `stringify!` 還透過在編譯時將 `#name` 轉換為字串字面值來節省記憶體分配。

此時，`cargo build` 應該在 `hello_macro` 和 `hello_macro_derive` 中都成功完成。讓我們將這些 crate 連接到程式碼清單 20-37 中的程式碼，以查看程序式 macro 的實際效果！在你的 *projects* 目錄中，使用 `cargo new pancakes` 建立一個新的二進位專案。我們需要將 `hello_macro` 和 `hello_macro_derive` 添加為 `pancakes` crate 的 *Cargo.toml* 中的依賴項。如果你正在將你的 `hello_macro` 和 `hello_macro_derive` 版本發布到 crates.io，它們將是[常規依賴項](https://crates.io/)；如果不是，你可以將它們指定為 `path` 依賴項，如下所示：

```toml
[dependencies]
hello_macro = { path = "../hello_macro" }
hello_macro_derive = { path = "../hello_macro/hello_macro_derive" }
```

將程式碼清單 20-37 中的程式碼放入 *src/main.rs*，然後執行 `cargo run`：它應該印出 `Hello, Macro! My name is Pancakes!`。程序式 macro 中的 `HelloMacro` trait 實作已包含在內，而 `pancakes` crate 無需實作它；`#[derive(HelloMacro)]` 添加了 trait 實作。

接下來，讓我們探討其他類型的程序式 macros 與自訂 `derive` macros 有何不同。

### 類 Attribute Macros

類 attribute macros 類似於自訂 `derive` macros，但它們不為 `derive` attribute 產生程式碼，而是允許你建立新的 attribute。它們也更靈活：`derive` 只適用於 struct 和 enum；attribute 也可以應用於其他項目，例如函式。這是一個使用類 attribute macro 的範例。假設你在使用網頁應用程式框架時有一個名為 `route` 的 attribute，用於標註函式：

```rust
#[route(GET, "/")]
fn index() {
```

這個 `#[route]` attribute 將由框架定義為程序式 macro。macro 定義函式的簽名將如下所示：

```rust
#[proc_macro_attribute]
pub fn route(attr: TokenStream, item: TokenStream) -> TokenStream {
```

在這裡，我們有兩個 `TokenStream` 型別的參數。第一個用於 attribute 的內容：`GET, "/"` 部分。第二個是 attribute 所附著的項目的主體：在本例中，`fn index() {}` 和函式的其餘部分。

除此之外，類 attribute macros 的運作方式與自訂 `derive` macros 相同：你建立一個具有 `proc-macro` crate 型別的 crate，並實作一個產生你想要的程式碼的函式！

### 類函式 Macros

類函式 macros 定義了看起來像函式呼叫的 macros。與 `macro_rules!` macros 類似，它們比函式更靈活；例如，它們可以接受未知數量的參數。然而，`macro_rules!` macros 只能使用我們前面在「[使用 macro_rules! 的宣告式 Macros 進行一般元程式設計](https://doc.rust-lang.org/book/ch20-05-macros.html#declarative-macros-with-macro_rules-for-general-metaprogramming)」中討論的類似 `match` 的語法來定義。類函式 macros 接受 `TokenStream` 參數，並且它們的定義像其他兩種程序式 macros 一樣，使用 Rust 程式碼操作該 `TokenStream`。類函式 macro 的一個範例是 `sql!` macro，它可能像這樣被呼叫：

```rust
let sql = sql!(SELECT * FROM posts WHERE id=1);
```

這個 macro 將解析其中的 SQL 陳述式並檢查其語法是否正確，這比 `macro_rules!` macro 所能做的處理要複雜得多。`sql!` macro 將像這樣定義：

```rust
#[proc_macro]
pub fn sql(input: TokenStream) -> TokenStream {
```

這個定義與自訂 `derive` macro 的簽名類似：我們接收括號內的 tokens，並回傳我們想要產生的程式碼。

## 總結

呼！現在你的工具箱裡有了一些 Rust 功能，你可能不會經常使用它們，但你會知道它們在非常特殊的情況下是可用的。我們介紹了幾個複雜的主題，這樣當你在錯誤訊息建議或他人的程式碼中遇到它們時，你就能夠識別這些概念和語法。將本章作為指導你找到解決方案的參考。

接下來，我們將把本書中討論過的一切付諸實踐，再做一個專案！