<!-- DO NOT EDIT THIS FILE.

This file is periodically generated from the content in the `/src/`
directory, so all fixes need to be made in `/src/`.
-->

[TOC]

# 常見的 Collections

Rust 的標準函式庫包含許多非常有用的資料結構，稱為 _collections_。大多數其他的資料型別代表一個特定的值，但 collections 可以包含多個值。與內建的 array 和 tuple 型別不同，這些 collections 指向的資料儲存在 heap 上，這意味著資料量在編譯時不需要是已知的，並且可以隨著程式執行而增長或縮小。每種 collection 都有不同的能力和成本，為當前情況選擇合適的一種是您會隨著時間發展的技能。在本章中，我們將討論在 Rust 程式中非常常用的三種 collections：

- _vector_ 讓您可以將可變數量的數值彼此相鄰儲存。
- _string_ 是字元的集合。我們之前提過 `String` 型別，但在本章中，我們將深入探討它。
- _hash map_ 讓您可以將一個值與一個特定的鍵關聯起來。它是一種更通用的資料結構 _map_ 的特定實作。

要了解標準函式庫提供的其他種類的 collections，請參閱位於 _https://doc.rust-lang.org/std/collections/index.html_ 的文件。

我們將討論如何建立和更新 vectors、strings 和 hash maps，以及它們各自的特別之處。

## 使用 Vector 儲存數值列表

我們將看到的第一個 collection 型別是 `Vec<T>`，也稱為 _vector_。Vectors 讓您可以在單一資料結構中儲存多個值，它會將所有值在記憶體中彼此相鄰放置。Vectors 只能儲存相同型別的值。當您有一系列項目時，它們很有用，例如檔案中的文字行或購物車中商品的價格。

### 建立新的 Vector

要建立一個新的空 vector，我們呼叫 `Vec::new` 函式，如列表 8-1 所示。

```rust
let v: Vec<i32> = Vec::new();
```

列表 8-1：建立一個新的、空的 vector 來存放 `i32` 型別的值

請注意，我們在這裡加上了型別註記。因為我們沒有將任何值插入這個 vector，Rust 不知道我們打算儲存什麼樣的元素。這是很重要的一點。Vectors 是使用 generics 實作的；我們將在第 10 章介紹如何將 generics 與您自己的型別一起使用。目前，只要知道標準函式庫提供的 `Vec<T>` 型別可以存放任何型別。當我們建立一個 vector 來存放特定型別時，我們可以在角括號內指定型別。在列表 8-1 中，我們告訴 Rust `v` 中的 `Vec<T>` 將會存放 `i32` 型別的元素。

更常見的情況是，您會用初始值建立一個 `Vec<T>`，而 Rust 會推斷您想儲存的值的型別，所以您很少需要做這種型別註記。Rust 方便地提供了 `vec!` macro，它會建立一個新的 vector，並存放您給予的值。列表 8-2 建立了一個新的 `Vec<i32>`，存放 `1`、`2` 和 `3`。整數型別是 `i32`，因為那是預設的整數型別，正如我們在第 3 章的「資料型別」部分所討論的。

```rust
let v = vec![1, 2, 3];
```

列表 8-2：建立一個包含值的新 vector

因為我們給了初始的 `i32` 值，Rust 可以推斷 `v` 的型別是 `Vec<i32>`，所以型別註記不是必要的。接下來，我們來看看如何修改一個 vector。

### 更新 Vector

要建立一個 vector 然後再新增元素，我們可以使用 `push` 方法，如列表 8-3 所示。

```rust
    let mut v = Vec::new();

    v.push(5);
    v.push(6);
    v.push(7);
    v.push(8);
```

列表 8-3：使用 `push` 方法將值新增到 vector 中

與任何變數一樣，如果我們希望能夠改變它的值，我們需要使用 `mut` 關鍵字使其成為可變的，正如第 3 章所討論的。我們放入的數字都是 `i32` 型別，Rust 從資料中推斷出這一點，所以我們不需要 `Vec<i32>` 的註記。

### 讀取 Vector 的元素

有兩種方式可以引用儲存在 vector 中的值：透過索引或使用 `get` 方法。在下面的範例中，我們為了更清晰地說明，註記了這些函式回傳值的型別。

列表 8-4 展示了存取 vector 中值的兩種方法，分別是索引語法和 `get` 方法。

```rust
    let v = vec![1, 2, 3, 4, 5];

    let third: &i32 = &v[2];
    println!("The third element is {third}");

    let third: Option<&i32> = v.get(2);
    match third {
        Some(third) => println!("The third element is {third}"),
        None => println!("There is no third element."),
    }
```

列表 8-4：使用索引語法和 `get` 方法存取 vector 中的項目

這裡有幾個細節要注意。我們使用索引值 `2` 來取得第三個元素，因為 vectors 是以數字索引，從零開始。使用 `&` 和 `[]` 給了我們一個指向該索引位置元素的參考。當我們使用 `get` 方法並傳入索引作為參數時，我們會得到一個 `Option<&T>`，我們可以將它與 `match` 一起使用。

Rust 提供這兩種引用元素的方式，讓您可以選擇當您嘗試使用超出既有元素範圍的索引值時，程式該如何表現。舉個例子，讓我們看看當我們有一個包含五個元素的 vector，然後嘗試用每種技術存取索引 100 的元素時會發生什麼，如列表 8-5 所示。

```rust
    let v = vec![1, 2, 3, 4, 5];

    let does_not_exist = &v[100];
    let does_not_exist = v.get(100);
```

列表 8-5：嘗試存取一個包含五個元素的 vector 中索引為 100 的元素

當我們執行這段程式碼時，第一個 `[]` 方法會導致程式 panic，因為它引用了一個不存在的元素。當您希望程式在嘗試存取超出 vector 範圍的元素時崩潰，這種方法是最好的選擇。

當 `get` 方法被傳入一個超出 vector 範圍的索引時，它會回傳 `None` 而不會 panic。當在正常情況下偶爾可能會存取超出 vector 範圍的元素時，您會使用這種方法。您的程式碼將會有邏輯來處理 `Some(&element)` 或 `None` 的情況，如第 6 章所討論。例如，索引可能來自使用者輸入的數字。如果他們不小心輸入了一個太大的數字，而程式得到了一個 `None` 值，您可以告訴使用者目前 vector 中有多少項目，並給他們另一次輸入有效值的機會。這比因為一個打字錯誤而讓程式崩潰要友善得多！

當程式有一個有效的參考時，borrow checker 會強制執行 ownership 和 borrowing 規則（在第 4 章中介紹），以確保這個參考以及對 vector 內容的任何其他參考都保持有效。回想一下，規則規定在同一個 scope 中不能同時有可變和不可變的參考。這個規則適用於列表 8-6，我們持有一個對 vector 中第一個元素的不可變參考，並嘗試在結尾新增一個元素。如果我們還想在函式稍後引用該元素，這個程式將無法運作。

```rust
    let mut v = vec![1, 2, 3, 4, 5];

    let first = &v[0];

    v.push(6);

    println!("The first element is: {first}");
```

列表 8-6：在持有一個項目參考的同時，嘗試新增元素到 vector

編譯這段程式碼會產生以下錯誤：

```
$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
error[E0502]: cannot borrow `v` as mutable because it is also borrowed as immutable
 --> src/main.rs:6:5
  |
4 |     let first = &v[0];
  |                  - immutable borrow occurs here
5 |
6 |     v.push(6);
  |     ^^^^^^^^^ mutable borrow occurs here
7 |
8 |     println!("The first element is: {first}");
  |                                     ------- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `collections` (bin "collections") due to 1 previous error
```

列表 8-6 的程式碼可能看起來應該可以運作：為什麼對第一個元素的參考會關心 vector 結尾的變化呢？這個錯誤是因為 vectors 的運作方式：因為 vectors 將值在記憶體中彼此相鄰放置，所以將新元素加到 vector 的結尾可能需要分配新的記憶體並將舊元素複製到新的空間，如果 vector 目前儲存的位置沒有足夠的空間將所有元素相鄰放置。在這種情況下，對第一個元素的參考將會指向被釋放的記憶體。Borrowing 規則防止程式最終陷入這種情況。

> 注意：關於 `Vec<T>` 型別的更多實作細節，請參閱位於 _https://doc.rust-lang.org/nomicon/vec/vec.html_ 的「The Rustonomicon」。

### 遍歷 Vector 中的值

要逐一存取 vector 中的每個元素，我們會遍歷所有元素，而不是使用索引一次存取一個。列表 8-7 展示了如何使用 `for` 迴圈來取得 `i32` 值 vector 中每個元素的不可變參考並將它們印出。

```rust
let v = vec![100, 32, 57];
for i in &v {
    println!("{i}");
}
```

列表 8-7：使用 `for` 迴圈遍歷元素來印出 vector 中的每個元素

我們也可以遍歷一個可變 vector 中每個元素的可變參考，以便對所有元素進行修改。列表 8-8 中的 `for` 迴圈會將每個元素加上 `50`。

```rust
let mut v = vec![100, 32, 57];
for i in &mut v {
    *i += 50;
}
```

列表 8-8：遍歷 vector 中元素的可變參考

要改變可變參考所指向的值，我們必須使用 `*` dereference 運算子來取得 `i` 中的值，然後才能使用 `+=` 運算子。我們將在第 15 章的「跟隨參考到值」一節中更詳細地討論 dereference 運算子。

遍歷一個 vector，無論是不可變的還是可變的，都是安全的，這要歸功於 borrow checker 的規則。如果我們試圖在列表 8-7 和列表 8-8 的 `for` 迴圈主體中插入或移除項目，我們會得到一個與列表 8-6 中程式碼類似的編譯器錯誤。`for` 迴圈持有的對 vector 的參考阻止了對整個 vector 的同時修改。

### 使用 Enum 儲存多種類型

Vectors 只能儲存相同型別的值。這可能很不方便；肯定有需要儲存不同型別項目列表的用例。幸運的是，enum 的變體都定義在同一個 enum 型別下，所以當我們需要用一個型別來代表不同型別的元素時，我們可以定義並使用一個 enum！

例如，假設我們想要從試算表的一行中取得值，其中該行的某些欄位包含整數，某些是浮點數，某些是字串。我們可以定義一個 enum，其變體將存放不同的值型別，而所有的 enum 變體都將被視為同一型別：即該 enum 的型別。然後我們可以建立一個 vector 來存放該 enum，從而最終存放不同的型別。我們在列表 8-9 中示範了這一點。

```rust
    enum SpreadsheetCell {
        Int(i32),
        Float(f64),
        Text(String),
    }

    let row = vec![
        SpreadsheetCell::Int(3),
        SpreadsheetCell::Text(String::from("blue")),
        SpreadsheetCell::Float(10.12),
    ];
```

列表 8-9：定義一個 `enum` 以在一個 vector 中儲存不同型別的值

Rust 需要在編譯時知道 vector 中會有哪些型別，這樣它才能確切地知道在 heap 上需要多少記憶體來儲存每個元素。我們也必須明確指出這個 vector 中允許哪些型別。如果 Rust 允許一個 vector 存放任何型別，那麼就有可能有一或多個型別會導致對 vector 元素執行的操作出現錯誤。使用 enum 加上 `match` 表達式意味著 Rust 會在編譯時確保每個可能的情況都被處理，正如在第 6 章中所討論的。

如果您不知道程式在執行時會得到哪些詳盡的型別來儲存在 vector 中，enum 的技巧將無法運作。相反地，您可以使用 trait object，我們將在第 18 章中介紹。

現在我們已經討論了一些最常見的使用 vector 的方式，請務必查閱 API 文件，了解標準函式庫為 `Vec<T>` 定義的所有眾多有用方法。例如，除了 `push`，還有一個 `pop` 方法可以移除並回傳最後一個元素。

### Drop 一個 Vector 會同時 Drop 其元素

就像任何其他的 `struct` 一樣，vector 在離開 scope 時會被釋放，如列表 8-10 所註解。

```rust
    {
        let v = vec![1, 2, 3, 4];

        // do stuff with v
    } // <- v goes out of scope and is freed here
```

列表 8-10：顯示 vector 及其元素在何處被 drop

當 vector 被 drop 時，它的所有內容也會被 drop，這意味著它所持有的整數將被清理。Borrow checker 確保任何對 vector 內容的參考都只在 vector 本身有效時使用。

讓我們繼續看下一個 collection 型別：`String`！

## 使用 String 儲存 UTF-8 編碼的文字

我們在第 4 章談過 strings，但現在我們將更深入地探討它們。新的 Rustaceans 通常會因為三個原因的組合而在 strings 上卡關：Rust 傾向於揭露可能的錯誤、strings 作為資料結構比許多程式設計師想像的要複雜，以及 UTF-8。這些因素結合在一起，對於來自其他程式語言的人來說，可能會顯得困難。

我們在 collections 的背景下討論 strings，因為 strings 是以位元組集合的形式實作的，再加上一些方法，以便在這些位元組被解釋為文字時提供有用的功能。在本節中，我們將討論 `String` 上每種 collection 型別都具備的操作，例如建立、更新和讀取。我們還將討論 `String` 與其他 collections 的不同之處，也就是說，由於人和電腦對 `String` 資料的解釋方式不同，對 `String` 進行索引變得複雜。

### 什麼是 String？

我們首先定義我們所說的 _string_ 這個詞是什麼意思。Rust 的核心語言中只有一種 string 型別，那就是 string slice `str`，通常以其借用形式 `&str` 出現。在第 4 章中，我們討論了 _string slices_，它們是對儲存在別處的某些 UTF-8 編碼字串資料的參考。例如，字串字面值儲存在程式的二進位檔案中，因此是 string slices。

`String` 型別是由 Rust 的標準函式庫提供，而不是編碼在核心語言中，它是一種可增長、可變、有 ownership、UTF-8 編碼的 string 型別。當 Rustaceans 在 Rust 中提到「strings」時，他們可能指的是 `String` 或 string slice `&str` 型別，而不僅僅是其中一種。雖然本節主要關於 `String`，但這兩種型別在 Rust 的標準函式庫中都大量使用，並且 `String` 和 string slices 都是 UTF-8 編碼的。

### 建立新的 String

許多 `Vec<T>` 可用的操作也適用於 `String`，因為 `String` 實際上是作為位元組 vector 的一個 wrapper 實作的，並帶有一些額外的保證、限制和功能。一個在 `Vec<T>` 和 `String` 上運作方式相同的函式範例是 `new` 函式，用於建立一個實例，如列表 8-11 所示。

```rust
let mut s = String::new();
```

列表 8-11：建立一個新的、空的 `String`

這行程式碼建立了一個名為 `s` 的新的空字串，我們可以在其中載入資料。通常，我們會有一些初始資料來開始這個字串。為此，我們使用 `to_string` 方法，這個方法在任何實作了 `Display` trait 的型別上都可用，字串字面值就是如此。列表 8-12 顯示了兩個範例。

```rust
    let data = "initial contents";

    let s = data.to_string();

    // The method also works on a literal directly:
    let s = "initial contents".to_string();
```

列表 8-12：使用 `to_string` 方法從字串字面值建立一個 `String`

這段程式碼建立了一個包含 `initial contents` 的字串。

我們也可以使用 `String::from` 函式從字串字面值建立一個 `String`。列表 8-13 中的程式碼與列表 8-12 中使用 `to_string` 的程式碼是等效的。

```rust
let s = String::from("initial contents");
```

列表 8-13：使用 `String::from` 函式從字串字面值建立一個 `String`

因為 strings 用途廣泛，我們可以使用許多不同的通用 API 來處理 strings，這給了我們很多選擇。其中一些可能看起來是多餘的，但它們都有各自的用處！在這種情況下，`String::from` 和 `to_string` 做的是同樣的事情，所以您選擇哪一個是風格和可讀性的問題。

請記住，strings 是 UTF-8 編碼的，所以我們可以在其中包含任何正確編碼的資料，如列表 8-14 所示。

```rust
let hello = String::from("السلام عليكم");
let hello = String::from("Dobrý den");
let hello = String::from("Hello");
let hello = String::from("שלום");
let hello = String::from("नमस्ते");
let hello = String::from("こんにちは");
let hello = String::from("안녕하세요");
let hello = String::from("你好");
let hello = String::from("Olá");
let hello = String::from("Здравствуйте");
let hello = String::from("Hola");
```

列表 8-14：在 strings 中儲存不同語言的問候語

所有這些都是有效的 `String` 值。

### 更新 String

`String` 的大小可以增長，其內容可以改變，就像 `Vec<T>` 的內容一樣，如果您將更多資料推入其中。此外，您可以方便地使用 `+` 運算子或 `format!` macro 來串接 `String` 值。

#### 使用 push_str 與 push 附加至 String

我們可以使用 `push_str` 方法來附加一個 string slice 來增長 `String`，如列表 8-15 所示。

```rust
let mut s = String::from("foo");
s.push_str("bar");
```

列表 8-15：使用 `push_str` 方法將 string slice 附加到 `String`

在這兩行之後，`s` 將包含 `foobar`。`push_str` 方法接受一個 string slice，因為我們不一定想要取得參數的 ownership。例如，在列表 8-16 的程式碼中，我們希望在將 `s2` 的內容附加到 `s1` 之後，還能使用 `s2`。

```rust
let mut s1 = String::from("foo");
let s2 = "bar";
s1.push_str(s2);
println!("s2 is {s2}");
```

列表 8-16：在將其內容附加到 `String` 之後使用 string slice

如果 `push_str` 方法取得了 `s2` 的 ownership，我們就無法在最後一行印出它的值。然而，這段程式碼如我們預期地運作！

`push` 方法接受一個單一字元作為參數，並將其加到 `String` 中。列表 8-17 使用 `push` 方法將字母 _l_ 加到一個 `String` 中。

```rust
let mut s = String::from("lo");
s.push('l');
```

列表 8-17：使用 `push` 將一個字元加到 `String` 值中

結果，`s` 將包含 `lol`。

#### 使用 + 運算子或 format! 巨集來串接

通常，您會想要結合兩個現有的字串。一種方法是使用 `+` 運算子，如列表 8-18 所示。

```rust
let s1 = String::from("Hello, ");
let s2 = String::from("world!");
let s3 = s1 + &s2; // note s1 has been moved here and can no longer be used
```

列表 8-18：使用 `+` 運算子將兩個 `String` 值結合成一個新的 `String` 值

字串 `s3` 將包含 `Hello, world!`。`s1` 在相加後不再有效的原因，以及我們使用 `s2` 的參考的原因，與我們使用 `+` 運算子時呼叫的方法的簽章有關。`+` 運算子使用 `add` 方法，其簽章大致如下：

```rust
fn add(self, s: &str) -> String {
```

在標準函式庫中，您會看到 `add` 是使用 generics 和關聯型別定義的。在這裡，我們代入了具體的型別，這就是當我們用 `String` 值呼叫這個方法時發生的情況。我們將在第 10 章討論 generics。這個簽章給了我們理解 `+` 運算子棘手之處的線索。

首先，`s2` 有一個 `&`，這意味著我們是將第二個字串的*參考*加到第一個字串上。這是因為 `add` 函式中的 `s` 參數：我們只能將一個 `&str` 加到 `String` 上；我們不能將兩個 `String` 值相加。但是等等——`&s2` 的型別是 `&String`，而不是 `&str`，如 `add` 的第二個參數所指定。那麼為什麼列表 8-18 可以編譯呢？

我們能夠在對 `add` 的呼叫中使用 `&s2` 的原因是，編譯器可以將 `&String` 參數*強制轉換*成 `&str`。當我們呼叫 `add` 方法時，Rust 使用 _deref coercion_，這裡它將 `&s2` 轉換成 `&s2[..]`。我們將在第 15 章更深入地討論 deref coercion。因為 `add` 不會取得 `s` 參數的 ownership，所以 `s2` 在這個操作之後仍然是一個有效的 `String`。

其次，我們可以在簽章中看到 `add` 取得了 `self` 的 ownership，因為 `self` _沒有_ `&`。這意味著列表 8-18 中的 `s1` 將被移動到 `add` 呼叫中，並且在那之後將不再有效。所以，雖然 `let s3 = s1 + &s2;` 看起來像是會複製兩個字串並建立一個新的，但這個陳述式實際上取得了 `s1` 的 ownership，附加了 `s2` 內容的副本，然後回傳結果的 ownership。換句話說，它看起來像是在做很多複製，但實際上並不是；實作比複製更有效率。

如果我們需要串接多個字串，`+` 運算子的行為會變得笨拙：

```rust
    let s1 = String::from("tic");
    let s2 = String::from("tac");
    let s3 = String::from("toe");

    let s = s1 + "-" + &s2 + "-" + &s3;
```

此時，`s` 將會是 `tic-tac-toe`。有了所有的 `+` 和 `"` 字元，很難看清楚發生了什麼。對於更複雜的字串組合，我們可以改用 `format!` macro：

```rust
    let s1 = String::com("tic");
    let s2 = String::from("tac");
    let s3 = String::from("toe");

    let s = format!("{s1}-{s2}-{s3}");
```

這段程式碼同樣會將 `s` 設為 `tic-tac-toe`。`format!` macro 的運作方式類似 `println!`，但它不是將輸出印到螢幕上，而是回傳一個帶有內容的 `String`。使用 `format!` 的程式碼版本更容易閱讀，而且 `format!` macro 產生的程式碼使用參考，所以這個呼叫不會取得任何參數的 ownership。

### 對 String 做索引

在許多其他程式語言中，通過索引引用來存取字串中的個別字元是有效且常見的操作。然而，如果您在 Rust 中嘗試使用索引語法存取 `String` 的部分，您會得到一個錯誤。請看列表 8-19 中的無效程式碼。

```rust
let s1 = String::from("hi");
let h = s1[0];
```

列表 8-19：嘗試對 String 使用索引語法

這段程式碼會導致以下錯誤：

```
$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
error[E0277]: the type `str` cannot be indexed by `{integer}`
 --> src/main.rs:3:16
  |
3 |     let h = s1[0];
  |                ^ string indices are ranges of `usize`
  |
  = note: you can use `.chars().nth()` or `.bytes().nth()`
          for more information, see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>
  = help: the trait `SliceIndex<str>` is not implemented for `{integer}`
          but trait `SliceIndex<[_]>` is implemented for `usize`
  = help: for that trait implementation, expected `[_]`, found `str`
  = note: required for `String` to implement `Index<{integer}>`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `collections` (bin "collections") due to 1 previous error
```

錯誤和註記說明了原因：Rust 的 strings 不支援索引。但為什麼不呢？要回答這個問題，我們需要討論 Rust 如何在記憶體中儲存 strings。

#### 內部表示法

`String` 是 `Vec<u8>` 的一個 wrapper。讓我們看看列表 8-14 中一些我們正確編碼的 UTF-8 範例字串。首先是這個：

```rust
let hello = String::from("Hola");
```

在這種情況下，`len` 將是 `4`，這意味著儲存字串 `"Hola"` 的 vector 長度是 4 個位元組。每個字母在 UTF-8 編碼時都佔用一個位元組。然而，下面這行可能會讓您驚訝（請注意，這個字串以大寫西里爾字母 _Ze_ 開頭，而不是數字 3）：

```rust
let hello = String::from("Здравствуйте");
```

如果您被問到這個字串有多長，您可能會說 12。事實上，Rust 的答案是 24：這是在 UTF-8 中編碼「Здравствуйте」所需的位元組數，因為該字串中的每個 Unicode 純量值都需要 2 個位元組的儲存空間。因此，對字串位元組的索引不一定會對應到一個有效的 Unicode 純量值。為了證明這一點，請看這段無效的 Rust 程式碼：

```rust
let hello = "Здравствуйте";
let answer = &hello[0];
```

您已經知道 `answer` 不會是 `З`，也就是第一個字母。在 UTF-8 編碼中，`З` 的第一個位元組是 `208`，第二個是 `151`，所以 `answer` 似乎應該是 `208`，但 `208` 本身不是一個有效的字元。如果使用者要求這個字串的第一個字母，回傳 `208` 很可能不是他們想要的；然而，這是 Rust 在位元組索引 0 處擁有的唯一資料。即使字串只包含拉丁字母，使用者通常也不希望回傳位元組值：如果 `&"hi"[0]` 是回傳位元組值的有效程式碼，它會回傳 `104`，而不是 `h`。

答案是，為了避免回傳非預期的值並導致可能不會立即發現的 bug，Rust 根本不會編譯這段程式碼，並在開發過程的早期就防止誤解。

#### Bytes、純量值與字形叢集！天啊！

關於 UTF-8 的另一個重點是，從 Rust 的角度來看，實際上存在三種相關的方式來看待 strings：作為位元組（bytes）、純量值（scalar values）和字形叢集（grapheme clusters）（最接近我們所說的_字母_）。

如果我們看以梵文書寫的印地語單詞「नमस्ते」，它被儲存為一個 `u8` 值的 vector，看起來像這樣：

```
[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,
224, 165, 135]
```

這是 18 個位元組，也是電腦最終儲存這些資料的方式。如果我們將它們視為 Unicode 純量值，也就是 Rust 的 `char` 型別，那些位元組看起來像這樣：

```
['न', 'म', 'स', '्', 'त', 'े']
```

這裡有六個 `char` 值，但第四個和第六個不是字母：它們是變音符號，本身沒有意義。最後，如果我們將它們視為字形叢集，我們會得到一個人會稱為構成這個印地語單詞的四個字母：

```
["न", "म", "स्", "ते"]
```

Rust 提供了不同的方式來解釋電腦儲存的原始字串資料，以便每個程式可以選擇它需要的解釋方式，無論資料是哪種人類語言。

Rust 不允許我們對 `String` 進行索引以取得字元的最後一個原因是，索引操作預期總是花費常數時間 (O(1))。但是用 `String` 是不可能保證這種效能的，因為 Rust 必須從頭走到索引處來確定有多少個有效的字元。

### 切割 String

對字串進行索引通常不是個好主意，因為字串索引操作的回傳型別應該是什麼並不清楚：是一個位元組值、一個字元、一個字形叢集，還是一個 string slice。因此，如果您真的需要使用索引來建立 string slices，Rust 會要求您更具體一些。

您可以使用 `[]` 搭配一個範圍來建立包含特定位元組的 string slice，而不是用 `[]` 搭配單一數字進行索引：

```rust
let hello = "Здравствуйте";

let s = &hello[0..4];
```

在這裡，`s` 將是一個 `&str`，包含該字串的前四個位元組。早些時候，我們提到這些字元每個都是兩個位元組，這意味著 `s` 將是 `Зд`。

如果我們試圖用 `&hello[0..1]` 這樣的方式只切割一個字元的部分位元組，Rust 會在執行時 panic，就像在 vector 中存取無效索引一樣：

```
$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/collections`

thread 'main' panicked at src/main.rs:4:19:
byte index 1 is not a char boundary; it is inside 'З' (bytes 0..2) of `Здравствуйте`
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```

在使用範圍建立 string slices 時應該要小心，因為這樣做可能會使您的程式崩潰。

### 遍歷 String 的方法

處理字串片段的最佳方式是明確表示您想要的是字元還是位元組。對於個別的 Unicode 純量值，請使用 `chars` 方法。在「Зд」上呼叫 `chars` 會分離出並回傳兩個 `char` 型別的值，您可以遍歷結果來存取每個元素：

```rust
for c in "Зд".chars() {
    println!("{c}");
}
```

這段程式碼會印出以下內容：

```
З
д
```

或者，`bytes` 方法會回傳每個原始位元組，這可能適合您的領域：

```rust
for b in "Зд".bytes() {
    println!("{b}");
}
```

這段程式碼會印出構成這個字串的四個位元組：

```
208
151
208
180
```

但請務必記住，有效的 Unicode 純量值可能由多於一個位元組組成。

從 strings 中取得字形叢集，就像梵文文字一樣，是複雜的，所以這個功能不由標準函式庫提供。如果這是您需要的功能，crates.io 上有可用的 crates。

### String 並不簡單

總結來說，strings 是複雜的。不同的程式語言對於如何向程式設計師呈現這種複雜性做出了不同的選擇。Rust 選擇將正確處理 `String` 資料作為所有 Rust 程式的預設行為，這意味著程式設計師必須在一開始就更深入地思考如何處理 UTF-8 資料。這種取捨暴露了比其他程式語言中更明顯的 strings 複雜性，但它能防止您在開發生命週期的後期才處理涉及非 ASCII 字元的錯誤。

好消息是，標準函式庫提供了許多基於 `String` 和 `&str` 型別的功能，以幫助正確處理這些複雜情況。請務必查閱文件，尋找有用的方法，例如用於在字串中搜尋的 `contains` 和用於將字串部分替換為另一字串的 `replace`。

讓我們轉向一些不那麼複雜的東西：hash maps！

## 使用 Hash Map 儲存鍵與其對應的值

我們最後一個常見的 collection 是 _hash map_。`HashMap<K, V>` 型別使用 _hashing function_ 儲存 `K` 型別的鍵到 `V` 型別的值的對應關係，這個函式決定了它如何將這些鍵和值放入記憶體中。許多程式語言支援這種資料結構，但它們通常使用不同的名稱，例如 _hash_、_map_、_object_、_hash table_、_dictionary_ 或 _associative array_，僅舉幾例。

當您不想像使用 vector 那樣透過索引來查找資料，而是想使用可以是任何型別的鍵時，Hash maps 非常有用。例如，在遊戲中，您可以用一個 hash map 來記錄每個隊伍的分數，其中每個鍵是隊伍的名稱，值是每個隊伍的分數。給定一個隊伍名稱，您就可以檢索其分數。

我們將在本節中介紹 hash maps 的基本 API，但標準函式庫為 `HashMap<K, V>` 定義的函式中還隱藏著更多好東西。一如既往，請查閱標準函式庫文件以獲取更多資訊。

### 建立新的 Hash Map

建立一個空的 hash map 的一種方法是使用 `new` 並用 `insert` 新增元素。在列表 8-20 中，我們正在記錄兩個隊伍的分數，它們的名稱是 _Blue_ 和 _Yellow_。藍隊以 10 分開始，黃隊以 50 分開始。

```rust
    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from("Blue"), 10);
    scores.insert(String::from("Yellow"), 50);
```

列表 8-20：建立一個新的 hash map 並插入一些鍵和值

請注意，我們需要先從標準函式庫的 collections 部分 `use` `HashMap`。在我們三個常見的 collections 中，這個是最不常用的，所以它不包含在 prelude 中自動引入 scope 的功能裡。Hash maps 得到的標準函式庫支援也較少；例如，沒有內建的 macro 來建構它們。

就像 vectors 一樣，hash maps 將它們的資料儲存在 heap 上。這個 `HashMap` 的鍵是 `String` 型別，值是 `i32` 型別。像 vectors 一樣，hash maps 是同質的：所有的鍵必須是相同的型別，所有的值也必須是相同的型別。

### 存取 Hash Map 中的值

我們可以透過將鍵提供給 `get` 方法來從 hash map 中取出一個值，如列表 8-21 所示。

```rust
    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from("Blue"), 10);
    scores.insert(String::from("Yellow"), 50);

    let team_name = String::from("Blue");
    let score = scores.get(&team_name).copied().unwrap_or(0);
```

列表 8-21：存取儲存在 hash map 中的藍隊分數

在這裡，`score` 將會是與藍隊關聯的值，結果將是 `10`。`get` 方法回傳一個 `Option<&V>`；如果 hash map 中沒有該鍵的值，`get` 將回傳 `None`。這個程式透過呼叫 `copied` 來處理 `Option`，以得到一個 `Option<i32>` 而不是 `Option<&i32>`，然後 `unwrap_or` 在 `scores` 沒有該鍵的條目時將 `score` 設為零。

我們可以像處理 vectors 一樣，用 `for` 迴圈來遍歷 hash map 中的每個鍵值對：

```rust
    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from("Blue"), 10);
    scores.insert(String::from("Yellow"), 50);

    for (key, value) in &scores {
        println!("{key}: {value}");
    }
```

這段程式碼會以任意順序印出每一對：

```
Yellow: 50
Blue: 10
```

### Hash Map 與 Ownership

對於實作 `Copy` trait 的型別，比如 `i32`，值會被複製到 hash map 中。對於像 `String` 這樣有 ownership 的值，值將會被移動，而 hash map 將成為這些值的 owner，如列表 8-22 所示。

```rust
    use std::collections::HashMap;

    let field_name = String::from("Favorite color");
    let field_value = String::from("Blue");

    let mut map = HashMap::new();
    map.insert(field_name, field_value);
    // field_name and field_value are invalid at this point, try using them and
    // see what compiler error you get!
```

列表 8-22：顯示鍵和值一旦被插入後就由 hash map 所擁有

在變數 `field_name` 和 `field_value` 被移動到 hash map 之後，我們就無法再使用它們了，這是透過呼叫 `insert` 實現的。

如果我們將值的參考插入到 hash map 中，這些值將不會被移動到 hash map 中。參考所指向的值必須在 hash map 有效的期間內保持有效。我們將在第 10 章的「使用
Lifetimes 驗證參考」中更詳細地討論這些問題。

### 更新 Hash Map

雖然鍵值對的數量是可增長的，但每個唯一的鍵在同一時間只能有一個與之關聯的值（但反之則不然：例如，藍隊和黃隊都可以在 `scores` hash map 中儲存值 `10`）。

當您想改變 hash map 中的資料時，您必須決定如何處理鍵已經有賦值的情況。您可以將舊值替換為新值，完全忽略舊值。您可以保留舊值並忽略新值，只在鍵*沒有*值時才加入新值。或者您可以結合舊值和新值。讓我們來看看如何做到這些！

#### 覆寫一個值

如果我們將一個鍵和一個值插入到 hash map 中，然後用不同的值再次插入同一個鍵，與該鍵關聯的值將被替換。儘管列表 8-23 的程式碼呼叫了 `insert` 兩次，但 hash map 只會包含一個鍵值對，因為我們兩次都是為藍隊的鍵插入值。

```rust
    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from("Blue"), 10);
    scores.insert(String::from("Blue"), 25);

    println!("{scores:?}");
```

列表 8-23：替換儲存在特定鍵下的值

這段程式碼會印出 `{"Blue": 25}`。原始的值 `10` 已經被覆寫了。

<!-- Old headings. Do not remove or links may break. -->

<a id="only-inserting-a-value-if-the-key-has-no-value"></a>

#### 只在鍵沒有對應值時才新增

一個常見的做法是檢查 hash map 中是否已經存在某個特定的鍵及其值，然後採取以下行動：如果該鍵存在於 hash map 中，現有的值應保持不變；如果該鍵不存在，則插入它和一個值。

Hash maps 有一個專門的 API 來處理這個，叫做 `entry`，它接受您想檢查的鍵作為參數。`entry` 方法的回傳值是一個名為 `Entry` 的 enum，它代表一個可能存在或不存在的值。假設我們想檢查黃隊的鍵是否有與之關聯的值。如果沒有，我們想插入值 `50`，藍隊也一樣。使用 `entry` API，程式碼如列表 8-24 所示。

```rust
    use std::collections::HashMap;

    let mut scores = HashMap::new();
    scores.insert(String::from("Blue"), 10);

    scores.entry(String::from("Yellow")).or_insert(50);
    scores.entry(String::from("Blue")).or_insert(50);

    println!("{scores:?}");
```

列表 8-24：使用 `entry` 方法只在鍵尚未有值時才插入

`Entry` 上的 `or_insert` 方法被定義為：如果對應 `Entry` 的鍵存在，則回傳一個指向該值的可變參考；如果不存在，則將參數作為該鍵的新值插入，並回傳一個指向新值的可變參考。這種技巧比我們自己編寫邏輯要簡潔得多，而且與 borrow checker 的配合也更好。

執行列表 8-24 的程式碼將印出 `{"Yellow": 50, "Blue": 10}`。第一次呼叫 `entry` 會為黃隊的鍵插入值 `50`，因為黃隊還沒有值。第二次呼叫 `entry` 不會改變 hash map，因為藍隊已經有值 `10`。

#### 根據舊值來更新值

另一個常見的 hash maps 用例是查找一個鍵的值，然後根據舊值來更新它。例如，列表 8-25 展示了計算一段文字中每個單詞出現次數的程式碼。我們使用一個 hash map，以單詞為鍵，並增加值來記錄我們看到該單詞的次數。如果這是我們第一次看到一個單詞，我們會先插入值 `0`。

```rust
    use std::collections::HashMap;

    let text = "hello world wonderful world";

    let mut map = HashMap::new();

    for word in text.split_whitespace() {
        let count = map.entry(word).or_insert(0);
        *count += 1;
    }

    println!("{map:?}");
```

列表 8-25：使用儲存單詞和計數的 hash map 來計算單詞出現次數

這段程式碼會印出 `{"world": 2, "hello": 1, "wonderful": 1}`。您可能會看到相同的鍵值對以不同的順序印出：回想一下「存取 Hash Map 中的值」部分，遍歷 hash map 是以任意順序進行的。

`split_whitespace` 方法回傳一個在 `text` 值中以空白分隔的子 slice 的 iterator。`or_insert` 方法回傳一個指向指定鍵值的可變參考 (`&mut V`)。在這裡，我們將該可變參考儲存在 `count` 變數中，所以為了賦值給那個值，我們必須先使用星號 (`*`) 對 `count` 進行 dereference。這個可變參考在 `for` 迴圈結束時會離開 scope，所以所有這些變更都是安全的，並且被 borrowing 規則所允許。

### Hashing 函式

預設情況下，`HashMap` 使用一個名為 _SipHash_ 的 hashing 函式，它可以提供對涉及 hash tables 的 denial-of-service (DoS) 攻擊的抵抗力[^siphash]<!-- ignore -->。這不是現有最快的 hashing 演算法，但為了更好的安全性而犧牲效能是值得的。如果您對程式碼進行效能分析，發現預設的 hash 函式對您的目的來說太慢了，您可以透過指定一個不同的 hasher 來切換到另一個函式。_hasher_ 是一個實作 `BuildHasher` trait 的型別。我們將在第 10 章討論 traits 以及如何實作它們。您不一定需要從頭開始實作自己的 hasher；crates.io
上有其他 Rust 使用者分享的函式庫，提供了實作許多常見 hashing 演算法的 hashers。

## 總結

當您需要在程式中儲存、存取和修改資料時，Vectors、strings 和 hash maps 將提供大量必要的功能。以下是一些您現在應該有能力解決的練習：

1. 給定一個整數列表，使用 vector 並回傳該列表的中位數（排序後，位於中間位置的值）和眾數（出現最多次的值；這裡 hash map 會很有用）。
1. 將字串轉換為 pig latin。每個單詞的第一個子音被移到單詞的末尾並加上 _ay_，所以 _first_ 變成 _irst-fay_。以母音開頭的單詞則在末尾加上 _hay_（_apple_ 變成 _apple-hay_）。請記住關於 UTF-8 編碼的細節！
1. 使用 hash map 和 vectors，建立一個文字介面，允許使用者將員工姓名新增到公司的某個部門；例如，「Add Sally to Engineering」或「Add Amir to Sales」。然後讓使用者可以按字母順序檢索某個部門的所有人員列表，或公司內所有部門的人員列表。

標準函式庫的 API 文件描述了 vectors、strings 和 hash maps 擁有的方法，這些方法對解決這些練習會很有幫助！

我們正進入更複雜的程式，其中操作可能會失敗，所以現在是討論錯誤處理的絕佳時機。我們接下來就會討論這個！
