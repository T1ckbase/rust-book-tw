<!-- DO NOT EDIT THIS FILE.

This file is periodically generated from the content in the `/src/`
directory, so all fixes need to be made in `/src/`.
-->

[TOC]

## 附錄 E：Edition

在第一章中，你看到了 `cargo new` 會在你的 _Cargo.toml_ 檔案中加入一些關於 edition 的元資料。本附錄將會探討其意義！

Rust 語言與編譯器有著六週的發布週期，這代表使用者會不斷收到新功能。其他程式語言較不常發布大型變更；Rust 則更頻繁地發布較小的更新。一段時間後，所有這些微小的變更會累積起來。但從一個版本到下一個版本，很難回過頭來說：「哇，在 Rust 1.10 和 Rust 1.31 之間，Rust 改變了很多！」

每隔兩到三年，Rust 團隊會推出一個新的 Rust _edition_。每個 edition 都會將已發布的功能整合到一個清晰的套件中，並附上完整的更新文件和工具。新的 edition 會作為平常六週發布流程的一部分推出。

Edition 對不同的人有不同的用途：

- 對於活躍的 Rust 使用者來說，新的 edition 將增量變更整合到一個易於理解的套件中。
- 對於非使用者而言，新的 edition 意味著一些重大的進展已經實現，這可能讓 Rust 值得再次關注。
- 對於開發 Rust 的人來說，新的 edition 為整個專案提供了一個凝聚點。

在本書撰寫時，共有三個 Rust edition 可用：Rust 2015、Rust 2018 和 Rust 2021。本書是使用 Rust 2021 edition 的風格編寫的。

_Cargo.toml_ 中的 `edition` 鍵值指出編譯器應該為你的程式碼使用哪個 edition。如果該鍵值不存在，Rust 會基於向後相容性的原因，使用 `2015` 作為 edition 的值。

每個專案都可以選擇使用預設 2015 edition 以外的版本。Edition 可能包含不相容的變更，例如加入一個與程式碼中識別字衝突的新 keyword。然而，除非你選擇加入這些變更，否則即使你升級了所使用的 Rust 編譯器版本，你的程式碼仍然可以繼續編譯。

所有 Rust 編譯器版本都支援在該編譯器發布之前就已存在的任何 edition，並且它們可以將任何受支援 edition 的 crate 連結在一起。Edition 的變更只會影響編譯器初始解析程式碼的方式。因此，如果你正在使用 Rust 2015，而你的某個依賴項使用的是 Rust 2018，你的專案將能夠編譯並使用該依賴項。反之亦然，如果你的專案使用 Rust 2018，而依賴項使用 Rust 2015，也是可行的。

需要澄清的是：大多數功能在所有 edition 中都可用。無論使用哪個 Rust edition 的開發者，都會隨著新的穩定版本發布而看到改進。然而，在某些情況下，主要是當加入新的 keyword 時，一些新功能可能只在較新的 edition 中提供。如果你想利用這些功能，就需要切換 edition。

想了解更多細節，《_Edition 指南_》（_The_ _Edition Guide_）位於 _https://doc.rust-lang.org/stable/edition-guide_，它是一本關於 edition 的完整書籍，其中列舉了各 edition 之間的差異，並解釋了如何透過 `cargo fix` 自動將你的程式碼升級到新的 edition。
