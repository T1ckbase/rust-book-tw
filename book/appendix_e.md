<!-- DO NOT EDIT THIS FILE.

This file is periodically generated from the content in the `/src/`
directory, so all fixes need to be made in `/src/`.
-->

[TOC]

## 附錄 E：版本

在第 1 章中，你曾看到 `cargo new` 會在你的 _Cargo.toml_ 檔案中新增一些關於 edition 的 metadata。本附錄將說明其意義！

Rust 語言和 compiler 具有六週的 release cycle，這表示使用者可以持續獲得新的 features。其他 programming languages 較不常發布較大的變更；Rust 則更頻繁地發布較小的 updates。過了一段時間後，這些微小的變更都會累積起來。但從一個 release 到另一個 release，很難回頭說：「哇，從 Rust 1.10 到 Rust 1.31，Rust 改變了好多！」

每隔兩到三年，Rust 團隊就會推出新的 Rust _edition_。每個 edition 都會將已推出的 features 整合到一個清晰的 package 中，並提供完整更新的 documentation 和 tooling。新 edition 會作為標準的六週 release process 的一部分發布。

Editions 對於不同的人有不同的用途：

- 對於活躍的 Rust 使用者來說，新的 edition 將漸進的變更整合到一個易於理解的 package 中。
- 對於非使用者來說，新的 edition 表示一些重大的改進已經完成，這可能會讓 Rust 值得再次關注。
- 對於那些開發 Rust 的人來說，新的 edition 為整個 project 提供了一個凝聚點。

在撰寫本文時，有三個 Rust edition 可用：Rust 2015、Rust 2018 和 Rust 2021。本書使用 Rust 2021 edition 的慣用語來撰寫。

`edition` key 在 _Cargo.toml_ 中指出 compiler 應該為你的程式碼使用哪個 edition。如果該 key 不存在，Rust 會為了 backward compatibility 的原因，使用 `2015` 作為 edition 的值。

每個 project 都可以選擇使用除了 default 的 2015 edition 以外的 edition。Editions 可能包含 incompatible 的變更，例如新增一個與程式碼中的 identifiers 衝突的 new keyword。然而，除非你選擇啟用這些變更，否則即使你升級了所使用的 Rust compiler 版本，你的程式碼仍將繼續 compile。

所有 Rust compiler 版本都支援在該 compiler 發布之前存在的任何 edition，並且它們可以將任何受支援 edition 的 crates 連結在一起。Edition 的變更只會影響 compiler 最初解析程式碼的方式。因此，如果你使用 Rust 2015 並且你的其中一個 dependencies 使用 Rust 2018，你的 project 將會 compile 並能夠使用該 dependency。你的 project 使用 Rust 2018 而 dependency 使用 Rust 2015 的相反情況也同樣可行。

需要澄清的是：大多數 features 將在所有 editions 上可用。使用任何 Rust edition 的開發者都將隨著新的 stable releases 而持續看到改進。然而，在某些情況下，主要是當新增了 new keywords 時，某些新 features 可能只在較新的 editions 中可用。如果你想利用這些 features，你需要切換 editions。

欲了解更多詳細資訊，_The_ _Edition Guide_ (位於 _https://doc.rust-lang.org/stable/edition-guide_) 是一本關於 editions 的完整書籍，其中列舉了 editions 之間的差異，並解釋了如何透過 `cargo fix` 自動將你的程式碼升級到新的 edition。
