<!-- DO NOT EDIT THIS FILE.

This file is periodically generated from the content in the `/src/`
directory, so all fixes need to be made in `/src/`.
-->

[TOC]

# 開始使用

讓我們開始你的 Rust 旅程！要學習的東西很多，但每個旅程都從某個地方開始。在本章中，我們將討論：

- 在 Linux、macOS 和 Windows 上安裝 Rust
- 編寫一個印出 `Hello, world!` 的程式
- 使用 `cargo`，Rust 的套件管理器和建構系統

## 安裝

第一步是安裝 Rust。我們將透過 `rustup` 下載 Rust，這是一個用於管理 Rust 版本和相關工具的命令列工具。你需要網路連線才能下載。

> 注意：如果由於某些原因你不想使用 `rustup`，請參閱位於 [https://forge.rust-lang.org/infra/other-installation-methods.html](https://forge.rust-lang.org/infra/other-installation-methods.html) 的其他 Rust 安裝方法頁面，以獲取更多選項。

以下步驟安裝 Rust 編譯器的最新穩定版。Rust 的穩定性保證了書中所有能編譯的範例，在新版 Rust 中也能持續編譯。輸出可能因版本而略有不同，因為 Rust 經常改進錯誤訊息和警告。換句話說，你使用這些步驟安裝的任何更新、穩定的 Rust 版本，都應該能與本書內容正常運作。

> ### 命令列標記
>
> 在本章和本書中，我們將展示一些在終端機中使用的命令。所有你應該在終端機中輸入的行都以 `$` 開頭。你不必輸入 `$` 字元；它只是命令列提示符號，表示每個命令的開始。不以 `$` 開頭的行通常顯示前一個命令的輸出。此外，PowerShell 特定的範例將使用 `>` 而非 `$`。

### 在 Linux 或 macOS 上安裝 rustup

如果你正在使用 Linux 或 macOS，開啟一個終端機並輸入以下命令：

```
$ curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh
```

此命令會下載一個腳本並開始安裝 `rustup` 工具，該工具會安裝最新穩定版的 Rust。你可能會被要求輸入密碼。如果安裝成功，將會出現以下行：

```
Rust is installed now. Great!
```

你還需要一個 `linker`，這是 Rust 用於將其編譯輸出連接成一個檔案的程式。你很可能已經有了一個。如果你收到 linker 錯誤，你應該安裝一個 C compiler，這通常會包含一個 linker。C compiler 也很有用，因為一些常見的 Rust packages 依賴於 C 程式碼，並且需要一個 C compiler。

在 macOS 上，你可以透過執行以下命令來取得一個 C compiler：

```
$ xcode-select --install
```

Linux 使用者通常應根據其發行版的說明文件安裝 GCC 或 Clang。例如，如果你使用 Ubuntu，你可以安裝 `build-essential` package。

### 在 Windows 上安裝 rustup

在 Windows 上，請前往 [https://www.rust-lang.org/tools/install](https://www.rust-lang.org/tools/install) 並按照指示安裝 Rust。在安裝的某些階段，你將被要求安裝 Visual Studio。這會提供一個 linker 和編譯程式所需的 native libraries。如果你在此步驟需要更多協助，請參閱 [https://rust-lang.github.io/rustup/installation/windows-msvc.html](https://rust-lang.github.io/rustup/installation/windows-msvc.html)。

本書的其餘部分使用在 `cmd.exe` 和 PowerShell 中都可運作的命令。如果存在特定差異，我們將解釋應使用哪個。

### 故障排除

為了檢查你是否正確安裝了 Rust，開啟一個 shell 並輸入以下行：

```
$ rustc --version
```

你應該會看到最新穩定版的版本號、commit hash 和 commit date，格式如下：

```
rustc x.y.z (abcabcabc yyyy-mm-dd)
```

如果你看到這些資訊，你已成功安裝 Rust！如果你沒有看到這些資訊，請檢查 Rust 是否在你的 `%PATH%` 系統變數中，如下所示。

在 Windows CMD 中，使用：

```
> echo %PATH%
```

在 PowerShell 中，使用：

```
> echo $env:Path
```

在 Linux 和 macOS 中，使用：

```
$ echo $PATH
```

如果這些都正確但 Rust 仍然無法運作，你可以從多個地方獲得幫助。請在 [https://www.rust-lang.org/community](https://www.rust-lang.org/community) 的社群頁面了解如何與其他 Rustaceans (我們對自己的滑稽暱稱) 取得聯繫。

### 更新與解除安裝

一旦透過 `rustup` 安裝了 Rust，更新到新發布的版本就很容易了。從你的 shell 執行以下更新腳本：

```
$ rustup update
```

要解除安裝 Rust 和 `rustup`，從你的 shell 執行以下解除安裝腳本：

```
$ rustup self uninstall
```

### 本機文件

Rust 的安裝還包括一份本機的文件副本，這樣你就可以離線閱讀它。執行 `rustup doc` 以在你的瀏覽器中開啟本機文件。

每當標準函式庫提供某種類型或函式，而你不確定它的作用或如何使用時，請使用應用程式介面 (API) documentation 來查找！

### 文字編輯器與整合開發環境

本書不對你用來編寫 Rust 程式碼的工具做任何假設。幾乎任何文字編輯器都能完成任務！然而，許多文字編輯器和整合開發環境 (IDEs) 都內建支援 Rust。你總能在 Rust 網站上 [https://www.rust-lang.org/tools](https://www.rust-lang.org/tools) 的工具頁面上找到一個相當新的編輯器和 IDE 列表。

## Hello, World!

現在你已經安裝了 Rust，是時候編寫你的第一個 Rust 程式了。學習新語言時，傳統上會編寫一個印出 `Hello, world!` 文字到螢幕上的小程序，所以我們在這裡也這樣做！

> 注意：本書假設你對命令列有基本的熟悉。Rust 對於你的編輯或工具或程式碼的位置沒有任何特定要求，所以如果你喜歡使用整合開發環境 (IDE) 而不是命令列，請隨意使用你最喜歡的 IDE。許多 IDE 現在都對 Rust 有一定程度的支援；請查看 IDE 的文件以獲取詳細資訊。Rust 團隊一直致力於透過 `rust-analyzer` 實現出色的 IDE 支援。有關更多詳細資訊，請參閱 [https://doc.rust-lang.org/book/appendix-04-development-tools.html](https://doc.rust-lang.org/book/appendix-04-development-tools.html)。

### 建立專案目錄

你將首先建立一個目錄來儲存你的 Rust 程式碼。Rust 對於你的程式碼位於何處並不在意，但對於本書中的練習和專案，我們建議在你的 home directory 中建立一個 `projects` 目錄，並將所有專案都放在那裡。

開啟一個終端機並輸入以下命令來建立一個 `projects` 目錄，以及一個位於 `projects` 目錄內的「Hello, world!」專案目錄。

對於 Linux、macOS 和 Windows 上的 PowerShell，輸入以下內容：

```
$ mkdir ~/projects
$ cd ~/projects
$ mkdir hello_world
$ cd hello_world
```

對於 Windows CMD，輸入以下內容：

```
> mkdir "%USERPROFILE%\projects"
> cd /d "%USERPROFILE%\projects"
> mkdir hello_world
> cd hello_world
```

### 編寫與執行 Rust 程式

接下來，建立一個新的 source file 並將其命名為 `main.rs`。Rust 檔案總是以後綴 `.rs` 結尾。如果你在檔案名稱中使用多個單字，慣例是使用 underscore 將它們分開。例如，使用 `hello_world.rs` 而不是 `helloworld.rs`。

現在打開你剛建立的 `main.rs` 檔案，並輸入 Listing 1-1 中的程式碼。

main.rs

```rust
fn main() {
    println!("Hello, world!");
}
```

Listing 1-1：一個印出 `Hello, world!` 的程式

儲存檔案並回到你位於 `~/projects/hello_world` 目錄中的終端機視窗。在 Linux 或 macOS 上，輸入以下命令來編譯和執行檔案：

```
$ rustc main.rs
$ ./main
Hello, world!
```

在 Windows 上，輸入命令 `.\main` 而不是 `./main`：

```
> rustc main.rs
> .\main
Hello, world!
```

無論你的作業系統是什麼，字串 `Hello, world!` 都應該會印到終端機上。如果你沒有看到此輸出，請參閱「安裝」章節的「[故障排除](https://doc.rust-lang.org/book/ch01-01-installation.html#troubleshooting)」部分以獲取幫助。

如果 `Hello, world!` 確實印出來了，恭喜你！你已經正式編寫了一個 Rust 程式。這讓你成為了一名 Rust 程式設計師——歡迎！

### Rust 程式的解析

讓我們詳細檢閱這個「Hello, world!」程式。這是謎題的第一部分：

```rust
fn main() {

}
```

這些行定義了一個名為 `main` 的 function。`main` function 很特別：它總是每個可執行 Rust 程式中第一個執行的程式碼。在這裡，第一行宣告了一個名為 `main` 的 function，它沒有 parameters 並且不回傳任何東西。如果有 parameters，它們會放在 parentheses `()` 裡面。

function body 被 `{}` 包裹。Rust 要求所有 function body 都必須用大括號。將開頭的大括號放在 function 宣告的同一行，並在中間添加一個空格，這是一種好的風格。

> 注意：如果你想在 Rust 專案中遵循標準風格，你可以使用一個名為 `rustfmt` 的自動格式化工具以特定風格格式化你的程式碼 (更多關於 `rustfmt` 的資訊請參閱 [https://doc.rust-lang.org/book/appendix-04-development-tools.html](https://doc.rust-lang.org/book/appendix-04-development-tools.html))。Rust 團隊已將此工具與標準 Rust 發行版一同提供，就像 `rustc` 一樣，所以它應該已經安裝在你的電腦上了！

`main` function 的 body 包含以下程式碼：

```rust
println!("Hello, world!");
```

這行程式碼完成了這個小程序中的所有工作：它將文字印到螢幕上。這裡有三個重要的細節需要注意。

首先，`println!` 呼叫了一個 Rust macro。如果它呼叫的是 function，它會被寫成 `println` (沒有 `!`)。Rust macros 是一種編寫程式碼以生成程式碼來擴展 Rust 語法的方式，我們將在 Chapter 20 中更詳細地討論它們。目前，你只需要知道使用 `!` 意味著你正在呼叫 macro 而不是 normal function，並且 macros 不總是遵循與 function 相同的規則。

其次，你看到 `"Hello, world!"` 字串。我們將此 string 作為 argument 傳遞給 `println!`，然後該 string 會被印到螢幕上。

第三，我們以 semicolon (`;`) 結尾該行，這表示此 expression 已結束，下一個 expression 準備開始。大多數 Rust 程式碼行都以 semicolon 結尾。

### 編譯與執行是獨立的步驟

你剛剛執行了一個新建立的程式，所以讓我們檢查一下這個過程中的每個步驟。

在執行 Rust 程式之前，你必須使用 Rust compiler 編譯它，透過輸入 `rustc` 命令並傳遞你的 source file 名稱，如下所示：

```
$ rustc main.rs
```

如果你有 C 或 C++ 背景，你會注意到這與 `gcc` 或 `clang` 類似。成功編譯後，Rust 會輸出一個 binary executable。

在 Linux、macOS 和 Windows 上的 PowerShell 中，你可以透過在你的 shell 中輸入 `ls` 命令來查看 executable：

```
$ ls
main  main.rs
```

在 Linux 和 macOS 上，你會看到兩個檔案。在 Windows 上的 PowerShell 中，你會看到與使用 CMD 時相同的三個檔案。在 Windows 上的 CMD 中，你會輸入以下內容：

```
> dir /B %= the /B option says to only show the file names =%
main.exe
main.pdb
main.rs
```

這顯示了帶有 `.rs` 擴展名的 source code file、executable file (在 Windows 上是 `main.exe`，但在所有其他平台上是 `main`)，以及在使用 Windows 時，一個包含 debugging information 的 `.pdb` 擴展名檔案。從這裡開始，你執行 `main` 或 `main.exe` 檔案，如下所示：

```
$ ./main # or .\main on Windows
```

如果你的 `main.rs` 是你的「Hello, world!」程式，這行程式碼會將 `Hello, world!` 印到你的 terminal。

如果你對動態語言更熟悉，例如 Ruby、Python 或 JavaScript，你可能不習慣將程式的編譯和執行分開進行。Rust 是一種 _ahead-of-time compiled_ 語言，這表示你可以編譯程式並將 executable 提供給其他人，即使他們沒有安裝 Rust 也能執行它。如果你給某人一個 `.rb`、`.py` 或 `.js` 檔案，他們需要安裝 Ruby、Python 或 JavaScript 的 implementation (分別)。但在這些語言中，你只需要一個命令來編譯和執行你的程式。在 language design 中，一切都是取捨。

對於簡單的程式來說，單獨使用 `rustc` 編譯是可行的，但隨著你的專案成長，你會希望管理所有選項並輕鬆共享你的程式碼。接下來，我們將向你介紹 Cargo 工具，它將幫助你編寫真實世界的 Rust 程式。

## Hello, Cargo!

Cargo 是 Rust 的 build system 和 package manager。大多數 Rustaceans 使用這個工具來管理他們的 Rust 專案，因為 Cargo 為你處理了許多任務，例如建構你的程式碼、下載你的程式碼所依賴的 `libraries`，以及建構這些 `libraries`。(我們稱你的程式碼所需的 `libraries` 為 `dependencies`。)

最簡單的 Rust 程式，就像我們目前所寫的程式一樣，沒有任何 `dependencies`。如果我們使用 Cargo 建構「Hello, world!」專案，它將只使用 Cargo 中處理程式碼建構的部分。當你編寫更複雜的 Rust 程式時，你會添加 `dependencies`，如果你使用 Cargo 啟動專案，添加 `dependencies` 將會容易得多。

因為絕大多數 Rust 專案都使用 Cargo，本書的其餘部分都假設你也在使用 Cargo。如果你使用「[安裝](https://doc.rust-lang.org/book/ch01-01-installation.html)」部分討論的官方安裝程式，Cargo 會隨 Rust 一同安裝。如果你透過其他方式安裝 Rust，請在終端機中輸入以下內容來檢查 Cargo 是否已安裝：

```
$ cargo --version
```

如果你看到版本號，就表示你已經安裝了！如果你看到錯誤，例如 `command not found`，請查看你安裝方法的說明文件以確定如何單獨安裝 Cargo。

### 使用 Cargo 建立專案

讓我們使用 Cargo 建立一個新專案，並看看它與我們原始的「Hello, world!」專案有何不同。導航回你的 `projects` 目錄 (或你決定儲存程式碼的任何位置)。然後，在任何作業系統上，執行以下命令：

```
$ cargo new hello_cargo
$ cd hello_cargo
```

第一個命令會建立一個名為 `hello_cargo` 的新目錄和專案。我們將專案命名為 `hello_cargo`，而 Cargo 會在其同名目錄中建立其檔案。

進入 `hello_cargo` 目錄並列出檔案。你會看到 Cargo 為我們生成了兩個檔案和一個目錄：一個 `Cargo.toml` 檔案和一個包含 `main.rs` 檔案的 `src` 目錄。

它還初始化了一個新的 Git repository，並附帶一個 `.gitignore` 檔案。如果你在現有的 Git repository 內執行 `cargo new`，Git 檔案將不會生成；你可以使用 `cargo new --vcs=git` 來覆寫此行為。

> 注意：Git 是一種常見的 version control system。你可以使用 `--vcs` 旗標將 `cargo new` 更改為使用不同的 version control system 或不使用任何 version control system。執行 `cargo new --help` 查看可用選項。

在你的文字編輯器中開啟 `Cargo.toml`。它應該與 Listing 1-2 中的程式碼相似。

Cargo.toml

```toml
[package]
name = "hello_cargo"
version = "0.1.0"
edition = "2024"

[dependencies]
```

Listing 1-2：由 `cargo new` 生成的 `Cargo.toml` 內容

這個檔案是 TOML (Tom’s Obvious, Minimal Language) 格式，這是 Cargo 的 configuration format。

第一行 `[package]` 是一個 section heading，表示以下語句正在配置一個 package。當我們向此檔案添加更多資訊時，我們將添加其他 sections。

接下來的三行設定了 Cargo 編譯你的程式所需的 configuration information：名稱、版本和要使用的 Rust `edition`。我們將在 [https://doc.rust-lang.org/book/appendix-05-editions.html](https://doc.rust-lang.org/book/appendix-05-editions.html) 中討論 `edition` key。

最後一行 `[dependencies]` 是你列出專案任何 `dependencies` 的 section 的開始。在 Rust 中，程式碼 package 被稱為 `crates`。我們在這個專案中不需要任何其他 `crates`，但在 [https://doc.rust-lang.org/book/ch02-00-guessing-game.html](https://doc.rust-lang.org/book/ch02-00-guessing-game.html) 中的第一個專案中會用到，所以我們到時會使用這個 `dependencies` section。

現在打開 `src/main.rs` 並查看：

檔案名：src/main.rs

```rust
fn main() {
    println!("Hello, world!");
}
```

Cargo 為你生成了一個「Hello, world!」程式，就像我們在 [Listing 1-1](https://doc.rust-lang.org/book/ch01-01-installation.html#listing-1-1-a-program-that-prints-hello-world) 中編寫的那個一樣！到目前為止，我們的專案與 Cargo 生成的專案之間的區別是，Cargo 將程式碼放在 `src` 目錄中，並且我們在頂層目錄中擁有一個 `Cargo.toml` configuration file。

Cargo 期望你的 source files 位於 `src` 目錄內。頂層專案目錄僅用於 README 檔案、許可證資訊、configuration files 以及任何與程式碼無關的其他內容。使用 Cargo 有助於你組織專案。萬事皆有歸屬，各就各位。

如果你啟動了一個不使用 Cargo 的專案，就像我們使用「Hello, world!」專案一樣，你可以將它轉換為使用 Cargo 的專案。將專案程式碼移到 `src` 目錄中，並創建一個適當的 `Cargo.toml` 檔案。獲得該 `Cargo.toml` 檔案的一個簡單方法是執行 `cargo init`，它會自動為你建立。

### 建構與執行 Cargo 專案

現在讓我們看看當我們使用 Cargo 建構和執行「Hello, world!」程式時有什麼不同！從你的 `hello_cargo` 目錄中，輸入以下命令來建構你的專案：

```text
$ cargo build
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs
```

此命令會將 executable file 建立在 `target/debug/hello_cargo` (或 Windows 上的 `target\debug\hello_cargo.exe`)，而不是你的目前目錄中。由於預設的 build 是 debug build，Cargo 會將 binary 放在名為 `debug` 的目錄中。你可以使用此命令執行 executable：

```text
$ ./target/debug/hello_cargo # or .\target\debug\hello_cargo.exe on Windows
Hello, world!
```

如果一切順利，`Hello, world!` 應該會印到終端機上。第一次執行 `cargo build` 也會導致 Cargo 在頂層建立一個新檔案：`Cargo.lock`。此檔案會追蹤你專案中 `dependencies` 的確切版本。此專案沒有 `dependencies`，因此檔案有點稀疏。你永遠不需要手動更改此檔案；Cargo 會為你管理其內容。

我們剛才用 `cargo build` 建構了一個專案，並用 `./target/debug/hello_cargo` 執行了它，但我們也可以使用 `cargo run` 來編譯程式碼，然後在一個命令中執行產生的 executable：

```text
$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/hello_cargo`
Hello, world!
```

使用 `cargo run` 比起必須記住執行 `cargo build` 然後使用 binary 的整個路徑更方便，因此大多數開發人員都使用 `cargo run`。

請注意，這次我們沒有看到指示 Cargo 正在編譯 `hello_cargo` 的輸出。Cargo 發現檔案沒有改變，所以它沒有重新建構，只是執行了 binary。如果你修改了你的 source code，Cargo 會在執行專案之前重新建構專案，你會看到以下輸出：

```text
$ cargo run
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.33 secs
     Running `target/debug/hello_cargo`
Hello, world!
```

Cargo 還提供了一個名為 `cargo check` 的命令。此命令會快速檢查你的程式碼，以確保它能編譯，但不會產生 executable：

```text
$ cargo check
   Checking hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
```

你為什麼不想要一個 executable？通常，`cargo check` 比 `cargo build` 快得多，因為它跳過了產生 executable 的步驟。如果你在編寫程式碼時不斷檢查你的工作，使用 `cargo check` 將加快讓你了解你的專案是否仍在編譯的過程！因此，許多 Rustaceans 在編寫程式時會定期執行 `cargo check` 以確保它能編譯。然後，當他們準備使用 executable 時，他們會執行 `cargo build`。

讓我們回顧一下到目前為止我們學到的關於 Cargo 的知識：

- 我們可以使用 `cargo new` 建立一個專案。
- 我們可以使用 `cargo build` 建構一個專案。
- 我們可以使用 `cargo run` 一步建構並執行專案。
- 我們可以使用 `cargo check` 建構專案而不產生 binary 來檢查錯誤。
- Cargo 不會將建構結果儲存在與我們的程式碼相同的目錄中，而是將其儲存在 `target/debug` 目錄中。

使用 Cargo 的另一個優點是，無論你在哪個作業系統上工作，命令都是相同的。因此，在這一點上，我們將不再提供 Linux 和 macOS 與 Windows 的特定說明。

### 為發布建構

當你的專案最終準備好發布時，你可以使用 `cargo build --release` 來編譯它並進行 `optimizations`。此命令會在 `target/release` 而不是 `target/debug` 中建立一個 executable。`optimizations` 會使你的 Rust 程式碼執行得更快，但啟用它們會延長你的程式編譯所需的時間。這就是為什麼有兩種不同的 `profiles`：一種用於 `development`，當你想要快速且經常重建時，另一種用於建構最終你會提供給使用者且不會重複重建並會盡可能快地執行的程式。如果你正在 `benchmarking` 你的程式碼執行時間，請務必執行 `cargo build --release` 並使用 `target/release` 中的 executable 進行 `benchmark`。

### Cargo 的慣例

對於簡單的專案，Cargo 相較於直接使用 `rustc` 來說，提供的價值並不多，但隨著你的程式變得更複雜，它將證明其價值。一旦程式成長到多個檔案或需要 `dependency`，讓 Cargo 協調建構會容易得多。

儘管 `hello_cargo` 專案很簡單，但它現在使用了你在餘下的 Rust 生涯中將使用的大部分真實工具。事實上，要處理任何現有專案，你可以使用以下命令來使用 Git 檢出程式碼，切換到該專案的目錄，然後建構：

```
$ git clone example.org/someproject
$ cd someproject
$ cargo build
```

有關 Cargo 的更多資訊，請查看其位於 [https://doc.rust-lang.org/cargo/](https://doc.rust-lang.org/cargo/) 的文件。

## 總結

你的 Rust 旅程已經有了很好的開始！在本章中，你已經學會了如何：

- 使用 `rustup` 安裝最新穩定版的 Rust
- 更新到較新的 Rust 版本
- 開啟本機安裝的文件
- 直接使用 `rustc` 編寫並執行「Hello, world!」程式
- 使用 Cargo 的慣例建立並執行新專案

現在正是時候建構一個更實質的程式，以習慣閱讀和編寫 Rust 程式碼。因此，在 [https://doc.rust-lang.org/book/ch02-00-guessing-game.html](https://doc.rust-lang.org/book/ch02-00-guessing-game.html) 中，我們將建構一個猜謎遊戲程式。如果你寧願先學習 Rust 中常見 programming concepts 的運作方式，請參閱 [https://doc.rust-lang.org/book/ch03-00-common-programming-concepts.html](https://doc.rust-lang.org/book/ch03-00-common-programming-concepts.html) 然後再回到 [https://doc.rust-lang.org/book/ch02-00-guessing-game.html](https://doc.rust-lang.org/book/ch02-00-guessing-game.html)。
