<!-- DO NOT EDIT THIS FILE.

This file is periodically generated from the content in the `/src/`
directory, so all fixes need to be made in `/src/`.
-->

[TOC]

# 介紹

> 備註：本書籍版本與 _https://nostarch.com/rust-programming-language-2nd-edition_ 上《The Rust Programming Language》一書的內容相同，該書的印刷版和電子書版本可在 No Starch Press 的 _https://nostarch.com/_ 取得。

歡迎閱讀《The Rust Programming Language》，這是一本關於 Rust 的入門書。Rust 程式語言可以幫助你編寫更快、更可靠的軟體。高層次的人體工學（ergonomics）和低層次控制在程式語言設計中經常相互衝突；Rust 挑戰了這種衝突。透過平衡強大的技術能力和出色的開發者體驗，Rust 讓你能夠控制低層次細節（例如記憶體使用），同時避免了傳統上與此類控制相關的所有麻煩。

## Rust 適合誰

Rust 因多種原因而適合許多人。讓我們來看看其中幾個最重要的群體。

### 開發團隊

Rust 被證明是一種高效的工具，可用於擁有不同系統程式設計知識水平的大型開發團隊之間的協作。低層次程式碼容易出現各種微妙的 bug，在大多數其他語言中，這些 bug 只能透過大量的測試和經驗豐富的開發人員仔細的 code review 才能發現。在 Rust 中，compiler 扮演著守門員的角色，它會拒絕編譯帶有這些難以發現的 bug 的程式碼，包括 concurrency bug。透過與 compiler 協同工作，團隊可以將時間花在專注於程式的邏輯上，而不是追查 bug。

Rust 也為系統程式設計世界帶來了現代化的開發工具：

- 內建的 dependency manager 和 build tool `Cargo`，讓在整個 Rust ecosystem 中新增、編譯和管理 dependency 變得輕鬆且一致。
- `Rustfmt` 格式化工具確保開發人員之間有著一致的 coding style。
- `rust-analyzer` 支援 Integrated Development Environment (IDE) 整合，提供 code completion 和 inline error messages。

透過使用這些以及 Rust ecosystem 中的其他工具，開發人員在編寫系統級程式碼時可以保持高效。

### 學生

Rust 適用於學生以及對學習系統概念感興趣的人。透過使用 Rust，許多人學到了作業系統開發等主題。Rust 社群非常熱情，樂意回答學生的問題。透過本書等努力，Rust 團隊希望讓更多人，特別是程式設計新手，更容易接觸到系統概念。

### 公司

數百家大小公司在生產環境中使用 Rust 執行各種任務，包括 command line tools、web services、DevOps tooling、embedded devices、音訊和視訊分析與轉碼、cryptocurrencies、bioinformatics、search engines、Internet of Things 應用程式、machine learning，甚至是 Firefox web browser 的主要部分。

### 開源開發者

Rust 適用於那些希望構建 Rust 程式語言、社群、開發工具和函式庫的人。我們非常歡迎你為 Rust 語言貢獻力量。

### 重視速度和穩定性的人

Rust 適用於那些渴望語言的速度和穩定性的人。所謂速度，我們指的是 Rust 程式碼的執行速度以及 Rust 讓你編寫程式的速度。Rust compiler 的檢查透過功能新增和 refactoring 來確保穩定性。這與沒有這些檢查的語言中脆弱的 legacy code 形成對比，開發人員往往害怕修改它們。透過追求 zero-cost abstractions——即更高層次的功能編譯成與手動編寫的程式碼一樣快的低層次程式碼——Rust 致力於讓安全程式碼也能快速執行。

Rust 語言也希望支援許多其他使用者；這裡提到的只是其中一些最大的利害關係人。總體而言，Rust 最偉大的目標是透過提供安全*性*與生產力，速度*與*人體工學來消除程式設計師幾十年來所接受的取捨。試試 Rust，看看它的選擇是否適合你。

## 本書適合誰

本書假設你曾經使用其他程式語言編寫過程式碼，但沒有對是哪種語言做出任何假設。我們已盡力使內容廣泛適用於來自各種程式設計背景的人。我們沒有花大量時間討論程式設計*是什麼*或如何思考它。如果你是程式設計的完全新手，那麼閱讀一本專門提供程式設計入門的書籍會更適合你。

## 如何使用本書

通常，本書假設你按照順序從頭到尾閱讀。後面的章節建立在前面章節的概念之上，而前面的章節可能不會深入探討特定主題的細節，但會在後面的章節中重新討論該主題。

本書有兩種類型的章節：概念章節和專案章節。在概念章節中，你將學習 Rust 的某個方面。在專案章節中，我們將一起建立小型程式，應用你目前所學到的知識。第 2、12 和 21 章是專案章節；其餘的都是概念章節。

第 1 章解釋了如何安裝 Rust，如何編寫「Hello, world!」程式，以及如何使用 Rust 的套件管理器和建構工具 `Cargo`。第 2 章是 Rust 程式設計的實務入門，讓你建立一個數字猜謎遊戲。在這裡，我們高層次地涵蓋了概念，後面的章節將提供更多細節。如果你想立即動手實作，第 2 章就是一個好開始。第 3 章涵蓋了與其他程式語言相似的 Rust 功能，在第 4 章中你將學習 Rust 的 ownership system。如果你是一個特別細心、喜歡在進入下一個主題之前學習所有細節的學習者，你可能會想跳過第 2 章，直接跳到第 3 章，等到你想應用所學的細節來製作一個專案時再回到第 2 章。

第 5 章討論 structs 和 methods，第 6 章涵蓋 enums、`match` expressions 和 `if let` control flow construct。你將使用 structs 和 enums 在 Rust 中建立自定義型別。

在第 7 章中，你將學習 Rust 的 module system 以及組織程式碼及其 public Application Programming Interface (API) 的 privacy rules。第 8 章討論了標準函式庫提供的一些常見 collection data structures，例如 vectors、strings 和 hash maps。第 9 章探討了 Rust 的 error-handling 哲學和技術。

第 10 章深入探討了 generics、traits 和 lifetimes，它們賦予你定義適用於多種型別程式碼的能力。第 11 章完全關於 testing，即使有 Rust 的 safety guarantees，它對於確保程式邏輯正確也是必要的。在第 12 章中，我們將實作 `grep` command line tool 功能的一個子集，該工具用於在檔案中搜尋文字。為此，我們將使用前面章節中討論的許多概念。

第 13 章探討 closures 和 iterators：這些是 Rust 源自 functional programming languages 的功能。在第 14 章中，我們將更深入地研究 `Cargo`，並討論與他人共享函式庫的最佳實踐。第 15 章討論了標準函式庫提供的 smart pointers 以及啟用其功能的 traits。

在第 16 章中，我們將探討不同的 concurrent programming 模型，並討論 Rust 如何幫助你無懼地在 multiple threads 中編寫程式。在第 17 章中，我們將在此基礎上探討 Rust 的 async 和 await 語法以及它們支援的 lightweight concurrency model。

第 18 章探討了 Rust idioms 與你可能熟悉的 object-oriented programming 原則之間的比較。

第 19 章是關於 patterns 和 pattern matching 的參考資料，它們是在整個 Rust 程式中表達思想的強大方式。第 20 章包含了一系列有趣的進階主題，包括 unsafe Rust、macros，以及更多關於 lifetimes、traits、types、functions 和 closures 的內容。

在第 21 章中，我們將完成一個專案，其中我們將實作一個 low-level multithreaded web server！

最後，一些附錄包含語言的有用資訊，格式更像參考資料。**附錄 A** 涵蓋 Rust 的 keywords，**附錄 B** 涵蓋 Rust 的 operators 和 symbols，**附錄 C** 涵蓋標準函式庫提供的 derivable traits，**附錄 D** 涵蓋一些有用的 development tools，**附錄 E** 解釋 Rust editions。在 **附錄 F** 中，你可以找到本書的翻譯版本，在 **附錄 G** 中，我們將介紹 Rust 是如何製作的以及什麼是 nightly Rust。

閱讀本書沒有錯誤的方法：如果你想跳著讀，那就去吧！如果你遇到任何困惑，可能需要跳回前面的章節。但做任何對你有效的事情。

<span id="ferris">

學習 Rust 過程的一個重要部分是學習如何閱讀 compiler 顯示的 error messages：這些將引導你編寫出可運行的程式碼。因此，我們將提供許多無法編譯的範例以及 compiler 在每種情況下將顯示的 error message。請記住，如果你輸入並運行一個隨機範例，它可能無法編譯！請務必閱讀周圍的文字，以查看你嘗試運行的範例是否預期會出錯。Ferris 也會幫助你區分不預期能正常運行的程式碼：

| Ferris                                                                                                                                   | 含義                           |
| ---------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------ |
| <img src="https://doc.rust-lang.org/book/img/ferris/does_not_compile.svg" class="ferris-explain" alt="帶有問號的 Ferris"/>               | 這段程式碼無法編譯！           |
| <img src="https://doc.rust-lang.org/book/img/ferris/panics.svg" class="ferris-explain" alt="雙手向上舉的 Ferris"/>                       | 這段程式碼會 panic！           |
| <img src="https://doc.rust-lang.org/book/img/ferris/not_desired_behavior.svg" class="ferris-explain" alt="一隻爪子抬起，聳肩的 Ferris"/> | 這段程式碼不會產生預期的行為。 |

在大多數情況下，我們將引導你找到任何無法編譯程式碼的正確版本。

## 原始碼

本書的原始檔可在 GitHub 上找到：_https://github.com/rust-lang/book/tree/main/src_。
