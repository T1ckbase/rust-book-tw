<!-- DO NOT EDIT THIS FILE.

This file is periodically generated from the content in the `/src/`
directory, so all fixes need to be made in `/src/`.
-->

[TOC]

# Enums 與模式匹配

在本章中，我們將探討 _enumerations_，也稱為 _enums_。Enums 允許你透過列舉其可能的_變體 (variants)_ 來定義一個型別。首先，我們將定義並使用一個 enum，以展示 enum 如何將意義與資料一起編碼。接下來，我們將探討一個特別有用的 enum，稱為 `Option`，它表示一個值可以是有東西或沒有東西。然後，我們將看看 `match` 表達式中的模式匹配如何讓你輕鬆地為 enum 的不同值執行不同的程式碼。最後，我們將介紹 `if let` 結構，這是另一個方便且簡潔的慣用語，可用於處理程式碼中的 enums。

## 定義 Enum

Struct 讓你能夠將相關的欄位和資料組合在一起，例如一個帶有 `width` 和 `height` 的 `Rectangle`，而 enums 則讓你能夠表示一個值是可能集合中的其中一個值。例如，我們可能想說 `Rectangle` 是一組可能圖形中的一種，這組圖形還包括 `Circle` 和 `Triangle`。為此，Rust 允許我們將這些可能性編碼為一個 enum。

讓我們來看一個我們可能想在程式碼中表達的情境，並看看為什麼在這種情況下，enums 比 structs 更有用、更合適。假設我們需要處理 IP 位址。目前，IP 位址有兩種主要標準：第四版和第六版。因為這些是我們的程式會遇到的 IP 位址的唯二可能性，所以我們可以 _enumerate_（列舉）所有可能的變體，這也是 enumeration（列舉）這個詞的由來。

任何 IP 位址可以是第四版或第六版，但不能同時是兩者。IP 位址的這個特性使得 enum 資料結構非常適合，因為一個 enum 值只能是其變體之一。第四版和第六版的位址在本質上仍然是 IP 位址，所以在程式碼處理適用於任何種類 IP 位址的情況時，它們應該被視為相同的型別。

我們可以透過定義一個 `IpAddrKind` 的 enumeration，並列出 IP 位址可能的種類 `V4` 和 `V6`，來在程式碼中表達這個概念。這些是 enum 的變體：

```rust
enum IpAddrKind {
    V4,
    V6,
}
```

`IpAddrKind` 現在是一個自訂資料型別，我們可以在程式碼的其他地方使用它。

### Enum 值

我們可以像這樣創建 `IpAddrKind` 兩個變體的實例：

```rust
let four = IpAddrKind::V4;
let six = IpAddrKind::V6;
```

請注意，enum 的變體是在其識別符下的命名空間中，我們使用雙冒號來分隔兩者。這很有用，因為現在 `IpAddrKind::V4` 和 `IpAddrKind::V6` 這兩個值都是相同的型別：`IpAddrKind`。然後，例如，我們可以定義一個接收任何 `IpAddrKind` 的函式：

```rust
fn route(ip_kind: IpAddrKind) {}
```

而且我們可以用任一變體來呼叫這個函式：

```rust
route(IpAddrKind::V4);
route(IpAddrKind::V6);
```

使用 enums 還有更多優點。再想想我們的 IP 位址型別，目前我們還沒有辦法儲存實際的 IP 位址_資料_；我們只知道它是哪種_種類_。鑑於你在第 5 章剛學過 structs，你可能會想用如列表 6-1 所示的 structs 來解決這個問題。

```rust
    enum IpAddrKind {
        V4,
        V6,
    }

    struct IpAddr {
        kind: IpAddrKind,
        address: String,
    }

    let home = IpAddr {
        kind: IpAddrKind::V4,
        address: String::from("127.0.0.1"),
    };

    let loopback = IpAddr {
        kind: IpAddrKind::V6,
        address: String::from("::1"),
    };
```

列表 6-1：使用 `struct` 儲存 IP 位址的資料和 `IpAddrKind` 變體

在這裡，我們定義了一個 `IpAddr` struct，它有兩個欄位：一個 `kind` 欄位，型別是 `IpAddrKind`（我們之前定義的 enum），以及一個 `address` 欄位，型別是 `String`。我們有這個 struct 的兩個實例。第一個是 `home`，它的 `kind` 值是 `IpAddrKind::V4`，關聯的位址資料是 `127.0.0.1`。第二個實例是 `loopback`。它的 `kind` 值是 `IpAddrKind` 的另一個變體 `V6`，並與位址 `::1` 相關聯。我們使用了一個 struct 來將 `kind` 和 `address` 值捆綁在一起，所以現在變體與值相關聯了。

然而，僅使用 enum 來表示相同的概念更為簡潔：我們可以直接將資料放入每個 enum 變體中，而不是在 struct 中包含一個 enum。這個 `IpAddr` enum 的新定義表示 `V4` 和 `V6` 變體都將有關聯的 `String` 值：

```rust
    enum IpAddr {
        V4(String),
        V6(String),
    }

    let home = IpAddr::V4(String::from("127.0.0.1"));

    let loopback = IpAddr::V6(String::from("::1"));
```

我們直接將資料附加到 enum 的每個變體上，所以不需要額外的 struct。這裡，也更容易看出 enums 如何運作的另一個細節：我們定義的每個 enum 變體的名稱也變成了一個建構 enum 實例的函式。也就是說，`IpAddr::V4()` 是一個函式呼叫，它接收一個 `String` 引數並回傳一個 `IpAddr` 型別的實例。由於定義了 enum，我們自動獲得了這個建構函式。

使用 enum 而非 struct 還有另一個優勢：每個變體可以有不同型別和數量的關聯資料。第四版的 IP 位址總是會有四個數字元件，其值介於 0 和 255 之間。如果我們想將 `V4` 位址儲存為四個 `u8` 值，但仍然將 `V6` 位址表示為一個 `String` 值，用 struct 就無法做到。Enums 可以輕鬆處理這種情況：

```rust
    enum IpAddr {
        V4(u8, u8, u8, u8),
        V6(String),
    }

    let home = IpAddr::V4(127, 0, 0, 1);

    let loopback = IpAddr::V6(String::from("::1"));
```

我們展示了幾種不同的方式來定義資料結構，以儲存第四版和第六版的 IP 位址。然而，事實證明，想要儲存 IP 位址並編碼它們的種類是如此普遍，以至於標準函式庫中有一個我們可以使用的定義！讓我們看看標準函式庫是如何定義 `IpAddr` 的：它有著我們定義和使用過的完全相同的 enum 和變體，但它以兩種不同 struct 的形式將位址資料嵌入變體中，這兩種 struct 對於每個變體都有不同的定義：

```rust
struct Ipv4Addr {
    // --snip--
}

struct Ipv6Addr {
    // --snip--
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
```

這段程式碼說明了你可以在 enum 變體中放入任何種類的資料：例如字串、數字型別或 structs。你甚至可以包含另一個 enum！此外，標準函式庫的型別通常不會比你可能想出來的複雜多少。

請注意，即使標準函式庫包含 `IpAddr` 的定義，我們仍然可以創建和使用我們自己的定義而不會產生衝突，因為我們沒有將標準函式庫的定義引入我們的作用域。我們將在第 7 章更多地討論將型別引入作用域。

讓我們來看列表 6-2 中的另一個 enum 範例：這個 enum 在其變體中嵌入了各式各樣的型別。

```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
```

列表 6-2：一個 `Message` enum，其各個變體儲存不同數量和型別的值

這個 enum 有四個帶有不同型別的變體：

- `Quit`：完全沒有關聯的資料
- `Move`：有名稱的欄位，就像 struct 一樣
- `Write`：包含一個 `String`
- `ChangeColor`：包含三個 `i32` 值

定義一個像列表 6-2 中那樣的 enum 變體，類似於定義不同種類的 struct，只是 enum 不使用 `struct` 關鍵字，而且所有的變體都歸類在 `Message` 型別之下。以下的 structs 可以持有與前述 enum 變體相同的資料：

```rust
struct QuitMessage; // unit struct
struct MoveMessage {
    x: i32,
    y: i32,
}
struct WriteMessage(String); // tuple struct
struct ChangeColorMessage(i32, i32, i32); // tuple struct
```

但是如果我們使用不同的 structs，每個都有自己的型別，我們就不能像使用列表 6-2 中定義的 `Message` enum（它是一個單一型別）那樣，輕易地定義一個函式來接收任何這些種類的訊息。

enums 和 structs 之間還有一個相似之處：就像我們能夠使用 `impl` 在 structs 上定義方法一樣，我們也能夠在 enums 上定義方法。這是一個名為 `call` 的方法，我們可以定義在我們的 `Message` enum 上：

```rust
    impl Message {
        fn call(&self) {
            // method body would be defined here
        }
    }

    let m = Message::Write(String::from("hello"));
    m.call();
```

方法的本體會使用 `self` 來取得我們呼叫該方法的值。在這個範例中，我們創建了一個變數 `m`，其值為 `Message::Write(String::from("hello"))`，當 `m.call()` 執行時，這就是 `call` 方法本體中的 `self`。

讓我們看看標準函式庫中另一個非常普遍且有用的 enum：`Option`。

### Option Enum 及其相較於 Null 值的優勢

本節探討 `Option` 的一個案例研究，這是標準函式庫定義的另一個 enum。`Option` 型別編碼了一個非常常見的情境，即一個值可以是有東西，也可以是沒有東西。

例如，如果你請求一個非空列表中的第一個項目，你會得到一個值。如果你請求一個空列表中的第一個項目，你會得到無。用型別系統來表達這個概念，意味著編譯器可以檢查你是否處理了所有應該處理的情況；這個功能可以防止在其他程式語言中極為常見的錯誤。

程式語言的設計通常是從你包含哪些功能的角度來思考的，但你排除哪些功能也很重要。Rust 沒有許多其他語言所擁有的 null 功能。_Null_ 是一個表示那裡沒有值的值。在有 null 的語言中，變數總是處於兩種狀態之一：null 或非 null。

在他的 2009 年演講「Null References: The Billion Dollar Mistake」中，null 的發明者 Tony Hoare 這樣說：

> 我稱之為我十億美元的錯誤。當時，我正在為一個物件導向語言設計第一個全面的參考型別系統。我的目標是確保所有參考的使用都絕對安全，並由編譯器自動執行檢查。但我無法抗拒加入一個 null 參考的誘惑，僅僅因為它實現起來太容易了。這導致了無數的錯誤、漏洞和系統崩潰，在過去四十年裡可能造成了十億美元的痛苦和損害。

null 值的問題在於，如果你試圖將一個 null 值當作一個非 null 值來使用，你會得到某種錯誤。因為這種 null 或非 null 的屬性無所不在，所以非常容易犯這種錯誤。

然而，null 試圖表達的概念仍然是一個有用的概念：null 是一個因某種原因目前無效或不存在的值。

問題其實不在於概念本身，而在於其具體的實現。因此，Rust 沒有 null，但它有一個 enum 可以編碼值存在或不存在的概念。這個 enum 就是 `Option<T>`，它由標準函式庫定義如下：

```rust
enum Option<T> {
    None,
    Some(T),
}
```

`Option<T>` enum 非常有用，甚至被包含在 prelude（預載入）中；你不需要明確地將它引入作用域。它的變體也包含在 prelude 中：你可以直接使用 `Some` 和 `None`，而不需要 `Option::` 前綴。`Option<T>` enum 仍然只是一個普通的 enum，而 `Some(T)` 和 `None` 仍然是 `Option<T>` 型別的變體。

`<T>` 語法是我們還沒有談過的 Rust 的一個特性。它是一個泛型型別參數，我們將在第 10 章更詳細地介紹泛型。目前，你只需要知道 `<T>` 意味著 `Option` enum 的 `Some` 變體可以持有任何型別的一份資料，並且每個用來取代 `T` 的具體型別都會使整體的 `Option<T>` 型別成為一個不同的型別。以下是一些使用 `Option` 值來持有數字型別和字元型別的範例：

```rust
    let some_number = Some(5);
    let some_char = Some('e');

    let absent_number: Option<i32> = None;
```

`some_number` 的型別是 `Option<i32>`。`some_char` 的型別是 `Option<char>`，這是一個不同的型別。Rust 能夠推斷出這些型別，因為我們在 `Some` 變體內指定了一個值。對於 `absent_number`，Rust 要求我們標註整體的 `Option` 型別：編譯器無法僅僅透過一個 `None` 值來推斷出對應的 `Some` 變體將持有的型別。在這裡，我們告訴 Rust 我們希望 `absent_number` 的型別是 `Option<i32>`。

當我們有一個 `Some` 值時，我們知道一個值是存在的，並且該值被包含在 `Some` 之中。當我們有一個 `None` 值時，在某種意義上，它與 null 的意思相同：我們沒有一個有效的值。那麼，為什麼擁有 `Option<T>` 會比擁有 null 更好呢？

簡而言之，因為 `Option<T>` 和 `T`（其中 `T` 可以是任何型別）是不同的型別，編譯器不允許我們將 `Option<T>` 值當作它肯定是一個有效的值來使用。例如，這段程式碼無法編譯，因為它試圖將一個 `i8` 加到一個 `Option<i8>` 上：

```rust
    let x: i8 = 5;
    let y: Option<i8> = Some(5);

    let sum = x + y;
```

如果我們執行這段程式碼，會得到像這樣的錯誤訊息：

```
$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0277]: cannot add `Option<i8>` to `i8`
 --> src/main.rs:5:17
  |
5 |     let sum = x + y;
  |                 ^ no implementation for `i8 + Option<i8>`
  |
  = help: the trait `Add<Option<i8>>` is not implemented for `i8`
  = help: the following other types implement trait `Add<Rhs>`:
            `&i8` implements `Add<i8>`
            `&i8` implements `Add`
            `i8` implements `Add<&i8>`
            `i8` implements `Add`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `enums` (bin "enums") due to 1 previous error
```

太強大了！實際上，這個錯誤訊息意味著 Rust 不知道如何將一個 `i8` 和一個 `Option<i8>` 相加，因為它們是不同的型別。當我們在 Rust 中有一個像 `i8` 這樣的型別的值時，編譯器會確保我們總是有一個有效的值。我們可以放心地繼續，而無需在使用該值之前檢查 null。只有當我們有一個 `Option<i8>`（或我們正在處理的任何型別的值）時，我們才需要擔心可能沒有值的情況，而編譯器會確保我們在使用該值之前處理了這種情況。

換句話說，你必須先將 `Option<T>` 轉換為 `T`，才能對其執行 `T` 的操作。通常，這有助於捕捉 null 最常見的問題之一：在某物實際上是 null 時，卻假設它不是 null。

消除了錯誤假設非 null 值的風險，有助於你對自己的程式碼更有信心。為了擁有一個可能為 null 的值，你必須透過將該值的型別設為 `Option<T>` 來明確選擇加入。然後，當你使用該值時，你被要求明確處理該值為 null 的情況。在任何一個值的型別不是 `Option<T>` 的地方，你*可以*安全地假設該值不是 null。這是 Rust 為了限制 null 的普遍性並提高 Rust 程式碼安全性而做出的深思熟慮的設計決定。

那麼，當你擁有一個 `Option<T>` 型別的值時，如何從 `Some` 變體中取出 `T` 值，以便使用該值呢？`Option<T>` enum 有大量在各種情況下都有用的方法；你可以在其文件中查看它們。熟悉 `Option<T>` 上的方法將對你的 Rust 之旅極為有益。

一般來說，為了使用 `Option<T>` 值，你需要有能夠處理每個變體的程式碼。你希望有些程式碼只在你有 `Some(T)` 值時執行，並且這段程式碼可以使用內部的 `T`。你也希望有另一段程式碼只在你有 `None` 值時執行，而那段程式碼沒有可用的 `T` 值。`match` 表達式就是一個與 enums 一起使用時能做到這一點的控制流程結構：它會根據它擁有的 enum 變體來執行不同的程式碼，並且那段程式碼可以使用匹配值內部的資料。

<!-- Old heading. Do not remove or links may break. -->

<a id="the-match-control-flow-operator"></a>

## match 控制流程結構

Rust 有一個非常強大的控制流程結構，稱為 `match`，它允許你將一個值與一系列模式進行比較，然後根據哪個模式匹配來執行程式碼。模式可以由字面值、變數名稱、萬用字元和許多其他東西組成；第 19 章將涵蓋所有不同種類的模式及其作用。`match` 的強大之處在於模式的表達能力，以及編譯器會確認所有可能的情況都已處理。

把 `match` 表達式想像成一台硬幣分類機：硬幣沿著一條軌道滑下，軌道上有各種大小的孔洞，每個硬幣都會掉進它遇到的第一個適合它的孔洞。同樣地，值會經過 `match` 中的每個模式，在第一個「符合」的模式處，值會掉進相關的程式碼區塊，在執行期間被使用。

說到硬幣，讓我們用它們作為 `match` 的例子吧！我們可以寫一個函式，接收一枚未知的美國硬幣，並以類似計數機的方式，判斷它是哪種硬幣並回傳其以美分為單位的價值，如列表 6-3 所示。

```rust
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}
```

列表 6-3：一個 enum 和一個 `match` 表達式，其模式是該 enum 的變體

讓我們來分解 `value_in_cents` 函式中的 `match`。首先，我們列出 `match` 關鍵字，後面跟著一個表達式，在此例中是 `coin` 這個值。這看起來非常類似於與 `if` 一起使用的條件表達式，但有一個很大的區別：對於 `if`，條件需要評估為一個布林值，但在這裡它可以是任何型別。在這個例子中，`coin` 的型別是我們在第一行定義的 `Coin` enum。

接下來是 `match` 的分支 (arms)。一個分支有兩個部分：一個模式和一些程式碼。這裡的第一個分支的模式是值 `Coin::Penny`，然後是 `=>` 運算子，它將模式和要執行的程式碼分開。這種情況下的程式碼只是值 `1`。每個分支之間用逗號隔開。

當 `match` 表達式執行時，它會依序將結果值與每個分支的模式進行比較。如果一個模式與值匹配，與該模式相關聯的程式碼就會被執行。如果該模式與值不匹配，執行就會繼續到下一個分支，就像在硬幣分類機中一樣。我們可以有任意多的分支：在列表 6-3 中，我們的 `match` 有四個分支。

與每個分支相關聯的程式碼是一個表達式，而匹配分支中表達式的結果值，就是整個 `match` 表達式回傳的值。

如果 match 分支的程式碼很短，我們通常不使用大括號，就像在列表 6-3 中，每個分支只回傳一個值。如果你想在一個 match 分支中執行多行程式碼，你必須使用大括號，這時分支後面的逗號就變成可選的。例如，下面的程式碼每次用 `Coin::Penny` 呼叫方法時都會印出「Lucky penny!」，但仍然回傳區塊的最後一個值 `1`：

```rust
fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => {
            println!("Lucky penny!");
            1
        }
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}
```

### 綁定值的模式

Match 分支的另一個有用特性是它們可以綁定到與模式匹配的值的部分。這就是我們如何從 enum 變體中提取值的方法。

舉個例子，讓我們改變我們的一個 enum 變體，讓它內部持有資料。從 1999 年到 2008 年，美國鑄造的 25 美分硬幣 (quarters) 的一面為 50 個州設計了不同的圖案。沒有其他硬幣有州的設計，所以只有 quarters 才有這個額外的值。我們可以透過改變 `Quarter` 變體，使其包含一個儲存在內部的 `UsState` 值，來將這個資訊加入我們的 `enum` 中，就像我們在列表 6-4 中所做的那樣。

```rust
#[derive(Debug)] // so we can inspect the state in a minute
enum UsState {
    Alabama,
    Alaska,
    // --snip--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}
```

列表 6-4：一個 `Coin` enum，其中 `Quarter` 變體也持有一個 `UsState` 值

讓我們想像一下，一位朋友正在嘗試收集所有 50 個州的 25 美分硬幣。當我們按硬幣種類整理零錢時，我們也會喊出每個 25 美分硬幣相關州的名稱，這樣如果是我朋友沒有的州，他們就可以將其加入收藏。

在這段程式碼的 match 表達式中，我們在匹配 `Coin::Quarter` 變體值的模式中加入一個名為 `state` 的變數。當 `Coin::Quarter` 匹配時，`state` 變數將會綁定到該 25 美分硬幣的州的值。然後我們可以在該分支的程式碼中使用 `state`，如下所示：

```rust
fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter(state) => {
            println!("State quarter from {state:?}!");
            25
        }
    }
}
```

如果我們呼叫 `value_in_cents(Coin::Quarter(UsState::Alaska))`，`coin` 將會是 `Coin::Quarter(UsState::Alaska)`。當我們將這個值與每個 match 分支比較時，沒有一個匹配，直到我們到達 `Coin::Quarter(state)`。在那一點，`state` 的綁定將是 `UsState::Alaska` 這個值。然後我們可以在 `println!` 表達式中使用那個綁定，從而從 `Coin` enum 的 `Quarter` 變體中取出內部的州值。

### 使用 Option<T> 進行匹配

在上一節中，我們想在使用 `Option<T>` 時從 `Some` 情況中取出內部的 `T` 值；我們也可以使用 `match` 來處理 `Option<T>`，就像我們處理 `Coin` enum 一樣！我們將比較 `Option<T>` 的變體，而不是比較硬幣，但 `match` 表達式的運作方式保持不變。

假設我們想寫一個函式，它接收一個 `Option<i32>`，如果裡面有值，就將該值加 1。如果裡面沒有值，函式應該回傳 `None` 值，並且不試圖執行任何操作。

多虧了 `match`，這個函式非常容易編寫，看起來會像列表 6-5 那樣。

```rust
    fn plus_one(x: Option<i32>) -> Option<i32> {
        match x {
            None => None,
            Some(i) => Some(i + 1),
        }
    }

    let five = Some(5);
    let six = plus_one(five);
    let none = plus_one(None);
```

列表 6-5：一個在 `Option<i32>` 上使用 `match` 表達式的函式

讓我們更詳細地檢查 `plus_one` 的第一次執行。當我們呼叫 `plus_one(five)` 時，`plus_one` 主體中的變數 `x` 將會是 `Some(5)`。然後我們將它與每個 match 分支進行比較：

```rust
None => None,
```

`Some(5)` 這個值不符合 `None` 模式，所以我們繼續到下一個分支：

```rust
Some(i) => Some(i + 1),
```

`Some(5)` 是否匹配 `Some(i)`？是的！我們有相同的變體。`i` 綁定到 `Some` 中包含的值，所以 `i` 的值變為 `5`。然後執行 match 分支中的程式碼，所以我們將 `i` 的值加 1，並用我們的總和 `6` 創建一個新的 `Some` 值。

現在讓我們考慮列表 6-5 中 `plus_one` 的第二次呼叫，其中 `x` 是 `None`。我們進入 `match` 並與第一個分支比較：

```rust
None => None,
```

它匹配了！沒有值可以相加，所以程式停止並回傳 `=>` 右側的 `None` 值。因為第一個分支匹配了，所以不會再比較其他分支。

結合 `match` 和 enums 在許多情況下都很有用。你會在 Rust 程式碼中經常看到這種模式：對 enum 進行 `match`，將一個變數綁定到內部的資料，然後根據它執行程式碼。一開始可能有點棘手，但一旦你習慣了，你會希望所有語言都有這個功能。它一直是用戶的最愛。

### Match 是窮盡的

關於 `match`，我們還需要討論另一個方面：分支的模式必須涵蓋所有可能性。考慮一下我們 `plus_one` 函式的這個版本，它有一個錯誤，無法編譯：

```rust
fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        Some(i) => Some(i + 1),
    }
}
```

我們沒有處理 `None` 的情況，所以這段程式碼會導致一個 bug。幸運的是，這是 Rust 知道如何捕捉的 bug。如果我們嘗試編譯這段程式碼，我們會得到這個錯誤：

```
$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0004]: non-exhaustive patterns: `None` not covered
 --> src/main.rs:3:15
  |
3 |         match x {
  |               ^ pattern `None` not covered
  |
note: `Option<i32>` defined here
 --> /rustc/4eb161250e340c8f48f66e2b929ef4a5bed7c181/library/core/src/option.rs:572:1
 ::: /rustc/4eb161250e340c8f48f66e2b929ef4a5bed7c181/library/core/src/option.rs:576:5
  |
  = note: not covered
  = note: the matched value is of type `Option<i32>`
help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown
  |
4 ~             Some(i) => Some(i + 1),
5 ~             None => todo!(),
  |

For more information about this error, try `rustc --explain E0004`.
error: could not compile `enums` (bin "enums") due to 1 previous error
```

Rust 知道我們沒有涵蓋所有可能的情況，甚至知道我們忘記了哪個模式！Rust 中的 `match` 是_窮盡的 (exhaustive)_：我們必須窮盡所有可能性，程式碼才能有效。特別是在 `Option<T>` 的情況下，當 Rust 阻止我們忘記明確處理 `None` 的情況時，它保護我們免於在可能擁有 null 時假設我們有值，從而使前面討論的十億美元錯誤不可能發生。

### 全捕捉模式與 _ 預留位置

使用 enums，我們也可以對幾個特定的值採取特殊行動，但對所有其他值採取一個預設行動。想像我們正在實作一個遊戲，如果你擲骰子得到 3，你的玩家不動，而是得到一頂新潮的帽子。如果你擲到 7，你的玩家會失去一頂新潮的帽子。對於所有其他值，你的玩家在遊戲板上移動那麼多格。這是一個實作該邏輯的 `match`，骰子擲出的結果是硬編碼的，而不是隨機值，所有其他邏輯都由沒有本體的函式表示，因為實際實作它們超出了本例的範圍：

```rust
    let dice_roll = 9;
    match dice_roll {
        3 => add_fancy_hat(),
        7 => remove_fancy_hat(),
        other => move_player(other),
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
    fn move_player(num_spaces: u8) {}
```

對於前兩個分支，模式是字面值 `3` 和 `7`。對於涵蓋所有其他可能值的最後一個分支，模式是我們選擇命名為 `other` 的變數。為 `other` 分支執行的程式碼透過將變數傳遞給 `move_player` 函式來使用它。

這段程式碼可以編譯，儘管我們沒有列出 `u8` 可能擁有的所有值，因為最後一個模式將匹配所有未明確列出的值。這個全捕捉 (catch-all) 模式滿足了 `match` 必須是窮盡的的要求。請注意，我們必須將全捕捉分支放在最後，因為模式是按順序評估的。如果我們將全捕捉分支放在前面，其他分支將永遠不會執行，所以如果在全捕捉之後添加分支，Rust 會警告我們！

Rust 還有一個模式，當我們想要一個全捕捉但不想*使用*全捕捉模式中的值時可以使用：`_` 是一個特殊的模式，它匹配任何值並且不綁定到該值。這告訴 Rust 我們不打算使用這個值，所以 Rust 不會警告我們有未使用的變數。

讓我們改變一下遊戲規則：現在，如果你擲出除了 3 或 7 以外的任何數字，你必須重擲。我們不再需要使用全捕捉的值，所以我們可以將程式碼改為使用 `_` 而不是名為 `other` 的變數：

```rust
    let dice_roll = 9;
    match dice_roll {
        3 => add_fancy_hat(),
        7 => remove_fancy_hat(),
        _ => reroll(),
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
    fn reroll() {}
```

這個例子也滿足了窮盡性的要求，因為我們在最後一個分支中明確忽略了所有其他值；我們沒有忘記任何東西。

最後，我們再改變一次遊戲規則，如果你擲出除了 3 或 7 以外的任何數字，你的回合就什麼都不會發生。我們可以用單位值（我們在「Tuple 型別」一節中提到的空 tuple 型別）作為與 `_` 分支對應的程式碼來表示：

```rust
    let dice_roll = 9;
    match dice_roll {
        3 => add_fancy_hat(),
        7 => remove_fancy_hat(),
        _ => (),
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
```

在這裡，我們明確告訴 Rust，我們不打算使用任何不匹配前面分支模式的其他值，並且在這種情況下我們不想執行任何程式碼。

關於模式和匹配，我們將在第 19 章中介紹更多內容。現在，我們將轉向 `if let` 語法，在 `match` 表達式有點冗長的情況下，它可能很有用。

## 使用 if let 的簡潔控制流程

`if let` 語法讓你將 `if` 和 `let` 結合起來，用一種較不冗長的方式來處理匹配一種模式而忽略其餘模式的值。考慮列表 6-6 中的程式，它對 `config_max` 變數中的 `Option<u8>` 值進行匹配，但只希望在值是 `Some` 變體時執行程式碼。

```rust
let config_max = Some(3u8);
match config_max {
    Some(max) => println!("The maximum is configured to be {max}"),
    _ => (),
}
```

列表 6-6：一個只關心在值為 `Some` 時執行程式碼的 `match`

如果值是 `Some`，我們透過在模式中將值綁定到變數 `max` 來印出 `Some` 變體中的值。我們不想對 `None` 值做任何事。為了滿足 `match` 表達式，我們在處理完一個變體後必須加上 `_ => ()`，這是一段煩人的樣板程式碼。

取而代之，我們可以用 `if let` 以更短的方式來寫。下面的程式碼與列表 6-6 中的 `match` 行為相同：

```rust
let config_max = Some(3u8);
if let Some(max) = config_max {
    println!("The maximum is configured to be {max}");
}
```

`if let` 語法接受一個模式和一個由等號分隔的表達式。它的運作方式與 `match` 相同，其中表達式被給予 `match`，而模式是它的第一個分支。在這種情況下，模式是 `Some(max)`，而 `max` 綁定到 `Some` 內部的值。然後我們可以在 `if let` 區塊的主體中使用 `max`，就像我們在對應的 `match` 分支中使用 `max` 一樣。只有當值與模式匹配時，`if let` 區塊中的程式碼才會執行。

使用 `if let` 意味著更少的打字、更少的縮排和更少的樣板程式碼。然而，你會失去 `match` 強制的窮盡性檢查，該檢查確保你沒有忘記處理任何情況。在 `match` 和 `if let` 之間做選擇，取決於你在特定情況下要做什麼，以及獲得簡潔性是否值得失去窮盡性檢查。

換句話說，你可以把 `if let` 看作是一個 `match` 的語法糖，它在值匹配一個模式時執行程式碼，然後忽略所有其他值。

我們可以在 `if let` 中包含一個 `else`。與 `else` 搭配的程式碼區塊，與等同於 `if let` 和 `else` 的 `match` 表達式中與 `_` 情況搭配的程式碼區塊相同。回想一下列表 6-4 中的 `Coin` enum 定義，其中 `Quarter` 變體也持有一個 `UsState` 值。如果我們想計算我們看到的所有非 25 美分硬幣，同時也宣布 25 美分硬幣的州別，我們可以用一個 `match` 表達式來做到，像這樣：

```rust
let mut count = 0;
match coin {
    Coin::Quarter(state) => println!("State quarter from {state:?}!"),
    _ => count += 1,
}
```

或者我們可以使用 `if let` 和 `else` 表達式，像這樣：

```rust
let mut count = 0;
if let Coin::Quarter(state) = coin {
    println!("State quarter from {state:?}!");
} else {
    count += 1;
}
```

## 使用 let...else 保持在「快樂路徑」上

常見的模式是當一個值存在時執行某些計算，否則回傳一個預設值。繼續我們帶有 `UsState` 值的硬幣範例，如果我們想根據 25 美分硬幣上的州有多老來說一些有趣的話，我們可能會在 `UsState` 上引入一個方法來檢查州的年齡，像這樣：

```rust
impl UsState {
    fn existed_in(&self, year: u16) -> bool {
        match self {
            UsState::Alabama => year >= 1819,
            UsState::Alaska => year >= 1959,
            // -- snip --
        }
    }
}
```

然後我們可能會使用 `if let` 來匹配硬幣的型別，在條件的主體內引入一個 `state` 變數，如列表 6-7 所示。

```rust
fn describe_state_quarter(coin: Coin) -> Option<String> {
    if let Coin::Quarter(state) = coin {
        if state.existed_in(1900) {
            Some(format!("{state:?} is pretty old, for America!"))
        } else {
            Some(format!("{state:?} is relatively new."))
        }
    } else {
        None
    }
}
```

列表 6-7：使用巢狀在 `if let` 內的條件來檢查一個州是否在 1900 年存在。

這樣可以完成工作，但它將工作推入了 `if let` 陳述式的主體中，如果要做的工作更複雜，可能很難確切地追蹤頂層分支之間的關係。我們也可以利用表達式會產生一個值這一點，要麼從 `if let` 中產生 `state`，要麼提前回傳，如列表 6-8 所示。（你也可以用 `match` 做到類似的事。）

```rust
fn describe_state_quarter(coin: Coin) -> Option<String> {
    let state = if let Coin::Quarter(state) = coin {
        state
    } else {
        return None;
    };

    if state.existed_in(1900) {
        Some(format!("{state:?} is pretty old, for America!"))
    } else {
        Some(format!("{state:?} is relatively new."))
    }
}
```

列表 6-8：使用 `if let` 來產生一個值或提前回傳。

不過，這樣追蹤起來也有點煩人！`if let` 的一個分支產生一個值，而另一個分支則完全從函式中回傳。

為了讓這個常見的模式表達起來更美好，Rust 有 `let...else`。`let...else` 語法左邊接受一個模式，右邊接受一個表達式，非常類似於 `if let`，但它沒有 `if` 分支，只有一個 `else` 分支。如果模式匹配，它將在外部作用域中綁定模式中的值。如果模式*不*匹配，程式將流向 `else` 分支，該分支必須從函式中回傳。

在列表 6-9 中，你可以看到列表 6-8 在使用 `let...else` 取代 `if let` 後的樣子。

```rust
fn describe_state_quarter(coin: Coin) -> Option<String> {
    let Coin::Quarter(state) = coin else {
        return None;
    };

    if state.existed_in(1900) {
        Some(format!("{state:?} is pretty old, for America!"))
    } else {
        Some(format!("{state:?} is relatively new."))
    }
}
```

列表 6-9：使用 `let...else` 來闡明函式的流程。

注意，這樣它在函式的主體中保持在「快樂路徑」（happy path）上，而不會像 `if let` 那樣，對於兩個分支有顯著不同的控制流程。

如果你遇到程式中的邏輯太過冗長，無法用 `match` 表達的情況，請記住 `if let` 和 `let...else` 也在你的 Rust 工具箱中。

## 總結

我們現在已經涵蓋了如何使用 enums 來創建自訂型別，這些型別可以是列舉值集合中的一個。我們展示了標準函式庫的 `Option<T>` 型別如何幫助你利用型別系統來防止錯誤。當 enum 值內部有資料時，你可以使用 `match` 或 `if let` 來提取和使用這些值，這取決於你需要處理多少種情況。

你的 Rust 程式現在可以使用 structs 和 enums 來表達你領域中的概念。創建自訂型別用於你的 API 可以確保型別安全：編譯器將確保你的函式只會得到每個函式期望的型別的值。

為了向你的用戶提供一個組織良好、易於使用且只暴露用戶真正需要的 API，現在讓我們轉向 Rust 的模組。
