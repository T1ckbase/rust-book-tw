<!-- DO NOT EDIT THIS FILE.

This file is periodically generated from the content in the `/src/`
directory, so all fixes need to be made in `/src/`.
-->

[TOC]

# 撰寫一個猜數字遊戲

讓我們一起動手做一個專案來開始學習 Rust 吧！本章將透過一個實際的程式，向你介紹一些常見的 Rust 概念。你將會學到 `let`、`match`、方法（method）、關聯函數（associated function）、外部 crate 等等！在接下來的章節中，我們將更詳細地探討這些概念。在本章中，你將只是練習一下基礎知識。

我們將實作一個經典的程式設計入門問題：一個猜數字遊戲。它的運作方式如下：程式會產生一個 1 到 100 之間的隨機整數。然後它會提示玩家輸入一個猜測。輸入猜測後，程式會指出猜測的數字是太低還是太高。如果猜對了，遊戲會印出恭賀訊息並結束。

## 設定一個新專案

要設定一個新專案，請前往你在第 1 章建立的 _projects_ 目錄，並使用 Cargo 建立一個新專案，如下所示：

```
$ cargo new guessing_game
$ cd guessing_game
```

第一個指令 `cargo new` 接受專案名稱（`guessing_game`）作為第一個參數。第二個指令會切換到新專案的目錄。

看看產生的 _Cargo.toml_ 檔案：

<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial
rm -rf no-listing-01-cargo-new
cargo new no-listing-01-cargo-new --name guessing_game
cd no-listing-01-cargo-new
cargo run > output.txt 2>&1
cd ../../..
-->

檔案名稱：Cargo.toml

```
[package]
name = "guessing_game"
version = "0.1.0"
edition = "2024"

[dependencies]
```

如同你在第 1 章所見，`cargo new` 為你產生了一個「Hello, world!」程式。來看看 _src/main.rs_ 檔案：

檔案名稱：src/main.rs

```rust
fn main() {
    println!("Hello, world!");
}
```

現在讓我們用 `cargo run` 指令，一步到位地編譯並執行這個「Hello, world!」程式：

```
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.08s
     Running `target/debug/guessing_game`
Hello, world!
```

`run` 指令在你需要快速迭代專案時非常方便，就像我們在這個遊戲中所做的，在進入下一次迭代前快速測試每一次的變更。

重新打開 _src/main.rs_ 檔案。你將會在這個檔案中撰寫所有的程式碼。

## 處理一個猜測

猜數字遊戲程式的第一部分將會要求使用者輸入，處理該輸入，並檢查輸入是否符合預期格式。首先，我們將允許玩家輸入一個猜測。將列表 2-1 中的程式碼輸入到 _src/main.rs_。

src/main.rs

```rust
use std::io;

fn main() {
    println!("Guess the number!");

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin()
        .read_line(&mut guess)
        .expect("Failed to read line");

    println!("You guessed: {guess}");
}
```

列表 2-1：從使用者取得猜測並印出的程式碼

這段程式碼包含許多資訊，所以讓我們逐行檢視。為了取得使用者輸入並將結果輸出，我們需要將 `io` 這個輸入/輸出函式庫引入作用域（scope）。`io` 函式庫來自於標準函式庫，也就是 `std`：

```rust
use std::io;
```

預設情況下，Rust 會將標準函式庫中定義的一組項目帶入每個程式的作用域。這組項目被稱為 _prelude_，你可以在標準函式庫文件的 _https://doc.rust-lang.org/std/prelude/index.html_ 中看到所有內容。

如果你想使用的型別不在 prelude 中，你就必須使用 `use` 陳述式將該型別明確地引入作用域。使用 `std::io` 函式庫能提供你許多有用的功能，包含接受使用者輸入的能力。

如同你在第 1 章所見，`main` 函式是程式的進入點：

```rust
fn main() {
```

`fn` 語法宣告一個新函式；括號 `()` 表示沒有參數；而大括號 `{` 開始函式的主體。

如同你在第 1 章所學到的，`println!` 是一個會將字串印到螢幕上的 macro：

```rust
    println!("Guess the number!");

    println!("Please input your guess.");
```

這段程式碼印出一個提示，說明遊戲是什麼，並請求使用者輸入。

### 使用變數儲存值

接著，我們將建立一個*變數*來儲存使用者輸入，像這樣：

```rust
let mut guess = String::new();
```

現在程式變得有趣了！這一小行程式碼中發生了很多事。我們使用 `let` 陳述式來建立變數。這裡是另一個例子：

```rust
let apples = 5;
```

這一行建立了一個名為 `apples` 的新變數，並將其綁定到值 5。在 Rust 中，變數預設是不可變的（immutable），這意味著一旦我們給變數一個值，這個值就不能改變。我們將在第 3 章的「變數與可變性」一節中詳細討論這個概念。要讓一個變數可變，我們在變數名稱前加上 `mut`：

```rust
let apples = 5; // immutable
let mut bananas = 5; // mutable
```

> 注意：`//` 語法會開始一個持續到行尾的註解。Rust 會忽略註解中的所有內容。我們將在第 3 章中更詳細地討論註解。

回到猜數字遊戲程式，你現在知道 `let mut guess` 會引入一個名為 `guess` 的可變變數。等號（`=`）告訴 Rust 我們現在要將某個東西綁定到這個變數上。等號右邊是 `guess` 所綁定的值，也就是呼叫 `String::new` 的結果，這個函式會回傳一個 `String` 的新實例。`String` 是標準函式庫提供的一種字串型別，它是一個可增長的、UTF-8 編碼的文字片段。

`::new` 這行中的 `::` 語法表示 `new` 是 `String` 型別的一個關聯函數（associated function）。*關聯函數*是在一個型別上實作的函式，在此案例中是 `String`。這個 `new` 函式會建立一個新的空字串。你會在許多型別上找到 `new` 函式，因為它是一個常用於建立某種新值的函式名稱。

總而言之，`let mut guess = String::new();` 這一行建立了一個可變變數，目前它被綁定到一個新的、空的 `String` 實例。呼！

### 接收使用者輸入

回想一下，我們在程式的第一行用 `use std::io;` 引入了標準函式庫的輸入/輸出功能。現在我們將呼叫 `io` 模組中的 `stdin` 函式，它將讓我們能夠處理使用者輸入：

```rust
io::stdin()
    .read_line(&mut guess)
```

如果我們沒有在程式開頭用 `use std::io;` 匯入 `io` 模組，我們仍然可以透過 `std::io::stdin` 的形式來呼叫這個函式。`stdin` 函式會回傳一個 `std::io::Stdin` 的實例，這是一個代表你終端機標準輸入的控制代碼（handle）的型別。

接著，`.read_line(&mut guess)` 這一行在標準輸入的 handle 上呼叫 `read_line` 方法，以從使用者取得輸入。我們也將 `&mut guess` 作為引數傳遞給 `read_line`，來告訴它要將使用者輸入儲存在哪個字串中。`read_line` 的完整工作是接收使用者在標準輸入中鍵入的任何內容，並將其附加到一個字串中（而不會覆寫其內容），因此我們將該字串作為引數傳遞。字串引數必須是可變的，這樣方法才能改變字串的內容。

`&` 表示這個引數是一個_reference_，它提供了一種方法，讓你的程式碼的多個部分可以存取同一份資料，而無需將該資料多次複製到記憶體中。Reference 是一個複雜的功能，而 Rust 的主要優勢之一就是使用 reference 的安全性和簡易性。你不需要了解太多細節就能完成這個程式。目前，你只需要知道，就像變數一樣，reference 預設也是不可變的。因此，你需要寫 `&mut guess` 而不是 `&guess` 來使其可變。（第 4 章會更深入地解釋 reference。）

<!-- Old heading. Do not remove or links may break. -->

<a id="handling-potential-failure-with-the-result-type"></a>

### 使用 Result 處理潛在的失敗

我們還在處理這行程式碼。我們現在討論的是第三行文字，但請注意，它仍然是單一邏輯行程式碼的一部分。下一個部分是這個方法：

```rust
.expect("Failed to read line");
```

我們可以將這段程式碼寫成：

```rust
io::stdin().read_line(&mut guess).expect("Failed to read line");
```

然而，一行太長難以閱讀，所以最好將其分開。當你使用 `.method_name()` 語法呼叫方法時，通常明智的做法是加入換行符和其他空白來斷開長行。現在讓我們來討論這行程式碼的作用。

如前所述，`read_line` 會將使用者輸入的任何內容放入我們傳遞給它的字串中，但它也會回傳一個 `Result` 值。`Result` 是一個_列舉_（enumeration），通常稱為 _enum_，它是一種可以處於多種可能狀態之一的型別。我們稱每個可能的狀態為一個_變體_（variant）。

第 6 章將更詳細地介紹 enum。這些 `Result` 型別的目的是為了編碼錯誤處理的資訊。

`Result` 的變體是 `Ok` 和 `Err`。`Ok` 變體表示操作成功，並且它包含成功產生的值。`Err` 變體表示操作失敗，並且它包含關於操作為何或如何失敗的資訊。

`Result` 型別的值，就像任何型別的值一樣，都有定義在其上的方法。`Result` 的一個實例有一個你可以呼叫的 `expect` 方法。如果這個 `Result` 實例是一個 `Err` 值，`expect` 會導致程式崩潰並顯示你作為引數傳遞給 `expect` 的訊息。如果 `read_line` 方法回傳一個 `Err`，這很可能是來自底層作業系統的錯誤。如果這個 `Result` 實例是一個 `Ok` 值，`expect` 會取出 `Ok` 所持有的回傳值，並將該值回傳給你，以便你使用。在這種情況下，該值是使用者輸入的位元組數。

如果你不呼叫 `expect`，程式會編譯，但你會得到一個警告：

```
$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
warning: unused `Result` that must be used
  --> src/main.rs:10:5
   |
10 |     io::stdin().read_line(&mut guess);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: this `Result` may be an `Err` variant, which should be handled
   = note: `#[warn(unused_must_use)]` on by default
help: use `let _ = ...` to ignore the resulting value
   |
10 |     let _ = io::stdin().read_line(&mut guess);
   |     +++++++

warning: `guessing_game` (bin "guessing_game") generated 1 warning
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.59s
```

Rust 警告你沒有使用 `read_line` 回傳的 `Result` 值，這表示程式沒有處理一個可能的錯誤。

抑制這個警告的正確方法是實際編寫錯誤處理程式碼，但在我們的案例中，我們只想在問題發生時讓程式崩潰，所以我們可以使用 `expect`。你將在第 9 章學習如何從錯誤中恢復。

### 使用 println! 的預留位置印出值

除了右大括號之外，到目前為止的程式碼中只剩下一行需要討論：

```rust
println!("You guessed: {guess}");
```

這一行會印出現在包含使用者輸入的字串。`{}` 這組大括號是一個預留位置：可以把 `{}` 想像成小蟹鉗，把一個值夾在原地。當印出一個變數的值時，變數名稱可以放在大括號裡面。當印出一個運算式求值後的結果時，在格式化字串中放置空的大括號，然後在格式化字串後面跟著一個用逗號分隔的運算式列表，這些運算式會按照順序被印在每個空的預留位置中。在一次 `println!` 呼叫中印出變數和運算式結果會像這樣：

```rust
let x = 5;
let y = 10;

println!("x = {x} and y + 2 = {}", y + 2);
```

這段程式碼會印出 `x = 5 and y + 2 = 12`。

### 測試第一部分

讓我們來測試猜數字遊戲的第一部分。使用 `cargo run` 來執行它：

<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-01/
cargo clean
cargo run
input 6 -->

```
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 6.44s
     Running `target/debug/guessing_game`
Guess the number!
Please input your guess.
6
You guessed: 6
```

至此，遊戲的第一部分完成了：我們從鍵盤取得輸入，然後將其印出。

## 產生一個秘密數字

接著，我們需要產生一個秘密數字，讓使用者來猜。為了讓遊戲多玩幾次也有趣，這個秘密數字每次都應該不同。我們將使用一個 1 到 100 之間的隨機數字，這樣遊戲就不會太難。Rust 的標準函式庫目前還沒有包含隨機數功能。然而，Rust 團隊確實在 _https://crates.io/crates/rand_ 提供了一個 `rand` crate，具備了我們需要的功能。

### 使用 Crate 來獲得更多功能

記住，一個 crate 是一組 Rust 原始碼檔案的集合。我們一直在建置的專案是一個_二進位 crate_（binary crate），它是一個可執行檔。`rand` crate 是一個_函式庫 crate_（library crate），它包含的程式碼旨在被其他程式使用，不能自行執行。

Cargo 對外部 crate 的協調是 Cargo 真正的亮點。在我們能夠撰寫使用 `rand` 的程式碼之前，我們需要修改 _Cargo.toml_ 檔案，將 `rand` crate 作為一個依賴項加入。現在打開那個檔案，並在底部 `[dependencies]` 區段標頭下方加入下面這行，這是 Cargo 為你建立的。請務必完全按照我們這裡的方式指定 `rand` 及其版本號，否則本教學中的程式碼範例可能無法運作：

<!-- When updating the version of `rand` used, also update the version of
`rand` used in these files so they all match:
* ch07-04-bringing-paths-into-scope-with-the-use-keyword.md
* ch14-03-cargo-workspaces.md
-->

檔案名稱：Cargo.toml

```
[dependencies]
rand = "0.8.5"
```

在 _Cargo.toml_ 檔案中，標頭後面的所有內容都屬於該區塊，直到下一個區塊開始為止。在 `[dependencies]` 中，你告訴 Cargo 你的專案依賴哪些外部 crate 以及你需要這些 crate 的哪個版本。在這個案例中，我們指定 `rand` crate，並使用語意化版本（semantic version）規範 `0.8.5`。Cargo 理解語意化版本（有時稱為 _SemVer_），這是一種撰寫版本號的標準。規範 `0.8.5` 實際上是 `^0.8.5` 的簡寫，表示任何大於等於 0.8.5 但小於 0.9.0 的版本。

Cargo 認為這些版本的公開 API 與 0.8.5 版本相容，這個規範確保你會取得最新的修補程式版本，且仍然能與本章的程式碼一起編譯。任何 0.9.0 或更高的版本不保證具有與以下範例所使用的相同 API。

現在，不改變任何程式碼，讓我們來建置專案，如列表 2-2 所示。

<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
rm Cargo.lock
cargo clean
cargo build -->

```
$ cargo build
  Updating crates.io index
   Locking 15 packages to latest Rust 1.85.0 compatible versions
    Adding rand v0.8.5 (available: v0.9.0)
 Compiling proc-macro2 v1.0.93
 Compiling unicode-ident v1.0.17
 Compiling libc v0.2.170
 Compiling cfg-if v1.0.0
 Compiling byteorder v1.5.0
 Compiling getrandom v0.2.15
 Compiling rand_core v0.6.4
 Compiling quote v1.0.38
 Compiling syn v2.0.98
 Compiling zerocopy-derive v0.7.35
 Compiling zerocopy v0.7.35
 Compiling ppv-lite86 v0.2.20
 Compiling rand_chacha v0.3.1
 Compiling rand v0.8.5
 Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
  Finished `dev` profile [unoptimized + debuginfo] target(s) in 2.48s
```

列表 2-2：新增 rand crate 作為依賴後執行 `cargo build` 的輸出

你可能會看到不同的版本號（但由於 SemVer 的關係，它們都會與程式碼相容！）、不同的行（取決於作業系統），而且行的順序也可能不同。

當我們引入一個外部依賴時，Cargo 會從_註冊庫_（registry）中取得該依賴所需的所有東西的最新版本，註冊庫是來自 _https://crates.io/_ 的資料副本。Crates.io 是 Rust 生態系統中的人們發布他們的開源 Rust 專案以供他人使用的地方。

更新註冊庫後，Cargo 會檢查 `[dependencies]` 區段並下載任何尚未下載的列出的 crate。在這種情況下，雖然我們只將 `rand` 列為依賴項，但 Cargo 也抓取了 `rand` 運作所需的其他 crate。下載 crate 後，Rust 會編譯它們，然後在依賴項可用的情況下編譯專案。

如果你在沒有做任何變更的情況下立即再次執行 `cargo build`，你將不會看到除了 `Finished` 行以外的任何輸出。Cargo 知道它已經下載並編譯了依賴項，而且你沒有在 _Cargo.toml_ 檔案中對它們做任何變更。Cargo 也知道你沒有對你的程式碼做任何變更，所以它也不會重新編譯。由於無事可做，它就直接退出了。

如果你打開 _src/main.rs_ 檔案，做一個微不足道的變更，然後儲存並再次建置，你只會看到兩行輸出：

<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
touch src/main.rs
cargo build -->

```
$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.13s
```

這些行顯示 Cargo 僅用你對 _src/main.rs_ 檔案的微小變更來更新建置。你的依賴項沒有改變，所以 Cargo 知道它可以重用它已經為這些依賴項下載和編譯的內容。

#### 使用 Cargo.lock 檔案確保可重現的建置

Cargo 有一個機制可以確保你或任何其他人每次建置你的程式碼時都能重現相同的產物：Cargo 將只使用你指定的依賴項版本，直到你另行指示。例如，假設下週 `rand` crate 推出了 0.8.6 版本，該版本包含一個重要的錯誤修復，但同時也包含一個會破壞你程式碼的回歸（regression）。為了處理這種情況，在你第一次執行 `cargo build` 時，Rust 會建立 _Cargo.lock_ 檔案，所以我們現在在 _guessing_game_ 目錄中有了這個檔案。

當你第一次建置一個專案時，Cargo 會找出所有符合條件的依賴項版本，然後將它們寫入 _Cargo.lock_ 檔案。當你將來建置你的專案時，Cargo 會看到 _Cargo.lock_ 檔案存在，並使用其中指定的版本，而不是再次做所有找出版本的工作。這讓你可以自動擁有一個可重現的建置。換句話說， благодаря _Cargo.lock_ 檔案，你的專案將保持在 0.8.5 版本，直到你明確升級。因為 _Cargo.lock_ 檔案對於可重現的建置很重要，所以它通常會與專案中的其他程式碼一起被簽入（check into）版本控制系統。

#### 更新 Crate 以取得新版本

當你*確實*想要更新一個 crate 時，Cargo 提供了 `update` 指令，它會忽略 _Cargo.lock_ 檔案，並找出所有符合你 _Cargo.toml_ 規範的最新版本。然後 Cargo 會將這些版本寫入 _Cargo.lock_ 檔案。在這種情況下，Cargo 只會尋找大於 0.8.5 且小於 0.9.0 的版本。如果 `rand` crate 發布了兩個新版本 0.8.6 和 0.9.0，如果你執行 `cargo update`，你會看到以下內容：

<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
cargo update
assuming there is a new 0.8.x version of rand; otherwise use another update
as a guide to creating the hypothetical output shown here -->

```
$ cargo update
    Updating crates.io index
     Locking 1 package to latest Rust 1.85.0 compatible version
    Updating rand v0.8.5 -> v0.8.6 (available: v0.9.0)
```

Cargo 忽略了 0.9.0 版本。此時，你也會注意到你的 _Cargo.lock_ 檔案發生了變化，註明你現在使用的 `rand` crate 版本是 0.8.6。要使用 `rand` 0.9.0 版或 0.9._x_ 系列的任何版本，你必須將 _Cargo.toml_ 檔案更新成這樣：

```
[dependencies]
rand = "0.9.0"
```

下一次你執行 `cargo build` 時，Cargo 將會更新可用的 crate 註冊庫，並根據你指定的新版本重新評估你的 `rand` 需求。

關於 Cargo 及其生態系統還有很多可以說的，我們將在第 14 章討論，但目前你只需要知道這些。Cargo 使得重用函式庫變得非常容易，所以 Rustaceans 能夠撰寫由多個套件（package）組裝而成的小型專案。

### 產生一個隨機數字

讓我們開始使用 `rand` 來產生一個要猜的數字。下一步是更新 _src/main.rs_，如列表 2-3 所示。

src/main.rs

```rust
use std::io;

use rand::Rng;

fn main() {
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1..=100);

    println!("The secret number is: {secret_number}");

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin()
        .read_line(&mut guess)
        .expect("Failed to read line");

    println!("You guessed: {guess}");
}
```

列表 2-3：新增程式碼以產生隨機數字

首先我們加入 `use rand::Rng;` 這一行。`Rng` trait 定義了隨機數產生器所實作的方法，這個 trait 必須在作用域內，我們才能使用這些方法。第 10 章將詳細介紹 trait。

接著，我們在中間加入了兩行。在第一行，我們呼叫 `rand::thread_rng` 函式，它給了我們將要使用的特定隨機數產生器：一個局限於當前執行緒且由作業系統植入種子的產生器。然後我們在隨機數產生器上呼叫 `gen_range` 方法。這個方法是由我們用 `use rand::Rng;` 陳述式引入作用域的 `Rng` trait 所定義的。`gen_range` 方法接受一個範圍運算式作為引數，並在該範圍內產生一個隨機數。我們這裡使用的範圍運算式形式為 `start..=end`，它包含下限和上限，所以我們需要指定 `1..=100` 來請求一個 1 到 100 之間的數字。

> 注意：你不會憑空知道要使用哪個 trait、從 crate 呼叫哪個方法和函式，所以每個 crate 都有文件，其中包含使用說明。Cargo 的另一個酷炫功能是執行 `cargo doc --open` 指令，它會在本地建置你所有依賴項提供的文件，並在你的瀏覽器中打開它。例如，如果你對 `rand` crate 中的其他功能感興趣，可以執行 `cargo doc --open` 並在左側邊欄中點擊 `rand`。

第二個新行會印出秘密數字。這在我們開發程式時很有用，可以方便測試，但我們會在最終版本中將其刪除。如果程式一開始就印出答案，那就不算什麼遊戲了！

試著多執行幾次程式：

<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-03/
cargo run
4
cargo run
5
-->

```
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.02s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 7
Please input your guess.
4
You guessed: 4

$ cargo run
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.02s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 83
Please input your guess.
5
You guessed: 5
```

你應該會得到不同的隨機數字，而且它們都應該是介於 1 和 100 之間的數字。做得好！

## 比較猜測與秘密數字

現在我們有了使用者輸入和一個隨機數字，我們可以比較它們了。這一步驟如列表 2-4 所示。請注意，這段程式碼還不能編譯，我們稍後會解釋。

src/main.rs

```rust
use std::cmp::Ordering;
use std::io;

use rand::Rng;

fn main() {
    // --snip--

    println!("You guessed: {guess}");

    match guess.cmp(&secret_number) {
        Ordering::Less => println!("Too small!"),
        Ordering::Greater => println!("Too big!"),
        Ordering::Equal => println!("You win!"),
    }
}
```

列表 2-4：處理比較兩個數字可能的回傳值

首先我們加入另一個 `use` 陳述式，從標準函式庫將一個名為 `std::cmp::Ordering` 的型別引入作用域。`Ordering` 型別是另一個 enum，它有 `Less`、`Greater` 和 `Equal` 這幾個變體。這是當你比較兩個值時可能出現的三種結果。

然後我們在底部新增五行使用 `Ordering` 型別的程式碼。`cmp` 方法會比較兩個值，並且可以在任何可比較的事物上呼叫。它接受一個你想要比較的對象的 reference：這裡它比較的是 `guess` 和 `secret_number`。然後它會回傳我們用 `use` 陳述式引入作用域的 `Ordering` enum 的一個變體。我們使用一個 `match` 運算式，根據 `cmp` 呼叫 `guess` 和 `secret_number` 的值所回傳的 `Ordering` 變體來決定下一步該做什麼。

`match` 運算式由數個_分支_（arm）組成。一個分支包含一個要匹配的_模式_（pattern），以及當給定給 `match` 的值符合該分支的模式時應該執行的程式碼。Rust 會取得給定給 `match` 的值，並依序查看每個分支的模式。模式和 `match` 結構是強大的 Rust 功能：它們讓你能夠表達你的程式碼可能遇到的各種情況，並確保你處理了所有情況。這些功能將分別在第 6 章和第 19 章中詳細介紹。

讓我們用這裡使用的 `match` 運算式來走一個例子。假設使用者猜了 50，而這次隨機產生的秘密數字是 38。

當程式碼比較 50 和 38 時，`cmp` 方法會回傳 `Ordering::Greater`，因為 50 大於 38。`match` 運算式取得 `Ordering::Greater` 值，並開始檢查每個分支的模式。它查看第一個分支的模式 `Ordering::Less`，發現 `Ordering::Greater` 值不匹配 `Ordering::Less`，所以它忽略該分支中的程式碼，移至下一個分支。下一個分支的模式是 `Ordering::Greater`，這*確實*匹配 `Ordering::Greater`！該分支中的相關程式碼將會執行，並在螢幕上印出 `Too big!`。`match` 運算式在第一次成功匹配後結束，所以在這種情況下它不會查看最後一個分支。

然而，列表 2-4 中的程式碼還無法編譯。讓我們試試看：

<!--
The error numbers in this output should be that of the code **WITHOUT** the
anchor or snip comments
-->

```
$ cargo build
   Compiling libc v0.2.86
   Compiling getrandom v0.2.2
   Compiling cfg-if v1.0.0
   Compiling ppv-lite86 v0.2.10
   Compiling rand_core v0.6.2
   Compiling rand_chacha v0.3.0
   Compiling rand v0.8.5
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
error[E0308]: mismatched types
  --> src/main.rs:23:21
   |
23 |     match guess.cmp(&secret_number) {
   |                 --- ^^^^^^^^^^^^^^ expected `&String`, found `&{integer}`
   |                 |
   |                 arguments to this method are incorrect
   |
   = note: expected reference `&String`
              found reference `&{integer}`
note: method defined here
  --> /rustc/4eb161250e340c8f48f66e2b929ef4a5bed7c181/library/core/src/cmp.rs:964:8

For more information about this error, try `rustc --explain E0308`.
error: could not compile `guessing_game` (bin "guessing_game") due to 1 previous error
```

錯誤的核心是_型別不匹配_（mismatched types）。Rust 有一個強大、靜態的型別系統。然而，它也有型別推斷（type inference）。當我們寫 `let mut guess = String::new()` 時，Rust 能夠推斷出 `guess` 應該是一個 `String`，而不需要我們寫出型別。另一方面，`secret_number` 是一個數字型別。Rust 的一些數字型別可以有介於 1 和 100 之間的值：`i32`，一個 32 位元的數字；`u32`，一個無符號的 32 位元數字；`i64`，一個 64 位元的數字；以及其他。除非另有指定，Rust 預設為 `i32`，這就是 `secret_number` 的型別，除非你在其他地方添加型別資訊，導致 Rust 推斷出不同的數值型別。錯誤的原因是 Rust 無法比較一個字串和一個數字型別。

最終，我們希望將程式讀取為輸入的 `String` 轉換成數字型別，這樣我們才能將它與秘密數字進行數值比較。我們透過在 `main` 函式主體中加入這行程式碼來做到這點：

檔案名稱：src/main.rs

```rust
    // --snip--

    let mut guess = String::new();

    io::stdin()
        .read_line(&mut guess)
        .expect("Failed to read line");

    let guess: u32 = guess.trim().parse().expect("Please type a number!");

    println!("You guessed: {guess}");

    match guess.cmp(&secret_number) {
        Ordering::Less => println!("Too small!"),
        Ordering::Greater => println!("Too big!"),
        Ordering::Equal => println!("You win!"),
    }
```

這一行是：

```rust
let guess: u32 = guess.trim().parse().expect("Please type a number!");
```

我們建立了一個名為 `guess` 的變數。但是等等，程式不是已經有一個名為 `guess` 的變數了嗎？是的，但 Rust 很有用地允許我們用一個新的 `guess` 來遮蔽（shadow）前一個值。*遮蔽*讓我們可以重用 `guess` 這個變數名稱，而不用被迫建立兩個唯一的變數，例如 `guess_str` 和 `guess`。我們將在第 3 章中更詳細地介紹這個功能，但現在，只要知道這個功能常用於當你想要將一個值從一種型別轉換為另一種型別時。

我們將這個新變數綁定到 `guess.trim().parse()` 這個運算式上。運算式中的 `guess` 指的是原始的 `guess` 變數，它包含作為字串的輸入。`String` 實例上的 `trim` 方法會消除開頭和結尾的任何空白，我們必須在將字串轉換為只能包含數值資料的 `u32` 之前做這件事。使用者必須按下 <kbd>enter</kbd> 來滿足 `read_line` 並輸入他們的猜測，這會在字串中加入一個換行符。例如，如果使用者輸入 <kbd>5</kbd> 並按下 <kbd>enter</kbd>，`guess` 會是這樣：`5\n`。`\n` 代表「換行」。（在 Windows 上，按下 <kbd>enter</kbd> 會產生一個歸位符和一個換行符，`\r\n`。）`trim` 方法會消除 `\n` 或 `\r\n`，結果就只有 `5`。

字串上的 `parse` 方法會將字串轉換為另一種型別。這裡，我們用它來從字串轉換為數字。我們需要用 `let guess: u32` 來告訴 Rust 我們想要確切的數字型別。`guess` 後面的冒號 (`:`) 告訴 Rust 我們將要註解變數的型別。Rust 有一些內建的數字型別；這裡看到的 `u32` 是一個無符號的 32 位元整數。對於一個小的正數來說，這是一個很好的預設選擇。你將在第 3 章學習其他數字型別。

此外，這個範例程式中的 `u32` 註解和與 `secret_number` 的比較意味著 Rust 將推斷 `secret_number` 也應該是 `u32`。所以現在的比較將在兩個相同型別的值之間進行！

`parse` 方法只對可以邏輯上轉換為數字的字元有效，因此很容易出錯。例如，如果字串包含 `A👍%`，就無法將其轉換為數字。因為它可能會失敗，所以 `parse` 方法會回傳一個 `Result` 型別，就像 `read_line` 方法一樣（先前在「使用 `Result` 處理潛在的失敗」 at _#handling-potential-failure-with-result_<!-- ignore--> 中討論過）。我們將以同樣的方式處理這個 `Result`，再次使用 `expect` 方法。如果 `parse` 因為無法從字串中建立數字而回傳 `Err` `Result` 變體，`expect` 呼叫將會使遊戲崩潰並印出我們給它的訊息。如果 `parse` 能夠成功將字串轉換為數字，它將回傳 `Ok` `Result` 變體，而 `expect` 將從 `Ok` 值中回傳我們想要的數字。

現在讓我們來執行程式：

<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/no-listing-03-convert-string-to-number/
touch src/main.rs
cargo run
  76
-->

```
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.26s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 58
Please input your guess.
  76
You guessed: 76
Too big!
```

不錯！即使在猜測前加了空格，程式仍然判斷出使用者猜的是 76。多執行幾次程式，驗證不同類型輸入下的不同行為：猜對數字、猜一個太高的數字、和猜一個太低的數字。

現在遊戲的大部分功能都已完成，但使用者只能猜一次。讓我們透過加入一個迴圈來改變這一點！

## 使用迴圈允許多次猜測

`loop` 關鍵字會建立一個無限迴圈。我們將加入一個迴圈，給使用者更多猜數字的機會：

檔案名稱：src/main.rs

```rust
    // --snip--

    println!("The secret number is: {secret_number}");

    loop {
        println!("Please input your guess.");

        // --snip--

        match guess.cmp(&secret_number) {
            Ordering::Less => println!("Too small!"),
            Ordering::Greater => println!("Too big!"),
            Ordering::Equal => println!("You win!"),
        }
    }
}
```

如你所見，我們已經將從猜測輸入提示開始的所有內容都移到了一個迴圈中。請務必將迴圈內的每一行再縮排四個空格，然後再次執行程式。程式現在會永遠要求下一個猜測，這實際上引入了一個新問題。使用者似乎無法退出了！

使用者總是可以使用鍵盤快捷鍵 <kbd>ctrl</kbd>-<kbd>c</kbd> 來中斷程式。但還有另一種方法可以逃離這個貪得無厭的怪物，正如在「比較猜測與秘密數字」一節中關於 `parse` 的討論所提到的：如果使用者輸入非數字的答案，程式將會崩潰。我們可以利用這一點來讓使用者退出，如下所示：

<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/no-listing-04-looping/
touch src/main.rs
cargo run
(too small guess)
(too big guess)
(correct guess)
quit
-->

```
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.23s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 59
Please input your guess.
45
You guessed: 45
Too small!
Please input your guess.
60
You guessed: 60
Too big!
Please input your guess.
59
You guessed: 59
You win!
Please input your guess.
quit

thread 'main' panicked at src/main.rs:28:47:
Please type a number!: ParseIntError { kind: InvalidDigit }
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```

輸入 `quit` 會退出遊戲，但你會注意到，輸入任何其他非數字的內容也會退出。這至少可以說是不理想的；我們希望遊戲在猜對數字時也能停止。

### 猜對後退出

讓我們透過新增一個 `break` 陳述式，讓遊戲在使用者獲勝時退出：

檔案名稱：src/main.rs

```rust
        // --snip--

        match guess.cmp(&secret_number) {
            Ordering::Less => println!("Too small!"),
            Ordering::Greater => println!("Too big!"),
            Ordering::Equal => {
                println!("You win!");
                break;
            }
        }
    }
}
```

在 `You win!` 之後加入 `break` 這一行，會讓程式在使用者猜對秘密數字時退出迴圈。退出迴圈也意味著退出程式，因為迴圈是 `main` 的最後一部分。

### 處理無效輸入

為了進一步改善遊戲的行為，我們不要在使用者輸入非數字時讓程式崩潰，而是讓遊戲忽略非數字，讓使用者可以繼續猜測。我們可以透過修改將 `guess` 從 `String` 轉換為 `u32` 的那一行來做到這一點，如列表 2-5 所示。

src/main.rs

```rust
        // --snip--

        io::stdin()
            .read_line(&mut guess)
            .expect("Failed to read line");

        let guess: u32 = match guess.trim().parse() {
            Ok(num) => num,
            Err(_) => continue,
        };

        println!("You guessed: {guess}");

        // --snip--
```

列表 2-5：忽略非數字的猜測並要求再次猜測，而不是讓程式崩潰

我們從 `expect` 呼叫切換到 `match` 運算式，從遇到錯誤就崩潰轉為處理錯誤。記住，`parse` 回傳一個 `Result` 型別，而 `Result` 是一個 enum，有 `Ok` 和 `Err` 這兩個變體。我們在這裡使用 `match` 運算式，就像我們處理 `cmp` 方法的 `Ordering` 結果時一樣。

如果 `parse` 能夠成功地將字串轉換為數字，它將回傳一個包含結果數字的 `Ok` 值。該 `Ok` 值將匹配第一個分支的模式，而 `match` 運算式將只回傳 `parse` 產生並放入 `Ok` 值中的 `num` 值。這個數字最終會放到我們正在建立的新 `guess` 變數中，正是我們想要的位置。

如果 `parse` *無法*將字串轉換為數字，它將回傳一個包含更多錯誤資訊的 `Err` 值。`Err` 值不符合第一個 `match` 分支的 `Ok(num)` 模式，但它符合第二個分支的 `Err(_)` 模式。底線 `_` 是一個 catch-all（全捕捉）的值；在這個例子中，我們是說我們想要匹配所有的 `Err` 值，不管它們內部有什麼資訊。所以程式會執行第二個分支的程式碼 `continue`，它告訴程式進入 `loop` 的下一次迭代，並要求另一次猜測。所以，程式實際上忽略了 `parse` 可能遇到的所有錯誤！

現在程式中的一切都應該如預期般運作。讓我們來試試看：

<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-05/
cargo run
(too small guess)
(too big guess)
foo
(correct guess)
-->

```
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.13s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 61
Please input your guess.
10
You guessed: 10
Too small!
Please input your guess.
99
You guessed: 99
Too big!
Please input your guess.
foo
Please input your guess.
61
You guessed: 61
You win!
```

太棒了！只要再做一個小小的最後調整，我們就完成猜數字遊戲了。回想一下，程式仍然會印出秘密數字。這在測試時很好用，但它破壞了遊戲的樂趣。讓我們刪除輸出秘密數字的 `println!`。列表 2-6 顯示了最終的程式碼。

src/main.rs

```rust
use std::cmp::Ordering;
use std::io;

use rand::Rng;

fn main() {
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1..=100);

    loop {
        println!("Please input your guess.");

        let mut guess = String::new();

        io::stdin()
            .read_line(&mut guess)
            .expect("Failed to read line");

        let guess: u32 = match guess.trim().parse() {
            Ok(num) => num,
            Err(_) => continue,
        };

        println!("You guessed: {guess}");

        match guess.cmp(&secret_number) {
            Ordering::Less => println!("Too small!"),
            Ordering::Greater => println!("Too big!"),
            Ordering::Equal => {
                println!("You win!");
                break;
            }
        }
    }
}
```

列表 2-6：完整的猜數字遊戲程式碼

至此，你已經成功建置了猜數字遊戲。恭喜！

## 總結

這個專案是一個動手實作的方式，向你介紹了許多新的 Rust 概念：`let`、`match`、函式、使用外部 crate 等等。在接下來的幾章中，你將更詳細地學習這些概念。第 3 章涵蓋了大多數程式語言都有的概念，例如變數、資料型別和函式，並展示如何在 Rust 中使用它們。第 4 章探討 ownership，這是 Rust 與其他語言不同的一個特性。第 5 章討論 struct 和方法語法，第 6 章解釋 enum 如何運作。
