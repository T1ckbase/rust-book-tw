<!-- DO NOT EDIT THIS FILE.

This file is periodically generated from the content in the `/src/`
directory, so all fixes need to be made in `/src/`.
-->

## 關於作者

Carol Nichols 是 Rust Crates.io 團隊的成員，也曾是 Rust 核心團隊的成員。她是 Integer 32, LLC 的共同創辦人，這是世界上第一家專注於 Rust 的軟體顧問公司。Nichols 也曾組織過 Rust Belt Rust Conference。

Steve Klabnik 曾是 Rust 文件團隊的負責人，也是 Rust 的核心開發者之一。他是一位活躍的演講者和多產的開源貢獻者，先前曾參與過 Ruby 和 Ruby on Rails 等專案。

## 關於技術審閱者

JT 是 Rust 核心團隊的成員，也是 Rust 錯誤訊息格式、Rust Language Server (RLS) 和 Nushell 的共同創造者。他們自 2011 年開始使用 Rust，並於 2016 年加入 Mozilla 全職從事 Rust 的工作，協助塑造其廣泛應用的方向。如今，他們是一位自由的 Rust 培訓師和安全系統程式設計的倡導者。

## 目錄簡介

## 詳細目錄

## 前言

這件事並非總是如此清晰，但 Rust 程式語言的根本在於_賦能_ (empowerment)：無論你現在正在寫哪種類型的程式碼，Rust 都能賦予你力量，讓你比以前更有信心地在更廣泛的領域中進行程式設計。

舉例來說，處理記憶體管理、資料表示和 concurrency 等底層細節的「系統層級」工作。傳統上，這個程式設計領域被視為神秘的，只有少數投入多年學習以避免其臭名昭彰陷阱的人才能進入。即使是那些從業者也小心翼翼，以免他們的程式碼遭受攻擊、崩潰或損壞。

Rust 透過消除舊有的陷阱，並提供一套友善、精良的工具來協助你，從而打破了這些障礙。需要「深入」底層控制的程式設計師可以使用 Rust 來做到這一點，而無需承擔慣有的崩潰或安全漏洞風險，也無需學習善變工具鏈的細節。更棒的是，這門語言的設計旨在自然地引導你寫出在速度和記憶體使用方面都有效率的可靠程式碼。

已經在從事底層程式設計的程式設計師可以使用 Rust 來提升他們的抱負。例如，在 Rust 中引入 parallelism 是一個相對低風險的操作：compiler 會為你捕捉典型的錯誤。你可以更有信心地在你的程式碼中進行更積極的優化，而不必擔心會意外引入崩潰或漏洞。

但 Rust 並不局限於底層系統程式設計。它足夠表達力強且符合人體工學，使得編寫 CLI 應用程式、網頁伺服器和許多其他類型的程式碼都相當愉快——你將在本書後面找到簡單的範例。使用 Rust 可以讓你建立能夠從一個領域轉移到另一個領域的技能；你可以透過編寫一個網頁應用程式來學習 Rust，然後將這些相同的技能應用於你的 Raspberry Pi。

本書完全擁抱 Rust 賦予其使用者力量的潛力。這是一本友善且易於理解的讀物，旨在幫助你不僅提升對 Rust 的知識，也提升你作為一個程式設計師的影響力和信心。所以，投入進來，準備學習——並歡迎來到 Rust 社群！

Nicholas Matsakis and Aaron Turon

## 致謝

我們要感謝所有參與 Rust 語言開發的人，創造了一門值得為之寫書的絕佳語言。我們感謝 Rust 社群中的每一個人，他們如此熱情好客，並創造了一個值得歡迎更多人加入的環境。

我們特別感謝所有在網路上閱讀本書早期版本並提供回饋、錯誤報告和 pull request 的人。特別感謝 Eduard-Mihai Burtescu、Alex Crichton 和 JT 提供的技術審閱，以及 Karen Rustad Tölva 繪製的封面藝術。感謝我們在 No Starch 的團隊，包括 Bill Pollock、Liz Chadwick 和 Janelle Ludowise，他們改進了這本書並將其付梓。

Carol 很感激有機會參與本書的寫作。她感謝家人的持續愛護與支持，特別是她的丈夫 Jake Goulding 和她的女兒 Vivian。

## 序

本版文字假設你使用的是 Rust 1.62.0 (2022-06-30 發布) 或更新版本，並在所有專案的 _Cargo.toml_ 檔案中設定 `edition="2021"`，以將其配置為使用 Rust 2021 edition 的慣例。關於安裝或更新 Rust 的說明，請參見第 XX 頁的「安裝」；關於 edition 的資訊，請參見附錄 E。

Rust 語言的 2021 edition 包含許多改進，使 Rust 更符合人體工學並修正了一些不一致之處。除了反映這些改進的一般性更新外，本書的這一版本還有許多改進，以回應特定的回饋：

- 第 7 章包含了一個新的快速參考部分，介紹如何使用 module 將你的程式碼組織到多個檔案中。
- 第 13 章有新的和改進的 closure 範例，更清楚地說明了 capture、`move` 關鍵字和 `Fn` traits。
- 我們修正了書中一些小錯誤和不精確的措辭。感謝回報這些問題的讀者！

請注意，即使你更新了所使用的 Rust compiler 版本，任何來自本書早期版本且能夠編譯的程式碼，只要在其專案的 _Cargo.toml_ 中設定了相應的 edition，就仍然可以編譯。這就是 Rust 的向後相容性保證在發揮作用！

## 介紹

歡迎閱讀*《The Rust Programming Language》*，這是一本關於 Rust 的入門書籍。Rust 程式語言幫助你編寫更快、更可靠的軟體。在程式語言設計中，高階的人體工學和底層的控制往往是互相矛盾的；Rust 挑戰了這種衝突。透過平衡強大的技術能力和出色的開發者體驗，Rust 讓你可以選擇控制底層細節（例如記憶體使用），而無需承擔傳統上與此類控制相關的所有麻煩。

## Rust 適合誰

出於各種原因，Rust 對許多人來說都是理想的選擇。讓我們來看看幾個最重要的群體。

### 開發者團隊

Rust 正被證明是一個富有成效的工具，適用於由不同系統程式設計知識水平的開發者組成的大型團隊協作。底層程式碼容易出現各種細微的 bug，在大多數其他語言中，這些 bug 只能透過經驗豐富的開發者進行大量的測試和仔細的程式碼審查才能發現。在 Rust 中，compiler 扮演著守門員的角色，它會拒絕編譯帶有這些難以捉摸的 bug 的程式碼，包括 concurrency bug。透過與 compiler 的合作，團隊可以將時間專注於程式的邏輯，而不是追查 bug。

Rust 也為系統程式設計領域帶來了現代的開發者工具：

- Cargo，內建的依賴管理器和建置工具，使得在整個 Rust 生態系中新增、編譯和管理依賴變得輕鬆且一致。
- `rustfmt` 格式化工具確保開發者之間有著一致的程式碼風格。
- Rust Language Server 為整合開發環境 (IDE) 提供支援，實現程式碼自動完成和行內錯誤訊息。

透過使用 Rust 生態系中的這些及其他工具，開發者在編寫系統層級的程式碼時可以保持高生產力。

### 學生

Rust 適合學生和那些對學習系統概念感興趣的人。透過使用 Rust，許多人已經學會了作業系統開發等主題。社群非常熱情，樂於回答學生的問題。透過本書等努力，Rust 團隊希望讓更多人更容易接觸到系統概念，特別是那些程式設計新手。

### 公司

數百家公司，無論大小，都在生產環境中使用 Rust 來完成各種任務，包括命令列工具、網路服務、DevOps 工具、嵌入式裝置、音訊和視訊分析與轉碼、加密貨幣、生物資訊學、搜尋引擎、物聯網應用、機器學習，甚至是 Firefox 網頁瀏覽器的主要部分。

### 開源開發者

Rust 適合那些想要建構 Rust 程式語言、社群、開發者工具和函式庫的人。我們很樂意你能為 Rust 語言做出貢獻。

### 重視速度和穩定性的人

Rust 適合那些渴望語言兼具速度和穩定性的人。所謂速度，我們指的是 Rust 程式碼的執行速度，以及 Rust 讓你編寫程式的速度。Rust compiler 的檢查透過功能增加和重構來確保穩定性。這與那些沒有這些檢查的語言中脆弱的舊程式碼形成對比，開發者通常不敢修改這些程式碼。透過追求 zero-cost abstractions，即將高階功能編譯成與手寫程式碼一樣快的底層程式碼，Rust 努力使安全的程式碼也成為快速的程式碼。

Rust 語言也希望能支援許多其他使用者；這裡提到的只是其中一些最大的利害關係人。總體而言，Rust 最大的抱負是透過提供安全性*和*生產力、速度*和*人體工學，來消除程式設計師數十年來一直接受的權衡。試試 Rust，看看它的選擇是否適合你。

## 本書適合的讀者

本書假設你已經用過其他程式語言寫過程式碼，但並不假設是哪一種。我們試圖讓內容對來自各種程式設計背景的人都易於理解。我們不會花太多時間討論什麼是程式設計或如何思考它。如果你是程式設計的全新手，閱讀一本專門介紹程式設計的書會更適合你。

## 如何使用本書

一般來說，本書假設你會從頭到尾按順序閱讀。後面的章節會建立在前面章節的概念之上，而前面的章節可能不會深入探討某個特定主題的細節，但在後面的章節會重新討論該主題。

在本書中，你會找到兩種章節：概念章節和專案章節。在概念章節中，你將學習 Rust 的某個方面。在專案章節中，我們將一起建構小型程式，應用你目前所學的知識。第 2 章、第 12 章和第 20 章是專案章節；其餘的是概念章節。

**第 1 章** 解釋如何安裝 Rust、如何編寫「Hello, world!」程式，以及如何使用 Rust 的套件管理器和建置工具 Cargo。**第 2 章** 是一個動手實作的 Rust 程式編寫入門，帶你建構一個猜數字遊戲。在這裡，我們將高層次地介紹概念，後面的章節將提供更多細節。如果你想立刻動手，第 2 章就是你的好去處。**第 3 章** 涵蓋了與其他程式語言相似的 Rust 功能，在**第 4 章**你將學習 Rust 的 ownership 系統。如果你是一個特別細心的學習者，喜歡在進入下一個主題前學習所有細節，你可能會想跳過第 2 章直接到第 3 章，然後在想做專案應用所學細節時再回到第 2 章。

**第 5 章** 討論 structs 和 methods，**第 6 章** 涵蓋 enums、`match` 表達式和 `if let` 控制流程結構。你將使用 structs 和 enums 在 Rust 中製作自訂型別。

在**第 7 章**，你將學習 Rust 的 module 系統以及組織程式碼和其公開應用程式介面 (API) 的隱私規則。**第 8 章** 討論標準函式庫提供的一些常見集合資料結構，例如 vectors、strings 和 hash maps。**第 9 章** 探討 Rust 的錯誤處理哲學和技巧。

**第 10 章** 深入探討 generics、traits 和 lifetimes，這些功能讓你能夠定義適用於多種類型的程式碼。**第 11 章** 講的是測試，即使有 Rust 的安全保證，測試對於確保你的程式邏輯正確仍然是必要的。在**第 12 章**，我們將自己實作 `grep` 命令列工具的一部分功能，該工具用於在檔案中搜尋文字。為此，我們將使用前面章節中討論的許多概念。

**第 13 章** 探討 closures 和 iterators：這些來自函數式程式語言的 Rust 功能。在**第 14 章**，我們將更深入地研究 Cargo，並討論與他人分享你的函式庫的最佳實踐。**第 15 章** 討論標準函式庫提供的 smart pointers 以及啟用其功能的 traits。

在**第 16 章**，我們將介紹不同的 concurrent 程式設計模型，並討論 Rust 如何幫助你無所畏懼地進行多執行緒程式設計。**第 17 章** 將探討 Rust 的慣例與你可能熟悉的物件導向程式設計原則有何異同。

**第 18 章** 是一份關於 pattern 和 pattern matching 的參考資料，它們是在 Rust 程式中表達想法的強大方式。**第 19 章** 包含了一系列感興趣的進階主題，包括 unsafe Rust、macros，以及更多關於 lifetimes、traits、型別、函數和 closures 的內容。

在**第 20 章**，我們將完成一個專案，在其中我們將實作一個底層的多執行緒網頁伺服器！

最後，一些附錄以更像參考資料的格式包含了關於該語言的有用資訊。**附錄 A** 涵蓋 Rust 的關鍵字，**附錄 B** 涵蓋 Rust 的運算子和符號，**附錄 C** 涵蓋標準函式庫提供的可派生 traits，**附錄 D** 涵蓋一些有用的開發工具，**附錄 E** 解釋 Rust editions。

閱讀本書沒有錯誤的方式：如果你想跳著讀，那就去做吧！如果遇到任何困惑，你可能需要跳回前面的章節。但做任何對你有用的事。

學習 Rust 的一個重要過程是學習如何閱讀 compiler 顯示的錯誤訊息：這些訊息將引導你寫出可運作的程式碼。因此，我們將提供許多無法編譯的範例，以及 compiler 在每種情況下會顯示的錯誤訊息。要知道，如果你輸入並執行一個隨機的範例，它可能無法編譯！請務必閱讀周圍的文字，看看你試圖運行的範例是否本來就預期會出錯。在大多數情況下，我們會引導你找到任何無法編譯程式碼的正確版本。

## 資源與如何貢獻本書

本書是開源的。如果你發現錯誤，請毫不猶豫地在 GitHub 上提出 issue 或發送 pull request，網址為 _https://github.com/rust-lang/book_。更多詳情請參閱 _https://github.com/rust-lang/book/blob/main/CONTRIBUTING.md_ 上的 _CONTRIBUTING.md_。

本書範例的原始碼、勘誤表和其他資訊可在 _https://www.nostarch.com/Rust2021_ 取得。
