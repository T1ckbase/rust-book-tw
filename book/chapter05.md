<!-- DO NOT EDIT THIS FILE.

This file is periodically generated from the content in the `/src/`
directory, so all fixes need to be made in `/src/`.
-->

[TOC]

# 使用 Struct 來組織相關的資料

_struct_，或稱 _structure_，是一種自訂的資料型別，讓你可以將多個相關的值打包在一起並命名，形成一個有意義的群組。如果你熟悉物件導向語言，_struct_ 就像是物件的資料屬性。在本章中，我們將比較並對照 tuple 與 struct，以你已知的知識為基礎，並展示在何種情況下 struct 是組織資料更好的方式。

我們將示範如何定義和實例化 struct。我們將討論如何定義關聯函式，特別是那種稱為 _methods_ 的關聯函式，用來指定與 struct 型別相關的行為。Struct 和 enum（將在第 6 章討論）是在你的程式領域中建立新型別的基礎，以充分利用 Rust 在編譯時期的型別檢查。

## 定義與實例化 Struct

Struct 與我們在「Tuple 型別」一節中討論過的 tuple 相似，兩者都包含多個相關的值。就像 tuple 一樣，struct 的各個部分可以是不同的型別。與 tuple 不同的是，在 struct 中，你會為每一份資料命名，這樣就能清楚地知道這些值的意義。加上這些名稱意味著 struct 比 tuple 更具彈性：你不需要依賴資料的順序來指定或存取一個 instance 的值。

要定義一個 struct，我們輸入 `struct` 關鍵字並為整個 struct 命名。一個 struct 的名稱應該描述被組織在一起的資料片段的重要性。然後，在大括號內，我們定義資料片段的名稱和型別，我們稱之為 _fields_。例如，列表 5-1 展示了一個儲存使用者帳戶資訊的 struct。

src/main.rs

```rust
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}
```

列表 5-1：一個 `User` struct 的定義

在定義好 struct 後，若要使用它，我們需要為每個 field 指定具體的值來建立一個該 struct 的 _instance_。我們透過陳述 struct 的名稱，然後加上包含 _`key: value`_ 配對的大括號來建立一個 instance，其中 key 是 field 的名稱，而 value 是我們想要儲存在這些 field 中的資料。我們不必按照在 struct 中宣告的順序來指定 field。換句話說，struct 的定義就像是該型別的通用模板，而 instance 則是用特定的資料填入該模板，以建立該型別的值。例如，我們可以宣告一個特定的使用者，如列表 5-2 所示。

src/main.rs

```rust
fn main() {
    let user1 = User {
        active: true,
        username: String::from("someusername123"),
        email: String::from("someone@example.com"),
        sign_in_count: 1,
    };
}
```

列表 5-2：建立 `User` struct 的一個 instance

要從 struct 中取得特定的值，我們使用點號標記法。例如，要存取這位使用者的電子郵件地址，我們使用 `user1.email`。如果 instance 是可變的，我們可以使用點號標記法並對特定 field 賦值來改變值。列表 5-3 展示了如何改變一個可變的 `User` instance 中 `email` field 的值。

src/main.rs

```rust
fn main() {
    let mut user1 = User {
        active: true,
        username: String::from("someusername123"),
        email: String::from("someone@example.com"),
        sign_in_count: 1,
    };

    user1.email = String::from("anotheremail@example.com");
}
```

列表 5-3：改變一個 `User` instance 中 `email` field 的值

請注意，整個 instance 必須是可變的；Rust 不允許我們只將某些 field 標記為可變。如同任何運算式，我們可以在函式主體的最後一個運算式中建構一個新的 struct instance，以隱式地回傳該新 instance。

列表 5-4 展示了一個 `build_user` 函式，它回傳一個帶有給定 email 和 username 的 `User` instance。`active` field 的值為 `true`，而 `sign_in_count` 的值為 `1`。

src/main.rs

```rust
fn build_user(email: String, username: String) -> User {
    User {
        active: true,
        username: username,
        email: email,
        sign_in_count: 1,
    }
}
```

列表 5-4：一個 `build_user` 函式，它接受一個 email 和 username 並回傳一個 `User` instance

將函式參數命名為與 struct field 相同的名稱是合理的，但必須重複 `email` 和 `username` 的 field 名稱和變數有點繁瑣。如果 struct 有更多 field，重複每個名稱會變得更加惱人。幸運的是，有一種方便的簡寫法！

<!-- Old heading. Do not remove or links may break. -->

<a id="using-the-field-init-shorthand-when-variables-and-fields-have-the-same-name"></a>

### 使用 Field Init 簡寫法

因為列表 5-4 中的參數名稱和 struct field 名稱完全相同，我們可以使用 _field init 簡寫_ 語法來重寫 `build_user`，使其行為完全相同，但沒有 `username` 和 `email` 的重複，如列表 5-5 所示。

src/main.rs

```rust
fn build_user(email: String, username: String) -> User {
    User {
        active: true,
        username,
        email,
        sign_in_count: 1,
    }
}
```

列表 5-5：一個 `build_user` 函式，因為 `username` 和 `email` 參數與 struct field 同名，所以使用了 field init 簡寫法

在這裡，我們正在建立一個 `User` struct 的新 instance，它有一個名為 `email` 的 field。我們想要將 `email` field 的值設為 `build_user` 函式中 `email` 參數的值。因為 `email` field 和 `email` 參數同名，我們只需要寫 `email` 而不是 `email: email`。

### 使用 Struct 更新語法從其他 Instance 建立 Instance

通常，建立一個 struct 的新 instance，其中包含來自同型別另一個 instance 的大部分值，但更改某些值是很有用的。你可以使用 _struct 更新語法_ 來做到這一點。

首先，在列表 5-6 中，我們展示如何正常地在 `user2` 中建立一個新的 `User` instance，而不使用更新語法。我們為 `email` 設定了一個新值，但其餘的值則沿用我們在列表 5-2 中建立的 `user1` 的值。

src/main.rs

```rust
fn main() {
    // --snip--

    let user2 = User {
        active: user1.active,
        username: user1.username,
        email: String::from("another@example.com"),
        sign_in_count: user1.sign_in_count,
    };
}
```

列表 5-6：使用 `user1` 除了一個值以外的所有值來建立一個新的 `User` instance

使用 struct 更新語法，我們可以用更少的程式碼達到相同的效果，如列表 5-7 所示。`..` 語法指定了未明確設定的其餘 field 應具有與給定 instance 中 field 相同的值。

src/main.rs

```rust
fn main() {
    // --snip--

    let user2 = User {
        email: String::from("another@example.com"),
        ..user1
    };
}
```

列表 5-7：使用 struct 更新語法為 `User` instance 設定新的 `email` 值，但其餘值沿用 `user1` 的值

列表 5-7 中的程式碼也在 `user2` 中建立了一個 instance，它的 `email` 值不同，但 `username`、`active` 和 `sign_in_count` field 的值與 `user1` 相同。`..user1` 必須放在最後，以指定任何剩餘的 field 都應從 `user1` 中對應的 field 獲取其值，但我們可以選擇以任何順序為任意數量的 field 指定值，無論 struct 定義中 field 的順序為何。

請注意，struct 更新語法像賦值一樣使用 `=`；這是因為它會移動資料，就像我們在「變數與資料互動的方式：Move」一節中看到的一樣。在這個範例中，建立 `user2` 後，我們就不能再使用 `user1` 了，因為 `user1` 的 `username` field 中的 `String` 被移動到了 `user2`。如果我們為 `user2` 的 `email` 和 `username` 都提供了新的 `String` 值，因此只使用了 `user1` 的 `active` 和 `sign_in_count` 值，那麼 `user1` 在建立 `user2` 之後仍然是有效的。`active` 和 `sign_in_count` 都是實作 `Copy` trait 的型別，所以我們在「只存在於 Stack 上的資料：Copy」一節中討論的行為會適用。在這個範例中，我們仍然可以使用 `user1.email`，因為它的值沒有被移出 `user1`。

### 使用沒有命名字段的 Tuple Struct 來建立不同的型別

Rust 也支援看起來與 tuple 相似的 struct，稱為 _tuple structs_。Tuple structs 具有 struct 名稱提供的額外意義，但其 field 沒有名稱；它們只有 field 的型別。當你想要給整個 tuple 一個名稱，並使該 tuple 成為與其他 tuple 不同的型別，且當像常規 struct 那樣為每個 field 命名會顯得冗長或多餘時，tuple structs 很有用。

要定義一個 tuple struct，先使用 `struct` 關鍵字和 struct 名稱，後面跟著 tuple 中的型別。例如，在這裡我們定義並使用了兩個名為 `Color` 和 `Point` 的 tuple structs：

src/main.rs

```rust
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

fn main() {
    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);
}
```

請注意，`black` 和 `origin` 的值是不同的型別，因為它們是不同 tuple structs 的 instance。你定義的每個 struct 都是它自己的型別，即使 struct 內的 field 可能具有相同的型別。例如，一個接受 `Color` 型別參數的函式不能接受 `Point` 作為引數，即使這兩種型別都由三個 `i32` 值組成。除此之外，tuple struct instance 與 tuple 相似，你可以將它們解構成各個部分，並且你可以使用 `.` 後面跟著索引來存取單一值。與 tuple 不同的是，當你解構 tuple structs 時，你需要指明 struct 的型別名稱。例如，我們會寫 `let Point(x, y, z) = origin;` 來將 `origin` 這個點的值解構成名為 `x`、`y` 和 `z` 的變數。

### 沒有任何欄位的 Unit-Like Structs

你也可以定義沒有任何 field 的 struct！這些被稱為 _unit-like structs_，因為它們的行為類似於 `()`，即我們在「Tuple 型別」一節中提到的 unit type。當你需要在某個型別上實作一個 trait，但不想在該型別本身儲存任何資料時，unit-like structs 可能很有用。我們將在第 10 章討論 trait。以下是一個宣告和實例化名為 `AlwaysEqual` 的 unit struct 的範例：

src/main.rs

```rust
struct AlwaysEqual;

fn main() {
    let subject = AlwaysEqual;
}
```

要定義 `AlwaysEqual`，我們使用 `struct` 關鍵字、我們想要的名稱，然後是一個分號。不需要大括號或括號！然後我們可以用類似的方式在 `subject` 變數中取得 `AlwaysEqual` 的一個 instance：使用我們定義的名稱，沒有任何大括號或括號。想像一下，之後我們將為這個型別實作行為，使得 `AlwaysEqual` 的每個 instance 永遠等於任何其他型別的每個 instance，也許是為了在測試時有一個已知的結果。我們不需要任何資料來實作那種行為！你將在第 10 章看到如何定義 trait 並在任何型別上實作它們，包括 unit-like structs。

> ### Struct 資料的 Ownership
>
> 在列表 5-1 的 `User` struct 定義中，我們使用了有 ownership 的 `String` 型別，而不是 `&str` 字串 slice 型別。這是一個刻意的選擇，因為我們希望這個 struct 的每個 instance 都擁有其所有資料，並且只要整個 struct 有效，這些資料就有效。
>
> struct 也有可能儲存由其他東西所擁有的資料的引用，但這樣做需要使用 _lifetimes_，這是我們將在第 10 章討論的 Rust 特性。Lifetimes 確保 struct 所引用的資料只要 struct 本身有效，就一直有效。假設你試圖在一個 struct 中儲存一個引用而不指定 lifetimes，就像下面這樣；這是行不通的：
>
> <Listing file-name="src/main.rs">
>
> <!-- CAN'T EXTRACT SEE https://github.com/rust-lang/mdBook/issues/1127 -->
>
> ```rust,ignore,does_not_compile
> struct User {
>     active: bool,
>     username: &str,
>     email: &str,
>     sign_in_count: u64,
> }
>
> fn main() {
>     let user1 = User {
>         active: true,
>         username: "someusername123",
>         email: "someone@example.com",
>         sign_in_count: 1,
>     };
> }
> ```
>
> </Listing>
>
> 編譯器會抱怨它需要 lifetime specifiers：
>
> ```console
> $ cargo run
>    Compiling structs v0.1.0 (file:///projects/structs)
> error[E0106]: missing lifetime specifier
>  --> src/main.rs:3:15
>   |
> 3 |     username: &str,
>   |               ^ expected named lifetime parameter
>   |
> help: consider introducing a named lifetime parameter
>   |
> 1 ~ struct User<'a> {
> 2 |     active: bool,
> 3 ~     username: &'a str,
>   |
>
> error[E0106]: missing lifetime specifier
>  --> src/main.rs:4:12
>   |
> 4 |     email: &str,
>   |            ^ expected named lifetime parameter
>   |
> help: consider introducing a named lifetime parameter
>   |
> 1 ~ struct User<'a> {
> 2 |     active: bool,
> 3 |     username: &str,
> 4 ~     email: &'a str,
>   |
>
> For more information about this error, try `rustc --explain E0106`.
> error: could not compile `structs` (bin "structs") due to 2 previous errors
> ```
>
> 在第 10 章，我們將討論如何修復這些錯誤，以便你可以在 struct 中儲存引用，但目前，我們將使用像 `String` 這樣的 owned types 而不是像 `&str` 這樣的引用來修復這類錯誤。

<!-- manual-regeneration
for the error above
after running update-rustc.sh:
pbcopy < listings/ch05-using-structs-to-structure-related-data/no-listing-02-reference-in-struct/output.txt
paste above
add `> ` before every line -->

## 一個使用 Struct 的範例程式

為了理解我們何時可能想用 struct，讓我們來寫一個計算矩形面積的程式。我們將從使用單一變數開始，然後重構程式，直到我們改用 struct 為止。

讓我們用 Cargo 建立一個名為 _rectangles_ 的新 binary 專案，它將接收以像素為單位的矩形寬度和高度，並計算矩形的面積。列表 5-8 展示了一個簡短的程式，用一種方式在我們專案的 _src/main.rs_ 中實現了這個功能。

src/main.rs

```rust
fn main() {
    let width1 = 30;
    let height1 = 50;

    println!(
        "The area of the rectangle is {} square pixels.",
        area(width1, height1)
    );
}

fn area(width: u32, height: u32) -> u32 {
    width * height
}
```

列表 5-8：計算由獨立的寬度和高度變數指定的矩形面積

現在，使用 `cargo run` 執行這個程式：

```
$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.42s
     Running `target/debug/rectangles`
The area of the rectangle is 1500 square pixels.
```

這段程式碼透過呼叫 `area` 函式並傳入每個維度，成功地計算出矩形的面積，但我們可以做更多來讓這段程式碼更清晰易讀。

這段程式碼的問題在 `area` 的簽名中很明顯：

```rust
fn area(width: u32, height: u32) -> u32 {
```

`area` 函式應該是計算一個矩形的面積，但我們寫的函式有兩個參數，而且在我們的程式中沒有任何地方清楚地表明這兩個參數是相關的。將寬度和高度組合在一起會更具可讀性且更易於管理。我們在第 3 章的「Tuple 型別」一節中已經討論過一種方法：使用 tuple。

### 使用 Tuple 重構

列表 5-9 展示了我們程式的另一個版本，它使用了 tuple。

src/main.rs

```rust
fn main() {
    let rect1 = (30, 50);

    println!(
        "The area of the rectangle is {} square pixels.",
        area(rect1)
    );
}

fn area(dimensions: (u32, u32)) -> u32 {
    dimensions.0 * dimensions.1
}
```

列表 5-9：使用 tuple 指定矩形的寬度和高度

在某種程度上，這個程式更好。Tuple 讓我們增加了一點結構，而且我們現在只傳遞一個引數。但在另一方面，這個版本更不清晰：tuple 沒有為它們的元素命名，所以我們必須透過索引來存取 tuple 的部分，這使得我們的計算不那麼明顯。

混淆寬度和高度對於面積計算來說無關緊要，但如果我們想在螢幕上繪製矩形，這就很重要了！我們必須記住 `width` 是 tuple 索引 `0`，而 `height` 是 tuple 索引 `1`。如果別人要使用我們的程式碼，這會更難以理解和記住。因為我們沒有在程式碼中傳達資料的意義，所以現在更容易引入錯誤。

### 使用 Struct 重構：增加更多意義

我們使用 struct 來為資料加上標籤以增加意義。我們可以將我們正在使用的 tuple 轉換為一個 struct，為整體和各個部分都命名，如列表 5-10 所示。

src/main.rs

```rust
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        "The area of the rectangle is {} square pixels.",
        area(&rect1)
    );
}

fn area(rectangle: &Rectangle) -> u32 {
    rectangle.width * rectangle.height
}
```

列表 5-10：定義一個 `Rectangle` struct

在這裡，我們定義了一個 struct 並命名為 `Rectangle`。在大括號內，我們定義了 `width` 和 `height` 這兩個 field，它們的型別都是 `u32`。然後，在 `main` 中，我們建立了一個 `Rectangle` 的特定 instance，其寬度為 `30`，高度為 `50`。

我們的 `area` 函式現在定義為只接受一個參數，我們將其命名為 `rectangle`，其型別是對一個 `Rectangle` struct instance 的不可變借用。如第 4 章所述，我們希望借用 struct 而不是取得它的 ownership。這樣一來，`main` 函式就能保留其 ownership 並繼續使用 `rect1`，這就是我們在函式簽名和呼叫函式的地方使用 `&` 的原因。

`area` 函式存取 `Rectangle` instance 的 `width` 和 `height` field（請注意，存取一個被借用的 struct instance 的 field 不會移動 field 的值，這就是為什麼你經常看到 struct 的借用）。我們 `area` 的函式簽名現在確切地表達了我們的意思：計算 `Rectangle` 的面積，使用它的 `width` 和 `height` field。這傳達了寬度和高度是相互關聯的，並且為這些值提供了描述性的名稱，而不是使用 tuple 索引值 `0` 和 `1`。這在清晰度上是一大進步。

### 使用衍生 Trait 增加實用功能

在我們對程式進行除錯時，能夠印出 `Rectangle` 的 instance 並看到其所有 field 的值會很有用。列表 5-11 嘗試使用我們在前幾章中使用過的 `println!` 巨集。然而，這將行不通。

src/main.rs

```rust
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!("rect1 is {rect1}");
}
```

列表 5-11：嘗試印出一個 `Rectangle` instance

當我們編譯這段程式碼時，我們會得到一個錯誤，其核心訊息如下：

```
error[E0277]: `Rectangle` doesn't implement `std::fmt::Display`
```

`println!` 巨集可以進行多種格式化，預設情況下，大括號告訴 `println!` 使用稱為 `Display` 的格式化：意圖直接給終端使用者看的輸出。我們至今所見的原始型別預設都實作了 `Display`，因為只有一種方式可以向使用者顯示 `1` 或任何其他原始型別。但對於 struct，`println!` 應該如何格式化輸出就不那麼清楚了，因為有更多的顯示可能性：你想要逗號嗎？你想印出大括號嗎？所有 field 都應該顯示嗎？由於這種模糊性，Rust 不會去猜測我們想要什麼，而 struct 也沒有提供可與 `println!` 和 `{}` 預留位置一起使用的 `Display` 實作。

如果我們繼續閱讀錯誤訊息，我們會發現這個有用的提示：

```
= help: the trait `std::fmt::Display` is not implemented for `Rectangle`
= note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
```

讓我們試試看！`println!` 巨集的呼叫現在會變成 `println!("rect1 is {rect1:?}");`。在大括號內加上指示符 `:?` 會告訴 `println!` 我們想使用一種名為 `Debug` 的輸出格式。`Debug` trait 讓我們能以一種對開發者有用的方式印出我們的 struct，這樣我們就可以在除錯程式碼時看到它的值。

用這個變更來編譯程式碼。糟糕！我們仍然得到一個錯誤：

```
error[E0277]: `Rectangle` doesn't implement `Debug`
```

但編譯器再次給了我們一個有用的提示：

```
= help: the trait `Debug` is not implemented for `Rectangle`
= note: add `#[derive(Debug)]` to `Rectangle` or manually `impl Debug for Rectangle`
```

Rust _確實_ 包含了印出除錯資訊的功能，但我們必須明確地選擇讓我們的 struct 具備這個功能。為此，我們在 struct 定義之前加上外部屬性 `#[derive(Debug)]`，如列表 5-12 所示。

src/main.rs

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!("rect1 is {rect1:?}");
}
```

列表 5-12：加上屬性來衍生 `Debug` trait 並使用除錯格式印出 `Rectangle` instance

現在當我們執行程式時，我們不會得到任何錯誤，並且會看到以下輸出：

```
$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/rectangles`
rect1 is Rectangle { width: 30, height: 50 }
```

太好了！這不是最漂亮的輸出，但它顯示了這個 instance 的所有 field 的值，這在除錯時肯定會有幫助。當我們有更大的 struct 時，讓輸出更容易閱讀會很有用；在那些情況下，我們可以在 `println!` 字串中使用 `{:#?}` 而不是 `{:?}`。在這個例子中，使用 `{:#?}` 風格會輸出以下內容：

```
$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/rectangles`
rect1 is Rectangle {
    width: 30,
    height: 50,
}
```

另一種使用 `Debug` 格式印出值的方法是使用 `dbg!` 巨集，它會取得一個運算式的 ownership（相對於 `println!` 是取得一個引用），印出該 `dbg!` 巨集呼叫在程式碼中的檔案和行號以及該運算式的結果值，然後回傳該值的 ownership。

> 注意：呼叫 `dbg!` 巨集會印到標準錯誤主控台串流（`stderr`），而 `println!` 則是印到標準輸出主控台串流（`stdout`）。我們將在第 12 章的「將錯誤訊息寫入標準錯誤而非標準輸出」一節中更多地討論 `stderr` 和 `stdout`。

這裡有一個範例，我們對賦值給 `width` field 的值以及 `rect1` 中整個 struct 的值感興趣：

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let scale = 2;
    let rect1 = Rectangle {
        width: dbg!(30 * scale),
        height: 50,
    };

    dbg!(&rect1);
}
```

我們可以將 `dbg!` 包在 `30 * scale` 這個運算式外面，而且因為 `dbg!` 會回傳運算式值的 ownership，所以 `width` field 將會得到與沒有 `dbg!` 呼叫時相同的值。我們不希望 `dbg!` 取得 `rect1` 的 ownership，所以在下一次呼叫中我們使用 `rect1` 的引用。以下是這個範例的輸出：

```
$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.61s
     Running `target/debug/rectangles`
[src/main.rs:10:16] 30 * scale = 60
[src/main.rs:14:5] &rect1 = Rectangle {
    width: 60,
    height: 50,
}
```

我們可以看到第一段輸出是來自 _src/main.rs_ 的第 10 行，我們在那裡除錯 `30 * scale` 這個運算式，它的結果值是 `60`（整數實作的 `Debug` 格式化只會印出它們的值）。在 _src/main.rs_ 第 14 行的 `dbg!` 呼叫輸出了 `&rect1` 的值，也就是那個 `Rectangle` struct。這個輸出使用了 `Rectangle` 型別的漂亮 `Debug` 格式。當你試圖弄清楚你的程式碼在做什麼時，`dbg!` 巨集真的很有幫助！

除了 `Debug` trait 之外，Rust 還提供了許多 trait 讓我們可以與 `derive` 屬性一起使用，這些 trait 可以為我們的自訂型別增加有用的行為。這些 trait 和它們的行為列在附錄 C。我們將在第 10 章介紹如何用自訂行為來實作這些 trait，以及如何建立你自己的 trait。除了 `derive` 之外，還有許多其他的屬性；更多資訊請參見 Rust 參考手冊的「Attributes」部分，網址為 _https://doc.rust-lang.org/reference/attributes.html_。

我們的 `area` 函式非常特定：它只計算矩形的面積。將這個行為更緊密地與我們的 `Rectangle` struct 連結會很有幫助，因為它不適用於任何其他型別。讓我們來看看如何將 `area` 函式變成定義在我們 `Rectangle` 型別上的 `area` _method_ 來繼續重構這段程式碼。

## Method 語法

_Methods_ 與函式相似：我們用 `fn` 關鍵字和一個名稱來宣告它們，它們可以有參數和回傳值，並且它們包含一些在別處被呼叫時會執行的程式碼。與函式不同的是，methods 是在一個 struct（或 enum 或 trait object，我們將分別在第 6 章和第 18 章介紹）的上下文中定義的，而且它們的第一個參數總是 `self`，代表該 method 被呼叫的 struct instance。

### 定義 Method

讓我們把接受 `Rectangle` instance 作為參數的 `area` 函式，改為在 `Rectangle` struct 上定義一個 `area` method，如列表 5-13 所示。

src/main.rs

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        "The area of the rectangle is {} square pixels.",
        rect1.area()
    );
}
```

列表 5-13：在 `Rectangle` struct 上定義一個 `area` method

為了在 `Rectangle` 的上下文中定義函式，我們為 `Rectangle` 開始一個 `impl`（實作）區塊。這個 `impl` 區塊內的所有東西都將與 `Rectangle` 型別相關聯。然後我們將 `area` 函式移到 `impl` 大括號內，並將簽名中的第一個（在這個例子中也是唯一的）參數以及函式體內所有地方都改為 `self`。在 `main` 中，我們原本呼叫 `area` 函式並傳遞 `rect1` 作為引數，現在我們可以改用 _method 語法_ 在我們的 `Rectangle` instance 上呼叫 `area` method。Method 語法接在一個 instance 後面：我們加上一個點，後面跟著 method 名稱、括號和任何引數。

在 `area` 的簽名中，我們使用 `&self` 而不是 `rectangle: &Rectangle`。`&self` 實際上是 `self: &Self` 的簡寫。在 `impl` 區塊中，`Self` 型別是該 `impl` 區塊所對應的型別的別名。Methods 的第一個參數必須是名為 `self` 且型別為 `Self` 的參數，所以 Rust 讓你在第一個參數位置只用 `self` 這個名稱來簡寫。請注意，我們仍然需要在 `self` 簡寫前加上 `&` 來表示這個 method 借用了 `Self` instance，就像我們在 `rectangle: &Rectangle` 中做的一樣。Methods 可以取得 `self` 的 ownership、像我們這裡一樣不可變地借用 `self`，或者可變地借用 `self`，就像它們可以對任何其他參數做的一樣。

我們在這裡選擇 `&self` 的原因和在函式版本中使用 `&Rectangle` 的原因相同：我們不想取得 ownership，我們只想讀取 struct 中的資料，而不是寫入它。如果我們想在 method 的一部分操作中改變我們呼叫 method 的 instance，我們會使用 `&mut self` 作為第一個參數。一個透過只用 `self` 作為第一個參數來取得 instance ownership 的 method 很罕見；這種技巧通常用在 method 將 `self` 轉換成其他東西，並且你想防止呼叫者在轉換後使用原始 instance 的時候。

使用 methods 而不是函式的主要原因，除了提供 method 語法和不必在每個 method 的簽名中重複 `self` 的型別之外，是為了組織性。我們把所有可以對一個型別的 instance 做的操作都放在一個 `impl` 區塊中，而不是讓我們程式碼的未來使用者在我們提供的函式庫的各個地方尋找 `Rectangle` 的功能。

請注意，我們可以選擇給一個 method 與 struct 的某個 field 相同的名稱。例如，我們可以在 `Rectangle` 上定義一個也叫 `width` 的 method：

src/main.rs

```rust
impl Rectangle {
    fn width(&self) -> bool {
        self.width > 0
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    if rect1.width() {
        println!("The rectangle has a nonzero width; it is {}", rect1.width);
    }
}
```

在這裡，我們選擇讓 `width` method 在 instance 的 `width` field 值大於 `0` 時回傳 `true`，如果值是 `0` 則回傳 `false`：我們可以為了任何目的在同名 method 中使用一個 field。在 `main` 中，當我們在 `rect1.width` 後面加上括號時，Rust 知道我們指的是 `width` method。當我們不使用括號時，Rust 知道我們指的是 `width` field。

通常情況下，但並非總是，當我們給一個 method 與 field 相同的名稱時，我們希望它只回傳 field 的值而不做其他事。這樣的 methods 稱為 _getters_，Rust 不像其他一些語言那樣會自動為 struct field 實作它們。Getters 很有用，因為你可以讓 field 成為私有的，但 method 是公開的，從而作為型別公開 API 的一部分，允許對該 field 進行唯讀存取。我們將在第 7 章討論 public 和 private 是什麼，以及如何將 field 或 method 指定為 public 或 private。

> ### -> 運算子在哪裡？
>
> 在 C 和 C++ 中，呼叫 method 使用兩種不同的運算子：如果你是直接在物件上呼叫 method，你會使用 `.`；如果你是在指向物件的指標上呼叫 method，並且需要先解引用指標，你會使用 `->`。換句話說，如果 `object` 是一個指標，`object->something()` 就類似於 `(*object).something()`。
>
> Rust 沒有與 `->` 運算子等效的東西；相反地，Rust 有一個稱為 _自動參照與解參照_（automatic referencing and dereferencing）的特性。呼叫 method 是 Rust 中少數有這種行為的地方之一。
>
> 它的運作方式如下：當你用 `object.something()` 呼叫一個 method 時，Rust 會自動加上 `&`、`&mut` 或 `*`，以便 `object` 符合 method 的簽名。換句話說，以下兩者是相同的：
>
> <!-- CAN'T EXTRACT SEE BUG https://github.com/rust-lang/mdBook/issues/1127 -->
>
> ```rust
> # #[derive(Debug,Copy,Clone)]
> # struct Point {
> #     x: f64,
> #     y: f64,
> # }
> #
> # impl Point {
> #    fn distance(&self, other: &Point) -> f64 {
> #        let x_squared = f64::powi(other.x - self.x, 2);
> #        let y_squared = f64::powi(other.y - self.y, 2);
> #
> #        f64::sqrt(x_squared + y_squared)
> #    }
> # }
> # let p1 = Point { x: 0.0, y: 0.0 };
> # let p2 = Point { x: 5.0, y: 6.5 };
> p1.distance(&p2);
> (&p1).distance(&p2);
> ```
>
> 第一種看起來乾淨多了。這種自動參照的行為之所以可行，是因為 method 有一個明確的接收者——`self` 的型別。給定接收者和 method 的名稱，Rust 可以明確地判斷出 method 是在讀取（`&self`）、改變（`&mut self`）還是消耗（`self`）。Rust 為 method 接收者隱性地進行借用，是讓 ownership 在實踐中符合人體工學的一大部分。

### 有更多參數的 Method

讓我們透過在 `Rectangle` struct 上實作第二個 method 來練習使用 method。這次我們希望一個 `Rectangle` 的 instance 能接收另一個 `Rectangle` 的 instance，如果第二個 `Rectangle` 能完全放入 `self`（第一個 `Rectangle`）內，則回傳 `true`；否則，回傳 `false`。也就是說，一旦我們定義了 `can_hold` method，我們希望能夠寫出如列表 5-14 所示的程式。

src/main.rs

```rust
fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };
    let rect2 = Rectangle {
        width: 10,
        height: 40,
    };
    let rect3 = Rectangle {
        width: 60,
        height: 45,
    };

    println!("Can rect1 hold rect2? {}", rect1.can_hold(&rect2));
    println!("Can rect1 hold rect3? {}", rect1.can_hold(&rect3));
}
```

列表 5-14：使用尚未寫好的 `can_hold` method

預期的輸出會像下面這樣，因為 `rect2` 的兩個維度都小於 `rect1` 的維度，但 `rect3` 比 `rect1` 寬：

```
Can rect1 hold rect2? true
Can rect1 hold rect3? false
```

我們知道我們要定義一個 method，所以它會放在 `impl Rectangle` 區塊內。method 的名稱將是 `can_hold`，它會接受另一個 `Rectangle` 的不可變借用作為參數。我們可以透過查看呼叫 method 的程式碼來判斷參數的型別：`rect1.can_hold(&rect2)` 傳入了 `&rect2`，這是一個對 `rect2`（一個 `Rectangle` 的 instance）的不可變借用。這很合理，因為我們只需要讀取 `rect2`（而不是寫入，那樣就需要一個可變借用），並且我們希望 `main` 保留 `rect2` 的 ownership，這樣我們在呼叫 `can_hold` method 後還可以再次使用它。`can_hold` 的回傳值將是一個布林值，而實作將會檢查 `self` 的寬度和高度是否分別大於另一個 `Rectangle` 的寬度和高度。讓我們將新的 `can_hold` method 加到列表 5-13 的 `impl` 區塊中，如列表 5-15 所示。

src/main.rs

```rust
impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }

    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}
```

列表 5-15：在 `Rectangle` 上實作 `can_hold` method，它接受另一個 `Rectangle` instance 作為參數

當我們用列表 5-14 中的 `main` 函式執行這段程式碼時，我們將得到我們想要的輸出。Methods 可以在 `self` 參數後加上多個參數，這些參數的運作方式與函式中的參數完全相同。

### 關聯函式

在 `impl` 區塊內定義的所有函式都稱為 _關聯函式_（associated functions），因為它們與 `impl` 後面命名的型別相關聯。我們可以定義沒有 `self` 作為第一個參數的關聯函式（因此它們不是 method），因為它們不需要一個型別的 instance 來運作。我們已經使用過一個這樣的函式：定義在 `String` 型別上的 `String::from` 函式。

不是 method 的關聯函式通常用作建構子，會回傳一個 struct 的新 instance。這些通常被稱為 `new`，但 `new` 並不是一個特殊的名稱，也不是內建於語言中的。例如，我們可以選擇提供一個名為 `square` 的關聯函式，它有一個維度參數，並將其用作寬度和高度，這樣建立一個正方形 `Rectangle` 就更容易了，而不必指定兩次相同的值：

檔案名稱：src/main.rs

```rust
impl Rectangle {
    fn square(size: u32) -> Self {
        Self {
            width: size,
            height: size,
        }
    }
}
```

在回傳型別和函式主體中的 `Self` 關鍵字是 `impl` 關鍵字後出現的型別的別名，在這裡就是 `Rectangle`。

要呼叫這個關聯函式，我們使用 `::` 語法和 struct 名稱；例如 `let sq = Rectangle::square(3);`。這個函式被 struct 所命名空間化：`::` 語法既用於關聯函式，也用於由模組建立的命名空間。我們將在第 7 章討論模組。

### 多個 `impl` 區塊

每個 struct 都允許有多個 `impl` 區塊。例如，列表 5-15 等同於列表 5-16 所示的程式碼，其中每個 method 都在自己的 `impl` 區塊中。

```rust
impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

impl Rectangle {
    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}
```

列表 5-16：使用多個 `impl` 區塊重寫列表 5-15

在這裡沒有理由將這些 methods 分成多個 `impl` 區塊，但這是有效的語法。我們將在第 10 章看到一個多個 `impl` 區塊有用的案例，屆時我們將討論泛型型別和 trait。

## 總結

Struct 讓你可以建立對你的領域有意義的自訂型別。透過使用 struct，你可以將相關的資料片段連結在一起，並為每個片段命名，使你的程式碼清晰。在 `impl` 區塊中，你可以定義與你的型別相關聯的函式，而 methods 是一種關聯函式，讓你指定你的 struct instance 所擁有的行為。

但 struct 並不是你建立自訂型別的唯一方法：讓我們轉向 Rust 的 enum 特性，為你的工具箱再添一樣工具。
