<!-- DO NOT EDIT THIS FILE.

This file is periodically generated from the content in the `/src/`
directory, so all fixes need to be made in `/src/`.
-->

[TOC]

# 更多關於 Cargo 和 Crates.io

目前為止，我們僅使用了 Cargo 最基礎的功能來建置、執行和測試我們的程式碼，但它能做到的遠不止這些。在本章中，我們將討論它的一些其他更進階的功能，向你展示如何做到以下幾點：

- 透過 release profiles 自訂建置
- 將函式庫發布到 crates.io
- 使用 workspaces 組織大型專案
- 從 crates.io 安裝二進位檔
- 使用自訂命令擴展 Cargo

Cargo 能做的比本章涵蓋的功能還要多，若想完整了解其所有功能，請參閱其文件：_https://doc.rust-lang.org/cargo/_.

## 使用 Release Profiles 自訂建置

在 Rust 中，_release profiles_ 是預定義且可自訂的設定檔，包含不同的組態，讓程式設計師能更精確地控制編譯程式碼的各種選項。每個 profile 都是獨立配置的。

Cargo 有兩個主要的 profile：當你執行 `cargo build` 時 Cargo 使用的 `dev` profile，以及當你執行 `cargo build --release` 時 Cargo 使用的 `release` profile。`dev` profile 定義了有利於開發的預設值，而 `release` profile 則定義了有利於發布建置的預設值。

這些 profile 名稱你可能從建置輸出中就已經很熟悉了：

<!-- manual-regeneration
anywhere, run:
cargo build
cargo build --release
and ensure output below is accurate
-->

```text
$ cargo build
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.00s
$ cargo build --release
    Finished `release` profile [optimized] target(s) in 0.32s
```

其中的 `dev` 和 `release` 就是編譯器使用的不同 profile。

當你沒有在專案的 _Cargo.toml_ 檔案中明確加入任何 `[profile.*]` 區塊時，Cargo 對於每個 profile 都有預設設定。透過為任何你想自訂的 profile 加入 `[profile.*]` 區塊，你就能覆寫預設設定的任何子集。例如，以下是 `dev` 和 `release` profile 的 `opt-level` 設定的預設值：

Filename: Cargo.toml

```toml
[profile.dev]
opt-level = 0

[profile.release]
opt-level = 3
```

`opt-level` 設定控制 Rust 將對你的程式碼套用的優化等級，範圍從 0 到 3。套用更多優化會延長編譯時間，因此如果你正在開發並經常編譯程式碼，你會希望減少優化以加快編譯速度，即使結果程式碼執行速度較慢。所以 `dev` 的預設 `opt-level` 是 `0`。當你準備好發布程式碼時，最好花更多時間編譯。你只會在 release mode 下編譯一次，但你會多次執行編譯後的程式，因此 release mode 犧牲了較長的編譯時間以換取更快的程式碼執行速度。這就是為什麼 `release` profile 的預設 `opt-level` 是 `3`。

你可以透過在 _Cargo.toml_ 中為其加入不同的值來覆寫預設設定。例如，如果我們想在開發 profile 中使用優化等級 1，我們可以在專案的 _Cargo.toml_ 檔案中加入這兩行：

Filename: Cargo.toml

```toml
[profile.dev]
opt-level = 1
```

這段程式碼會覆寫預設設定 `0`。現在當我們執行 `cargo build` 時，Cargo 將使用 `dev` profile 的預設值加上我們對 `opt-level` 的自訂。因為我們將 `opt-level` 設定為 `1`，Cargo 將套用比預設更多的優化，但不會像 release build 那麼多。

有關每個 profile 的完整組態選項和預設值列表，請參閱 Cargo 的文件：_https://doc.rust-lang.org/cargo/reference/profiles.html_。

## 將 Crate 發布到 Crates.io

我們已將來自 crates.io 的套件作為專案的依賴項來使用，但你也可以透過發布自己的套件來與其他人分享你的程式碼。crates.io 上的 crate registry 會發布你的套件的原始碼，因此它主要託管開源程式碼。

Rust 和 Cargo 具有一些功能，能讓你的已發布套件更容易被他人找到和使用。接下來我們將討論其中一些功能，然後解釋如何發布套件。

### 撰寫有用的文件註解

準確地為你的套件撰寫文件將幫助其他使用者了解如何以及何時使用它們，因此投入時間撰寫文件是值得的。在第三章中，我們討論了如何使用兩個斜線 `//` 來註解 Rust 程式碼。Rust 還有一種特殊的文件註解，方便地稱為 _documentation comment_ (文件註解)，它會生成 HTML 文件。HTML 會顯示用於公開 API 項目的文件註解內容，這些註解旨在供對如何*使用*你的 crate 感興趣的程式設計師閱讀，而非你的 crate 的_實作方式_。

文件註解使用三個斜線 `///` 而不是兩個，並支援 Markdown 標記來格式化文字。將文件註解放置在它們要記錄的項目之前。清單 14-1 顯示了名為 `my_crate` 的 crate 中 `add_one` 函式的文件註解。

src/lib.rs

````rust
/// Adds one to the number given.
///
/// # Examples
///
/// ```
/// let arg = 5;
/// let answer = my_crate::add_one(arg);
///
/// assert_eq!(6, answer);
/// ```
pub fn add_one(x: i32) -> i32 {
    x + 1
}
````

清單 14-1：函式的文件註解

在這裡，我們描述了 `add_one` 函式的功能，以標題 `Examples` 開始一個區塊，然後提供範例程式碼來展示如何使用 `add_one` 函式。我們可以透過執行 `cargo doc` 從這個文件註解生成 HTML 文件。此命令會執行 Rust 附帶的 `rustdoc` 工具，並將生成的 HTML 文件放在 _target/doc_ 目錄中。

為方便起見，執行 `cargo doc --open` 將會為你當前 crate 的文件（以及你所有 crate 依賴項的文件）建置 HTML，並在網頁瀏覽器中打開結果。導覽到 `add_one` 函式，你將會看到文件註解中的文字是如何呈現的，如圖 14-1 所示。

![my_crate 中 `add_one` 函式的 HTML 文件渲染圖](https://doc.rust-lang.org/book/img/trpl14-01.png)

圖 14-1：`add_one` 函式的 HTML 文件

#### 常用區塊

我們在清單 14-1 中使用了 `# Examples` Markdown 標題，在 HTML 中創建了一個標題為「Examples」的區塊。以下是 crate 作者在其文件中常用的一些其他區塊：

- **Panics** (恐慌)：被記錄的函式可能發生 panic 的場景。不希望其程式 panic 的函式呼叫者應確保在這些情況下不要呼叫該函式。
- **Errors** (錯誤)：如果函式返回 `Result`，描述可能發生的錯誤類型以及哪些條件可能導致這些錯誤被返回，這對呼叫者來說會很有幫助，他們可以編寫程式碼以不同方式處理不同類型的錯誤。
- **Safety** (安全性)：如果函式呼叫是 `unsafe` 的（我們在第二十章討論 unsafety），則應有一個區塊解釋為什麼該函式是 unsafe 的，並涵蓋函式期望呼叫者遵守的不變性。

大多數文件註解不需要所有這些區塊，但這是一個很好的清單，可以提醒你使用者會感興趣的程式碼方面。

#### 將文件註解作為測試

在你的文件註解中加入範例程式碼區塊可以幫助展示如何使用你的函式庫，這樣做還有一個額外的好處：執行 `cargo test` 將會把你的文件中的程式碼範例作為測試來執行！沒有什麼比帶有範例的文件更好了。但也沒有什麼比由於程式碼自文件撰寫以來已更改而導致範例無法運作更糟糕了。如果我們針對清單 14-1 中的 `add_one` 函式的文件執行 `cargo test`，我們將會在測試結果中看到類似以下的區塊：

<!-- manual-regeneration
cd listings/ch14-more-about-cargo/listing-14-01/
cargo test
copy just the doc-tests section below
-->

```text
   Doc-tests my_crate

running 1 test
test src/lib.rs - add_one (line 5) ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.27s
```

現在，如果我們更改函式或範例，使得範例中的 `assert_eq!` 發生 panic，並再次執行 `cargo test`，我們將會看到 doc tests 發現範例與程式碼不同步！

#### 註解包含的項目

文件註解 `//!` 的風格是為*包含*這些註解的項目添加文件，而不是為*跟隨*這些註解的項目添加。我們通常在 crate 的根檔案（依慣例是 _src/lib.rs_）或模組內部使用這些文件註解，以記錄整個 crate 或模組。

例如，要添加描述包含 `add_one` 函式的 `my_crate` crate 目的的文件，我們將以 `//!` 開頭的文件註解添加到 _src/lib.rs_ 檔案的開頭，如清單 14-2 所示。

src/lib.rs

```rust
//! # My Crate
//!
//! `my_crate` is a collection of utilities to make performing certain
//! calculations more convenient.

/// Adds one to the number given.
// --snip--
```

清單 14-2：整個 `my_crate` crate 的文件

請注意，以 `//!` 開頭的最後一行之後沒有任何程式碼。因為我們用 `//!` 而非 `///` 開啟註解，我們是在為包含此註解的項目撰寫文件，而不是為此註解之後的項目。在本例中，該項目是 _src/lib.rs_ 檔案，即 crate 根目錄。這些註解描述了整個 crate。

當我們執行 `cargo doc --open` 時，這些註解將會顯示在 `my_crate` 文件的首頁上，位於 crate 中公開項目列表的上方，如圖 14-2 所示。

![呈現包含整個 crate 註解的 HTML 文件](https://doc.rust-lang.org/book/img/trpl14-02.png)

圖 14-2：`my_crate` 的文件渲染圖，包含描述整個 crate 的註解

項目內的文件註解對於描述 crate 和 module 特別有用。使用它們來解釋容器的整體目的，以幫助你的使用者理解 crate 的組織結構。

### 使用 pub use 匯出方便的 Public API

發布 crate 時，public API 的結構是一個主要考量。使用你的 crate 的人比你更不熟悉其結構，如果你的 crate 有一個龐大的模組層級，他們可能會難以找到他們想使用的部分。

在第七章中，我們討論了如何使用 `pub` 關鍵字使項目公開，以及如何使用 `use` 關鍵字將項目引入作用域。然而，你在開發 crate 時覺得合理的結構，對於你的使用者來說可能不太方便。你可能希望將你的 struct 組織成一個包含多個層級的層次結構，但這樣一來，那些想使用你定義在層次結構深處的類型的使用者可能會難以發現該類型的存在。他們也可能會因為必須輸入 `use my_crate::some_module::another_module::UsefulType;` 而非 `use my_crate::UsefulType;` 而感到惱火。

好消息是，如果結構對其他函式庫的使用者來說*不*方便，你不必重新安排你的內部組織：相反地，你可以使用 `pub use` 來 re-export 項目，以建立一個與你的私有結構不同的公開結構。_Re-exporting_ (重新匯出) 是將一個公開項目從一個位置取出，並使其在另一個位置也公開，就像它是在那個新位置定義的一樣。

例如，假設我們建立了一個名為 `art` 的函式庫，用於建模藝術概念。這個函式庫內有兩個模組：一個包含兩個 enum `PrimaryColor` 和 `SecondaryColor` 的 `kinds` 模組，以及一個包含名為 `mix` 的函式的 `utils` 模組，如清單 14-3 所示。

src/lib.rs

```rust
//! # Art
//!
//! A library for modeling artistic concepts.

pub mod kinds {
    /// The primary colors according to the RYB color model.
    pub enum PrimaryColor {
        Red,
        Yellow,
        Blue,
    }

    /// The secondary colors according to the RYB color model.
    pub enum SecondaryColor {
        Orange,
        Green,
        Purple,
    }
}

pub mod utils {
    use crate::kinds::*;

    /// Combines two primary colors in equal amounts to create
    /// a secondary color.
    pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -> SecondaryColor {
        // --snip--
    }
}
```

清單 14-3：一個將項目組織到 `kinds` 和 `utils` 模組中的 `art` 函式庫

圖 14-3 顯示了由 `cargo doc` 生成的這個 crate 的文件首頁會是什麼樣子。

![`art` crate 文件渲染圖，其中列出了 `kinds` 和 `utils` 模組](https://doc.rust-lang.org/book/img/trpl14-03.png)

圖 14-3：`art` 文件首頁，其中列出了 `kinds` 和 `utils` 模組

請注意，`PrimaryColor` 和 `SecondaryColor` 類型都沒有列在首頁上，`mix` 函式也沒有。我們必須點擊 `kinds` 和 `utils` 才能看到它們。

另一個依賴此函式庫的 crate 將需要 `use` 語句來將 `art` 中的項目引入作用域，並指定當前定義的模組結構。清單 14-4 顯示了一個使用 `art` crate 中 `PrimaryColor` 和 `mix` 項目的 crate 範例。

src/main.rs

```rust
use art::kinds::PrimaryColor;
use art::utils::mix;

fn main() {
    let red = PrimaryColor::Red;
    let yellow = PrimaryColor::Yellow;
    mix(red, yellow);
}
```

清單 14-4：一個使用 `art` crate 項目並匯出其內部結構的 crate

清單 14-4 中使用 `art` crate 的程式碼作者必須找出 `PrimaryColor` 位於 `kinds` 模組中，而 `mix` 位於 `utils` 模組中。`art` crate 的模組結構對於開發 `art` crate 的開發者來說更為相關，而不是對於使用者。內部結構對於嘗試理解如何使用 `art` crate 的人來說不包含任何有用資訊，反而造成困惑，因為使用者必須找出要查看的位置，並且必須在 `use` 語句中指定模組名稱。

為了從 public API 中移除內部組織，我們可以修改清單 14-3 中的 `art` crate 程式碼，加入 `pub use` 語句來在頂層 re-export 這些項目，如清單 14-5 所示。

src/lib.rs

```rust
//! # Art
//!
//! A library for modeling artistic concepts.

pub use self::kinds::PrimaryColor;
pub use self::kinds::SecondaryColor;
pub use self::utils::mix;

pub mod kinds {
    // --snip--
}

pub mod utils {
    // --snip--
}
```

清單 14-5：添加 `pub use` 語句來 re-export 項目

現在，`cargo doc` 為此 crate 生成的 API 文件將會在首頁上列出並連結 re-export 的項目，如圖 14-4 所示，這使得 `PrimaryColor` 和 `SecondaryColor` 類型以及 `mix` 函式更容易找到。

![`art` crate 文件渲染圖，其中首頁上列出了 re-exports](https://doc.rust-lang.org/book/img/trpl14-04.png)

圖 14-4：`art` 文件首頁，其中列出了 re-exports

`art` crate 的使用者仍然可以看到並使用清單 14-3 中的內部結構，如清單 14-4 所示，或者他們可以使用清單 14-5 中更方便的結構，如清單 14-6 所示。

src/main.rs

```rust
use art::PrimaryColor;
use art::mix;

fn main() {
    // --snip--
}
```

清單 14-6：一個使用 `art` crate 中 re-export 項目的程式

在許多巢狀模組的情況下，使用 `pub use` 在頂層 re-export 類型可以顯著改善 crate 使用者的體驗。`pub use` 的另一個常見用途是在當前 crate 中 re-export 依賴項的定義，使其成為你的 crate 的 public API 的一部分。

建立一個有用的 public API 結構更像是一門藝術而非科學，你可以迭代以找到最適合你使用者的 API。選擇 `pub use` 賦予你靈活性，可以自行決定如何組織你的 crate 內部結構，並將該內部結構與你呈現給使用者的內容解耦。看看你安裝的一些 crate 的程式碼，了解它們的內部結構是否與其 public API 不同。

### 設定 Crates.io 帳號

在你發布任何 crate 之前，你需要在 crates.io 上建立一個帳號並取得一個 API token。為此，請造訪 crates.io 首頁並透過 GitHub 帳號登入。（目前 GitHub 帳號是必需的，但該網站未來可能會支援其他建立帳號的方式。）登入後，請造訪你的帳號設定：https://crates.io/me/ 並取得你的 API key。然後執行 `cargo login` 命令，並在提示時貼上你的 API key，如下所示：

```text
$ cargo login
abcdefghijklmnopqrstuvwxyz012345
```

此命令將告知 Cargo 你的 API token 並將其本地儲存在 _~/.cargo/credentials.toml_ 中。請注意，這個 token 是_秘密_：不要與任何人分享。如果出於任何原因你與任何人分享了它，你應該立即撤銷它並在 crates.io 上生成一個新 token。

### 為新 Crate 添加 Metadata

假設你有一個想要發布的 crate。在發布之前，你需要在庫的 _Cargo.toml_ 檔案的 `[package]` 區塊中添加一些 metadata。

你的 crate 需要一個獨特的名稱。當你在本地開發 crate 時，你可以隨心所欲地命名它。然而，crates.io 上的 crate 名稱是按照先到先得的原則分配的。一旦一個 crate 名稱被佔用，其他人就不能再以該名稱發布 crate。在嘗試發布 crate 之前，請搜尋你想要使用的名稱。如果該名稱已被使用，你需要找到另一個名稱並編輯 _Cargo.toml_ 檔案中 `[package]` 區塊下的 `name` 欄位，以使用新名稱進行發布，如下所示：

Filename: Cargo.toml

```toml
[package]
name = "guessing_game"
```

即使你選擇了一個獨特的名稱，當你此時執行 `cargo publish` 來發布 crate 時，你會收到一個警告，然後是一個錯誤：

<!-- manual-regeneration
Create a new package with an unregistered name, making no further modifications
  to the generated package, so it is missing the description and license fields.
cargo publish
copy just the relevant lines below
-->

```text
$ cargo publish
    Updating crates.io index
warning: manifest has no description, license, license-file, documentation, homepage or repository.
See https://doc.rust-lang.org/cargo/reference/manifest.html#package-metadata for more info.
--snip--
error: failed to publish to registry at https://crates.io

Caused by:
  the remote server responded with an error (status 400 Bad Request): missing or empty metadata fields: description, license. Please see https://doc.rust-lang.org/cargo/reference/manifest.html for more information on configuring these fields
```

這會導致錯誤，因為你缺少一些關鍵資訊：需要 description 和 license，以便人們了解你的 crate 的功能以及他們可以使用它的條款。在 _Cargo.toml_ 中，添加一個只有一兩句話的 description，因為它會和你的 crate 一起出現在搜尋結果中。對於 `license` 欄位，你需要提供一個_許可證識別值_。Linux 基金會的軟體套件資料交換 (SPDX) 在 _https://spdx.org/licenses/_ 列出了你可以用於此值的識別碼。例如，要指定你使用 MIT 許可證授權你的 crate，請添加 `MIT` 識別碼：

Filename: Cargo.toml

```toml
[package]
name = "guessing_game"
license = "MIT"
```

如果你想使用一個未出現在 SPDX 中的許可證，你需要將該許可證的文本放在一個檔案中，將該檔案包含在你的專案中，然後使用 `license-file` 來指定該檔案的名稱，而不是使用 `license` 鍵。

關於哪種許可證適合你的專案的指導超出了本書的範圍。許多 Rust 社群的人都像 Rust 一樣，使用 `MIT OR Apache-2.0` 雙重許可證來授權他們的專案。這種做法表明你也可以指定多個以 `OR` 分隔的許可證識別碼，讓你的專案擁有多個許可證。

添加了獨特名稱、版本、描述和許可證後，準備發布的專案的 _Cargo.toml_ 檔案可能看起來像這樣：

Filename: Cargo.toml

```toml
[package]
name = "guessing_game"
version = "0.1.0"
edition = "2024"
description = "A fun game where you guess what number the computer has chosen."
license = "MIT OR Apache-2.0"

[dependencies]
```

Cargo 的文件：_https://doc.rust-lang.org/cargo/_ 描述了你可以指定的其他 metadata，以確保其他人更容易發現和使用你的 crate。

### 發布到 Crates.io

現在你已經建立帳號、儲存了你的 API token、為你的 crate 選擇了名稱，並指定了必要的 metadata，你已經準備好發布了！發布一個 crate 會將特定版本上傳到 crates.io 供其他人使用。

請小心，因為發布是*永久性*的。版本永遠不能被覆寫，除了某些特定情況外，程式碼也不能被刪除。Crates.io 的一個主要目標是作為程式碼的永久檔案，這樣所有依賴 crates.io 上 crate 的專案建置都能持續運作。允許刪除版本將使實現此目標變得不可能。然而，你可以發布的 crate 版本數量沒有限制。

再次執行 `cargo publish` 命令。現在應該會成功：

<!-- manual-regeneration
go to some valid crate, publish a new version
cargo publish
copy just the relevant lines below
-->

```text
$ cargo publish
    Updating crates.io index
   Packaging guessing_game v0.1.0 (file:///projects/guessing_game)
    Packaged 6 files, 1.2KiB (895.0B compressed)
   Verifying guessing_game v0.1.0 (file:///projects/guessing_game)
   Compiling guessing_game v0.1.0
(file:///projects/guessing_game/target/package/guessing_game-0.1.0)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.19s
   Uploading guessing_game v0.1.0 (file:///projects/guessing_game)
    Uploaded guessing_game v0.1.0 to registry `crates-io`
note: waiting for `guessing_game v0.1.0` to be available at registry
`crates-io`.
You may press ctrl-c to skip waiting; the crate should be available shortly.
   Published guessing_game v0.1.0 at registry `crates-io`
```

恭喜你！你現在已經與 Rust 社群分享了你的程式碼，任何人都可以輕鬆地將你的 crate 添加為其專案的 dependency。

### 發布現有 Crate 的新版本

當你對你的 crate 進行了更改並準備發布新版本時，請更改你的 _Cargo.toml_ 檔案中指定的 `version` 值並重新發布。使用 _https://semver.org/_ 上的 Semantic Versioning 規則，根據你所做的更改類型來決定下一個適當的版本號。然後執行 `cargo publish` 以上傳新版本。

<!-- Old link, do not remove -->

<a id="removing-versions-from-cratesio-with-cargo-yank"></a>

### 使用 cargo yank 從 Crates.io 棄用版本

雖然你無法移除 crate 的舊版本，但你可以阻止未來任何專案將其添加為新的 dependency。當某個 crate 版本因某種原因損壞時，這就很有用。在這種情況下，Cargo 支援 yank 一個 crate 版本。

_Yanking_ 一個版本會阻止新專案依賴該版本，同時允許所有現有依賴該版本的專案繼續運作。本質上，yank 意味著所有帶有 _Cargo.lock_ 的專案不會損壞，並且任何未來生成的 _Cargo.lock_ 檔案都不會使用被 yank 的版本。

要 yank 某個 crate 的版本，在你先前發布的 crate 目錄中，執行 `cargo yank` 並指定你想要 yank 的版本。例如，如果我們已經發布了一個名為 `guessing_game` 的 crate 版本 1.0.1，並且我們想要 yank 它，在 `guessing_game` 的專案目錄中，我們將執行：

<!-- manual-regeneration:
cargo yank carol-test --version 2.1.0
cargo yank carol-test --version 2.1.0 --undo
-->

```text
$ cargo yank --vers 1.0.1
    Updating crates.io index
        Yank guessing_game@1.0.1
```

透過在命令中添加 `--undo`，你也可以撤銷 yank，並允許專案再次開始依賴該版本：

```text
$ cargo yank --vers 1.0.1 --undo
    Updating crates.io index
      Unyank guessing_game@1.0.1
```

yank *不會*刪除任何程式碼。例如，它無法刪除意外上傳的秘密。如果發生這種情況，你必須立即重設這些秘密。

## Cargo Workspaces

在第十二章中，我們建置了一個包含 binary crate 和 library crate 的 package。隨著你的專案發展，你可能會發現 library crate 持續變大，並且你希望將你的 package 進一步拆分為多個 library crate。Cargo 提供了一個稱為 _workspaces_ 的功能，可以幫助管理多個同步開發的相關 package。

### 建立 Workspace

_workspace_ 是一組共享相同 _Cargo.lock_ 和輸出目錄的 package。讓我們使用 workspace 來建立一個專案——我們將使用簡單的程式碼，以便專注於 workspace 的結構。建構 workspace 有多種方法，我們只展示一種常見的方式。我們將有一個包含一個 binary 和兩個 library 的 workspace。這個 binary 將提供主要功能，並依賴於這兩個 library。一個 library 將提供 `add_one` 函式，另一個 library 將提供 `add_two` 函式。這三個 crate 將是同一個 workspace 的一部分。我們將從為 workspace 建立一個新目錄開始：

```text
$ mkdir add
$ cd add
```

接下來，在 _add_ 目錄中，我們建立 _Cargo.toml_ 檔案，它將配置整個 workspace。這個檔案不會有 `[package]` 區塊。相反地，它會以一個 `[workspace]` 區塊開始，允許我們將成員加入 workspace。我們也特別指定在我們的 workspace 中使用 Cargo 最新且最棒的 resolver 演算法，將 `resolver` 值設定為 `"3"`。

Filename: Cargo.toml

```toml
[workspace]
resolver = "3"
```

接著，我們將在 _add_ 目錄中執行 `cargo new` 來建立 `adder` binary crate：

<!-- manual-regeneration
cd listings/ch14-more-about-cargo/output-only-01-adder-crate/add
remove `members = ["adder"]` from Cargo.toml
rm -rf adder
cargo new adder
copy output below
-->

```text
$ cargo new adder
     Created binary (application) `adder` package
      Adding `adder` as member of workspace at `file:///projects/add`
```

在 workspace 內部執行 `cargo new` 也會自動將新建立的 package 加入 workspace _Cargo.toml_ 中 `[workspace]` 定義的 `members` 鍵，像這樣：

```toml
[workspace]
resolver = "3"
members = ["adder"]
```

此時，我們可以透過執行 `cargo build` 來建置 workspace。你的 _add_ 目錄中的檔案應該像這樣：

```
├── Cargo.lock
├── Cargo.toml
├── adder
│   ├── Cargo.toml
│   └── src
│       └── main.rs
└── target
```

workspace 在頂層只有一個 _target_ 目錄，編譯後的 artifacts 將會放置於此；`adder` package 沒有自己的 _target_ 目錄。即使我們從 _adder_ 目錄內部執行 `cargo build`，編譯後的 artifacts 仍然會落在 _add/target_ 而不是 _add/adder/target_。Cargo 這樣組織 workspace 中的 _target_ 目錄是因為 workspace 中的 crates 旨在相互依賴。如果每個 crate 都有自己的 _target_ 目錄，那麼每個 crate 都必須重新編譯 workspace 中的其他每個 crate，才能將 artifacts 放置到自己的 _target_ 目錄中。透過共享一個 _target_ 目錄，這些 crates 可以避免不必要的重複建置。

### 在 Workspace 中建立第二個 Package

接下來，讓我們在 workspace 中建立另一個成員 package，並將其命名為 `add_one`。生成一個名為 `add_one` 的新 library crate：

<!-- manual-regeneration
cd listings/ch14-more-about-cargo/output-only-02-add-one/add
remove `"add_one"` from `members` list in Cargo.toml
rm -rf add_one
cargo new add_one --lib
copy output below
-->

```text
$ cargo new add_one --lib
     Created library `add_one` package
      Adding `add_one` as member of workspace at `file:///projects/add`
```

現在，頂層的 _Cargo.toml_ 將會在 `members` 列表中包含 _add_one_ 路徑：

Filename: Cargo.toml

```toml
[workspace]
resolver = "3"
members = ["adder", "add_one"]
```

你的 _add_ 目錄現在應該有這些目錄和檔案：

```
├── Cargo.lock
├── Cargo.toml
├── add_one
│   ├── Cargo.toml
│   └── src
│       └── lib.rs
├── adder
│   ├── Cargo.toml
│   └── src
│       └── main.rs
└── target
```

在 _add_one/src/lib.rs_ 檔案中，讓我們添加一個 `add_one` 函式：

Filename: add_one/src/lib.rs

```rust
pub fn add_one(x: i32) -> i32 {
    x + 1
}
```

現在我們可以讓帶有我們 binary 的 `adder` package 依賴於帶有我們 library 的 `add_one` package。首先，我們需要在 _adder/Cargo.toml_ 中添加一個對 `add_one` 的 path dependency。

Filename: adder/Cargo.toml

```toml
[dependencies]
add_one = { path = "../add_one" }
```

Cargo 不會假設 workspace 中的 crates 會相互依賴，因此我們需要明確說明依賴關係。

接下來，讓我們在 `adder` crate 中使用 `add_one` 函式（來自 `add_one` crate）。打開 _adder/src/main.rs_ 檔案並更改 `main` 函式以呼叫 `add_one` 函式，如清單 14-7 所示。

adder/src/main.rs

```rust
fn main() {
    let num = 10;
    println!("Hello, world! {num} plus one is {}!", add_one::add_one(num));
}
```

清單 14-7：從 `adder` crate 使用 `add_one` library crate

讓我們在頂層的 _add_ 目錄中執行 `cargo build` 來建置 workspace！

<!-- manual-regeneration
cd listings/ch14-more-about-cargo/listing-14-07/add
cargo build
copy output below; the output updating script doesn't handle subdirectories in paths properly
-->

```text
$ cargo build
   Compiling add_one v0.1.0 (file:///projects/add/add_one)
   Compiling adder v0.1.0 (file:///projects/add/adder)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.22s
```

要從 _add_ 目錄執行 binary crate，我們可以使用 `-p` 參數和 package 名稱與 `cargo run` 來指定我們要執行 workspace 中的哪個 package：

<!-- manual-regeneration
cd listings/ch14-more-about-cargo/listing-14-07/add
cargo run -p adder
copy output below; the output updating script doesn't handle subdirectories in paths properly
-->

```text
$ cargo run -p adder
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.00s
     Running `target/debug/adder`
Hello, world! 10 plus one is 11!
```

這會執行 _adder/src/main.rs_ 中的程式碼，它依賴於 `add_one` crate。

#### Workspace 中依賴外部 Package

請注意，workspace 在頂層只有一個 _Cargo.lock_ 檔案，而不是每個 crate 目錄都有一個 _Cargo.lock_。這確保了所有 crate 都使用所有 dependencies 的相同版本。如果我們將 `rand` package 添加到 _adder/Cargo.toml_ 和 _add_one/Cargo.toml_ 檔案中，Cargo 將把這兩者解析為 `rand` 的一個版本，並將其記錄在唯一的 _Cargo.lock_ 中。讓 workspace 中的所有 crate 使用相同的 dependencies 意味著這些 crate 將始終相互兼容。讓我們將 `rand` crate 添加到 _add_one/Cargo.toml_ 檔案的 `[dependencies]` 區塊中，這樣我們就可以在 `add_one` crate 中使用 `rand` crate：

<!-- When updating the version of `rand` used, also update the version of
`rand` used in these files so they all match:
* ch02-00-guessing-game-tutorial.md
* ch07-04-bringing-paths-into-scope-with-the-use-keyword.md
-->

Filename: add_one/Cargo.toml

```toml
[dependencies]
rand = "0.8.5"
```

我們現在可以將 `use rand;` 添加到 _add_one/src/lib.rs_ 檔案中，並透過在 _add_ 目錄中執行 `cargo build` 來建置整個 workspace，這將會引入並編譯 `rand` crate。我們將會收到一個警告，因為我們沒有引用我們引入作用域的 `rand`：

<!-- manual-regeneration
cd listings/ch14-more-about-cargo/no-listing-03-workspace-with-external-dependency/add
cargo build
copy output below; the output updating script doesn't handle subdirectories in paths properly
-->

```text
$ cargo build
    Updating crates.io index
  Downloaded rand v0.8.5
   --snip--
   Compiling rand v0.8.5
   Compiling add_one v0.1.0 (file:///projects/add/add_one)
warning: unused import: `rand`
 --> add_one/src/lib.rs:1:5
  |
1 | use rand;
  |     ^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: `add_one` (lib) generated 1 warning (run `cargo fix --lib -p add_one` to apply 1 suggestion)
   Compiling adder v0.1.0 (file:///projects/add/adder)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.95s
```

頂層的 _Cargo.lock_ 現在包含 `add_one` 對 `rand` 的 dependency 資訊。然而，即使 `rand` 在 workspace 的某處被使用，我們也無法在 workspace 中的其他 crate 中使用它，除非我們也將 `rand` 添加到它們的 _Cargo.toml_ 檔案中。例如，如果我們將 `use rand;` 添加到 `adder` package 的 _adder/src/main.rs_ 檔案中，我們將會得到一個錯誤：

<!-- manual-regeneration
cd listings/ch14-more-about-cargo/output-only-03-use-rand/add
cargo build
copy output below; the output updating script doesn't handle subdirectories in paths properly
-->

```text
$ cargo build
  --snip--
   Compiling adder v0.1.0 (file:///projects/add/adder)
error[E0432]: unresolved import `rand`
 --> adder/src/main.rs:2:5
  |
2 | use rand;
  |     ^^^^ no external crate `rand`
```

要解決此問題，請編輯 `adder` package 的 _Cargo.toml_ 檔案，並指出 `rand` 也是它的 dependency。建置 `adder` package 會將 `rand` 添加到 _Cargo.lock_ 中 `adder` 的 dependencies 列表中，但不會下載額外的 `rand` 副本。只要它們指定兼容的 `rand` 版本，Cargo 將確保 workspace 中每個 package 中的每個 crate 都會使用相同版本的 `rand` package，從而節省空間並確保 workspace 中的 crate 相互兼容。

如果 workspace 中的 crate 指定了相同 dependency 的不兼容版本，Cargo 將會解析它們每一個，但仍會盡量解析最少數量的版本。

#### 為 Workspace 添加測試

為了進一步改進，讓我們在 `add_one` crate 中添加一個針對 `add_one::add_one` 函式的測試：

Filename: add_one/src/lib.rs

```rust
pub fn add_one(x: i32) -> i32 {
    x + 1
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        assert_eq!(3, add_one(2));
    }
}
```

現在在頂層的 _add_ 目錄中執行 `cargo test`。在像這樣結構化的 workspace 中執行 `cargo test` 將會執行 workspace 中所有 crate 的測試：

<!-- manual-regeneration
cd listings/ch14-more-about-cargo/no-listing-04-workspace-with-tests/add
cargo test
copy output below; the output updating script doesn't handle subdirectories in
paths properly
-->

```text
$ cargo test
   Compiling add_one v0.1.0 (file:///projects/add/add_one)
   Compiling adder v0.1.0 (file:///projects/add/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.20s
     Running unittests src/lib.rs (target/debug/deps/add_one-93c49ee75dc46543)

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests src/main.rs (target/debug/deps/adder-3a47283c568d2b6a)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests add_one

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
```

輸出的第一個部分顯示 `add_one` crate 中的 `it_works` 測試通過了。接下來的部分顯示在 `adder` crate 中沒有找到任何測試，然後最後的部分顯示在 `add_one` crate 中沒有找到任何文件測試。

我們也可以從頂層目錄執行 workspace 中特定 crate 的測試，方法是使用 `-p` 旗標並指定我們想要測試的 crate 名稱：

<!-- manual-regeneration
cd listings/ch14-more-about-cargo/no-listing-04-workspace-with-tests/add
cargo test -p add_one
copy output below; the output updating script doesn't handle subdirectories in paths properly
-->

```text
$ cargo test -p add_one
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.00s
     Running unittests src/lib.rs (target/debug/deps/add_one-93c49ee75dc46543)

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests add_one

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
```

此輸出顯示 `cargo test` 只執行了 `add_one` crate 的測試，而沒有執行 `adder` crate 的測試。

如果你將 workspace 中的 crate 發布到 crates.io，workspace 中的每個 crate 都需要單獨發布。與 `cargo test` 類似，我們可以透過使用 `-p` 旗標並指定我們想要發布的 crate 名稱來發布我們 workspace 中的特定 crate。

為了額外的練習，以類似 `add_one` crate 的方式，將一個 `add_two` crate 添加到這個 workspace！

隨著你的專案成長，請考慮使用 workspace：它使你能夠使用更小、更容易理解的組件，而不是一大坨程式碼。此外，將 crate 保持在 workspace 中，如果它們經常同時更改，可以使 crate 之間的協調更容易。

<!-- Old link, do not remove -->

<a id="installing-binaries-from-cratesio-with-cargo-install"></a>

## 使用 cargo install 安裝二進位檔

`cargo install` 命令允許你在本地安裝和使用 binary crate。這並非旨在取代系統套件；它旨在為 Rust 開發者提供一種方便的方式，來安裝其他人已在 crates.io 上分享的工具。請注意，你只能安裝具有 binary target 的 package。_binary target_ 是指如果 crate 具有 _src/main.rs_ 檔案或另一個指定為 binary 的檔案時所建立的可執行程式，這與 library target 不同，library target 本身無法執行，但適合包含在其他程式中。通常，crate 會在其 _README_ 檔案中說明該 crate 是 library、具有 binary target，還是兩者兼有。

所有透過 `cargo install` 安裝的二進位檔都儲存在安裝根目錄的 _bin_ 資料夾中。如果你是使用 _rustup.rs_ 安裝 Rust 並且沒有任何自訂配置，這個目錄將會是 *$HOME/.cargo/bin*。請確保該目錄位於你的 `$PATH`中，以便能夠執行你使用`cargo install` 安裝的程式。

例如，在第十二章中我們提到過，有一個 Rust 實作的 `grep` 工具，稱為 `ripgrep`，用於搜尋檔案。要安裝 `ripgrep`，我們可以執行以下命令：

<!-- manual-regeneration
cargo install something you don't have, copy relevant output below
-->

```text
$ cargo install ripgrep
    Updating crates.io index
  Downloaded ripgrep v14.1.1
  Downloaded 1 crate (213.6 KB) in 0.40s
  Installing ripgrep v14.1.1
--snip--
   Compiling grep v0.3.2
    Finished `release` profile [optimized + debuginfo] target(s) in 6.73s
  Installing ~/.cargo/bin/rg
   Installed package `ripgrep v14.1.1` (executable `rg`)
```

輸出的倒數第二行顯示了已安裝 binary 的位置和名稱，在 `ripgrep` 的情況下是 `rg`。只要安裝目錄在你的 `$PATH` 中（如前所述），你就可以執行 `rg --help` 並開始使用一個更快、更 Rust 風格的工具來搜尋檔案！

## 使用自訂命令擴展 Cargo

Cargo 的設計宗旨是讓你無需修改它即可用新的 subcommand 擴展它。如果你的 `$PATH` 中有一個名為 `cargo-something` 的 binary，你可以透過執行 `cargo something` 將其作為 Cargo subcommand 運行。當你執行 `cargo --list` 時，此類自訂命令也會被列出。能夠使用 `cargo install` 來安裝擴展，然後像內建的 Cargo 工具一樣運行它們，是 Cargo 設計的一個超級方便的優點！

## 總結

與 Cargo 和 crates.io 共享程式碼是使 Rust 生態系統適用於許多不同任務的一部分。Rust 的標準函式庫小巧且穩定，但 crate 可以輕鬆共享、使用和改進，且其時間軸與語言本身不同。不要害怕在 crates.io 上分享對你有用的程式碼；它很可能對其他人也很有用！
