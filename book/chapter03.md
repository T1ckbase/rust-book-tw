<!-- DO NOT EDIT THIS FILE.

This file is periodically generated from the content in the `/src/`
directory, so all fixes need to be made in `/src/`.
-->

[TOC]

# 常見程式設計概念

本章節介紹了幾乎所有程式語言中都會出現的概念，以及它們在 Rust 中是如何運作的。許多程式語言的核心都有許多共通之處。本章節中介紹的概念都不是 Rust 獨有的，但我們將在 Rust 的語境中討論它們，並解釋使用這些概念的慣例。

具體來說，你將學習變數 (variables)、基本型別 (basic types)、函數 (functions)、註解 (comments) 和控制流程 (control flow)。這些基礎將會出現在每個 Rust 程式中，盡早學習它們將為你打下堅實的基礎。

> #### 關鍵字 (Keywords)
>
> 與其他語言一樣，Rust 語言有一組*關鍵字* (keywords) 專供語言本身使用。請記住，你不能將這些詞用作變數或函數的名稱。大多數關鍵字都有特殊含義，你將在 Rust 程式中使用它們來執行各種任務；少數關鍵字目前沒有相關功能，但已保留用於未來可能添加到 Rust 中的功能。你可以在附錄 A 中找到關鍵字列表。

## 變數與可變性 (Variables and Mutability)

如「[用變數儲存數值](https://doc.rust-lang.org/book/ch02-00-guessing-game-tutorial.html#storing-values-with-variables)」章節所述，變數預設是 immutable（不可變）的。這是 Rust 鼓勵你以一種方式編寫程式碼，從而利用 Rust 所提供的安全性和易於併發性的眾多提示之一。然而，你仍然可以選擇將你的變數設為 mutable（可變）。讓我們探討 Rust 如何以及為何鼓勵你偏好 immutability，以及有時你為何可能希望選擇不使用它。

當一個變數是 immutable 時，一旦一個值被綁定到一個名稱，你就不能改變那個值。為了說明這一點，在你的 *projects* 目錄中，使用 `cargo new variables` 來建立一個名為 *variables* 的新專案。

然後，在你新的 *variables* 目錄中，打開 *src/main.rs* 並將其程式碼替換為以下程式碼，這段程式碼目前還無法編譯：

檔案名稱：src/main.rs

```rust
fn main() {
    let x = 5;
    println!("The value of x is: {x}");
    x = 6;
    println!("The value of x is: {x}");
}
```

儲存並使用 `cargo run` 執行程式。你應該會收到一個關於 immutability 錯誤的訊息，如下所示：

```
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0384]: cannot assign twice to immutable variable `x`
 --> src/main.rs:4:5
  |
2 |     let x = 5;
  |         - first assignment to `x`
3 |     println!("The value of x is: {x}");
4 |     x = 6;
  |     ^^^^^ cannot assign twice to immutable variable
  |
help: consider making this binding mutable
  |
2 |     let mut x = 5;
  |         +++

For more information about this error, try `rustc --explain E0384`.
error: could not compile `variables` (bin "variables") due to 1 previous error
```

這個範例展示了編譯器如何幫助你找出程式中的錯誤。編譯器錯誤可能會令人沮喪，但它們實際上只表示你的程式尚未安全地執行你想要它做的事情；它們*不*表示你不是一個好的程式設計師！經驗豐富的 Rustaceans 仍然會遇到編譯器錯誤。

你收到錯誤訊息 `` cannot assign twice to immutable variable `x` `` 是因為你嘗試為 immutable 的 `x` 變數分配第二個值。

當我們嘗試更改被指定為 immutable 的值時，得到編譯時錯誤很重要，因為這種情況很容易導致錯誤。如果我們程式碼的一部分基於一個值永不改變的假設進行操作，而程式碼的另一部分卻改變了該值，那麼程式碼的第一部分可能就無法執行其設計目的。這類錯誤的原因事後很難追蹤，特別是當第二部分程式碼只*有時*更改值時。Rust 編譯器保證，當你聲明一個值不會改變時，它確實不會改變，因此你無需自己追蹤。你的程式碼因此更容易推論。

但 mutability 非常有用，並且可以讓程式碼更方便編寫。儘管變數預設是 immutable 的，但你可以透過在變數名稱前加上 `mut` 來使其成為 mutable，就像你在[第二章](https://doc.rust-lang.org/book/ch02-00-guessing-game-tutorial.html)中所做的那樣。加上 `mut` 也向未來的程式碼讀者傳達意圖，表明程式碼的其他部分將會改變這個變數的值。

例如，讓我們將 *src/main.rs* 更改為以下內容：

檔案名稱：src/main.rs

```rust
fn main() {
    let mut x = 5;
    println!("The value of x is: {x}");
    x = 6;
    println!("The value of x is: {x}");
}
```

現在執行程式，我們會得到以下輸出：

```
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/variables`
The value of x is: 5
The value of x is: 6
```

當使用 `mut` 時，我們被允許將綁定到 `x` 的值從 `5` 更改為 `6`。最終，決定是否使用 mutability 取決於你，並取決於你認為在哪種特定情況下最清楚。

### 常數 (Constants)

與 immutable 變數一樣，*常數* (constants) 是綁定到名稱且不允許更改的值，但常數和變數之間存在一些差異。

首先，你不允許將 `mut` 與常數一起使用。常數不僅預設是 immutable 的——它們總是 immutable 的。你使用 `const` 關鍵字而不是 `let` 關鍵字來宣告常數，並且值的型別*必須*被註釋。我們將在下一節「[資料型別](https://doc.rust-lang.org/book/ch03-02-data-types.html)」中介紹型別和型別註釋，所以現在不用擔心細節。你只需要知道你必須始終註釋型別。

常數可以在任何範圍內宣告，包括全域範圍，這使得它們對於程式碼許多部分都需要知道的值非常有用。

最後一個差異是，常數只能設定為常數表達式 (constant expression)，而不是只能在執行時計算的值的結果。

這是一個常數宣告的範例：

```
const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
```

這個常數的名稱是 `THREE_HOURS_IN_SECONDS`，它的值被設定為 60（一分鐘的秒數）乘以 60（一小時的分鐘數）再乘以 3（我們想在程式中計算的小時數）的結果。Rust 的常數命名慣例是使用全大寫字母並在單字之間使用底線。編譯器能夠在編譯時評估有限的運算，這讓我們可以選擇以一種更容易理解和驗證的方式來撰寫這個值，而不是將這個常數設定為 10,800。有關宣告常數時可以使用哪些運算的更多資訊，請參閱 Rust Reference 中關於[常數評估](https://doc.rust-lang.org/reference/const_eval.html)的部分。

常數在程式執行期間的整個宣告範圍內都是有效的。這個特性使得常數對於應用程式領域中多個程式部分可能需要知道的值非常有用，例如遊戲中任何玩家允許獲得的最大分數，或是光速。

將程式中使用的硬編碼值命名為常數，對於向未來的程式碼維護者傳達該值的含義非常有用。如果未來需要更新硬編碼值，它也有助於在程式碼中只在一個地方進行更改。

### 遮蔽 (Shadowing)

正如你在[第二章](https://doc.rust-lang.org/book/ch02-00-guessing-game-tutorial.html)的猜數字遊戲教學中看到的那樣，你可以宣告一個與先前變數同名的新變數。Rustaceans 稱第一個變數被第二個變數*遮蔽* (shadowed)，這表示當你使用該變數的名稱時，編譯器將會看到第二個變數。實際上，第二個變數會覆蓋第一個變數，獨佔該變數名稱的所有使用，直到它自己被遮蔽或其作用域結束。我們可以透過使用相同的變數名稱並重複使用 `let` 關鍵字來遮蔽變數，如下所示：

檔案名稱：src/main.rs

```rust
fn main() {
    let x = 5;

    let x = x + 1;

    {
        let x = x * 2;
        println!("The value of x in the inner scope is: {x}");
    }

    println!("The value of x is: {x}");
}
```

這個程式首先將 `x` 綁定到值 `5`。然後它透過重複 `let x =` 建立一個新的變數 `x`，取原始值並加上 `1`，使得 `x` 的值變為 `6`。接著，在由大括號建立的內部作用域中，第三個 `let` 陳述式也遮蔽了 `x` 並建立了一個新變數，將先前的值乘以 `2` 使得 `x` 的值變為 `12`。當該作用域結束時，內部遮蔽結束，`x` 恢復為 `6`。當我們執行這個程式時，它將輸出以下內容：

```
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/variables`
The value of x in the inner scope is: 12
The value of x is: 6
```

遮蔽 (Shadowing) 與將變數標記為 `mut` 是不同的，因為如果我們在不使用 `let` 關鍵字的情況下意外地嘗試重新賦值給這個變數，我們將會得到編譯時錯誤 (compile-time error)。透過使用 `let`，我們可以在對值進行一些轉換後，讓變數在轉換完成後保持 immutable。

`mut` 和 shadowing 之間的其他區別是，因為我們在使用 `let` 關鍵字時實際上是建立了一個新變數，所以我們可以改變值的型別，但重複使用相同的名稱。例如，假設我們的程式要求使用者透過輸入空格字元來顯示他們希望文本之間有多少空格，然後我們希望將該輸入儲存為數字：

```
    let spaces = "   ";
    let spaces = spaces.len();
```

第一個 `spaces` 變數是字串型別，第二個 `spaces` 變數是數字型別。因此，遮蔽讓我們不必想出不同的名稱，例如 `spaces_str` 和 `spaces_num`；相反，我們可以重複使用更簡單的 `spaces` 名稱。但是，如果我們嘗試像這裡所示那樣使用 `mut`，我們將會得到編譯時錯誤：

```
    let mut spaces = "   ";
    spaces = spaces.len();
```

錯誤訊息指出我們不允許改變變數的型別：

```
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0308]: mismatched types
 --> src/main.rs:3:14
  |
2 |     let mut spaces = "   ";
  |                      ----- expected due to this value
3 |     spaces = spaces.len();
  |              ^^^^^^^^^^^^ expected `&str`, found `usize`

For more information about this error, try `rustc --explain E0308`.
error: could not compile `variables` (bin "variables") due to 1 previous error
```

現在我們已經探討了變數的運作方式，接下來看看它們可以擁有的更多資料型別。

## 資料型別 (Data Types)

Rust 中的每個值都具有特定的*資料型別* (data type)，這告訴 Rust 所指定的資料類型，以便它知道如何處理該資料。我們將介紹兩種資料型別子集：純量 (scalar) 和複合 (compound)。

請記住，Rust 是一種*靜態型別* (statically typed) 的語言，這意味著它必須在編譯時知道所有變數的型別。編譯器通常可以根據值及其使用方式來推斷我們想要使用的型別。在許多型別都可能的情況下，例如在[第二章](https://doc.rust-lang.org/book/ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number)「[比較猜測與秘密數字](https://doc.rust-lang.org/book/ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number)」章節中，我們將 `String` 轉換為數字型別時使用了 `parse`，我們必須添加型別註釋 (type annotation)，如下所示：

```rust
let guess: u32 = "42".parse().expect("Not a number!");
```

如果我們不加上前面程式碼中顯示的 `: u32` 型別註釋，Rust 將會顯示以下錯誤，這表示編譯器需要更多資訊才能知道我們想要使用哪種型別：

```
$ cargo build
   Compiling no_type_annotations v0.1.0 (file:///projects/no_type_annotations)
error[E0284]: type annotations needed
 --> src/main.rs:2:9
  |
2 |     let guess = "42".parse().expect("Not a number!");
  |         ^^^^^        ----- type must be known at this point
  |
  = note: cannot satisfy `<_ as FromStr>::Err == _`
help: consider giving `guess` an explicit type
  |
2 |     let guess: /* Type */ = "42".parse().expect("Not a number!");
  |              ++++++++++++

For more information about this error, try `rustc --explain E0284`.
error: could not compile `no_type_annotations` (bin "no_type_annotations") due to 1 previous error
```

你會看到其他資料型別的不同型別註釋。

### 純量型別 (Scalar Types)

*純量* (scalar) 型別表示單一值。Rust 有四種主要的純量型別：整數 (integers)、浮點數 (floating-point numbers)、布林值 (Booleans) 和字元 (characters)。你可能從其他程式語言中認得這些型別。讓我們深入探討它們在 Rust 中的運作方式。

#### 整數型別 (Integer Types)

*整數* (integer) 是沒有分數部分的數字。我們在第二章中使用了一種整數型別，`u32` 型別。這個型別宣告表示它所關聯的值應該是一個 unsigned integer（無符號整數）（signed integer 型別以 `i` 而非 `u` 開頭），並佔用 32 bits 的空間。表 3-1 顯示了 Rust 中內建的整數型別。我們可以使用這些變體中的任何一個來宣告整數值的型別。

表 3-1：Rust 中的整數型別

|長度 (Length)|有符號 (Signed)|無符號 (Unsigned)|
|------|------|--------|
|8-bit|`i8`|`u8`|
|16-bit|`i16`|`u16`|
|32-bit|`i32`|`u32`|
|64-bit|`i64`|`u64`|
|128-bit|`i128`|`u128`|
|依賴架構 (architecture dependent)|`isize`|`usize`|

每個變體都可以是有符號 (signed) 或無符號 (unsigned)，並且具有明確的大小。*有符號*和*無符號*指的是數字是否可以是負數——換句話說，數字是否需要帶有符號（有符號）或是否只會是正數，因此可以不帶符號表示（無符號）。這就像在紙上寫數字一樣：當符號很重要時，數字會帶有加號或減號；但是，當可以安全地假設數字為正數時，則不帶符號顯示。有符號數字使用二補數 (two’s complement) 表示法儲存。

每個有符號變體可以儲存從 −(2<sup>n − 1</sup>) 到 2<sup>n − 1</sup> − 1（含）的數字，其中 *n* 是該變體使用的位元數。因此，一個 `i8` 可以儲存從 −(2<sup>7</sup>) 到 2<sup>7</sup> − 1 的數字，即 −128 到 127。無符號變體可以儲存從 0 到 2<sup>n</sup> − 1 的數字，因此一個 `u8` 可以儲存從 0 到 2<sup>8</sup> − 1 的數字，即 0 到 255。

此外，`isize` 和 `usize` 型別取決於程式運行所在的電腦架構：如果是 64-bit 架構則為 64 bits，如果是 32-bit 架構則為 32 bits。

你可以用表 3-2 中所示的任何一種形式寫整數 literals。請注意，可以有多個數字型別的數字 literals 允許使用型別後綴，例如 `57u8`，來指定型別。數字 literals 也可以使用 `_` 作為視覺分隔符號，以使數字更容易閱讀，例如 `1_000`，這與你指定 `1000` 具有相同的值。

表 3-2：Rust 中的整數 Literal

|數字 Literal (Number literals)|範例 (Example)|
|---------------|-------|
|十進制 (Decimal)|`98_222`|
|十六進制 (Hex)|`0xff`|
|八進制 (Octal)|`0o77`|
|二進制 (Binary)|`0b1111_0000`|
|位元組 (`u8` only) (Byte (`u8` only))|`b'A'`|

那麼你如何知道要使用哪種整數型別呢？如果你不確定，Rust 的預設值通常是一個好的開始：整數型別預設為 `i32`。你使用 `isize` 或 `usize` 的主要情況是當索引某種類型的 collection 時。

> ##### 整數溢位 (Integer Overflow)
>
> 假設你有一個 `u8` 型別的變數，它可以容納 0 到 255 之間的值。如果你嘗試將變數更改為超出該範圍的值，例如 256，將會發生*整數溢位* (integer overflow)，這可能導致兩種行為之一。當你在除錯模式 (debug mode) 下編譯時，Rust 包含整數溢位檢查，如果發生這種行為，將導致你的程式在執行時*panic*（恐慌）。Rust 在程式以錯誤退出時使用術語*panicking*；我們將在[第九章](https://doc.rust-lang.org/book/ch09-00-error-handling.html)的「[使用 `panic!` 處理無法復原的錯誤](https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html)」一節中更深入地討論 panics。
>
> 當你使用 `--release` 標誌在發布模式 (release mode) 下編譯時，Rust *不*會包含導致 panics 的整數溢位檢查。相反，如果發生溢位，Rust 會執行*二補數環繞* (two’s complement wrapping)。簡而言之，大於型別所能容納的最大值會「環繞」到型別所能容納的最小值。對於 `u8` 的情況，值 256 變為 0，值 257 變為 1，依此類推。程式不會 panic，但變數將擁有一個值，這個值可能不是你預期的。依賴整數溢位的環繞行為被視為一個錯誤。
>
> 為了明確處理溢位的可能性，你可以使用標準函式庫為基本數字型別提供的這些方法家族：
>
> *   在所有模式下使用 `wrapping_*` 方法進行環繞，例如 `wrapping_add`。
> *   如果發生溢位，則使用 `checked_*` 方法回傳 `None` 值。
> *   使用 `overflowing_*` 方法回傳值和一個布林值，指示是否發生溢位。
> *   使用 `saturating_*` 方法將值飽和到該型別的最小值或最大值。

#### 浮點數型別 (Floating-Point Types)

Rust 也有兩種用於*浮點數* (floating-point numbers) 的原始型別，它們是帶有小數點的數字。Rust 的浮點數型別是 `f32` 和 `f64`，它們的大小分別為 32 bits 和 64 bits。預設型別是 `f64`，因為在現代 CPU 上，它的速度大約與 `f32` 相同，但能夠提供更高的精確度。所有浮點數型別都是有符號的。

以下是一個展示浮點數運作的範例：

檔案名稱：src/main.rs

```rust
fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}
```

浮點數根據 IEEE-754 標準表示。

#### 數值運算 (Numeric Operations)

Rust 支援所有數字型別應有的基本數學運算：加法、減法、乘法、除法和餘數。整數除法會向零截斷到最接近的整數。以下程式碼顯示了如何在 `let` 陳述式中使用每個數值運算：

檔案名稱：src/main.rs

```rust
fn main() {
    // addition
    let sum = 5 + 10;

    // subtraction
    let difference = 95.5 - 4.3;

    // multiplication
    let product = 4 * 30;

    // division
    let quotient = 56.7 / 32.2;
    let truncated = -5 / 3; // Results in -1

    // remainder
    let remainder = 43 % 5;
}
```

這些陳述式中的每個表達式都使用一個數學運算子並計算出一個單一值，然後該值被綁定到一個變數。附錄 B 包含了 Rust 提供的所有運算子的列表。

#### 布林型別 (The Boolean Type)

與大多數其他程式語言一樣，Rust 中的布林 (Boolean) 型別有兩個可能的值：`true` 和 `false`。布林值大小為一個位元組。Rust 中的布林型別使用 `bool` 指定。例如：

檔案名稱：src/main.rs

```rust
fn main() {
    let t = true;

    let f: bool = false; // with explicit type annotation
}
```

使用布林值的主要方式是透過條件式 (conditionals)，例如 `if` 表達式。我們將在「[控制流程](https://doc.rust-lang.org/book/ch03-05-control-flow.html)」一節中介紹 `if` 表達式在 Rust 中的運作方式。

#### 字元型別 (The Character Type)

Rust 的 `char` 型別是該語言最原始的字母型別。以下是一些宣告 `char` 值的範例：

檔案名稱：src/main.rs

```rust
fn main() {
    let c = 'z';
    let z: char = 'ℤ'; // with explicit type annotation
    let heart_eyed_cat = '😻';
}
```

請注意，我們使用單引號來指定 `char` literals，這與使用雙引號的字串 literals 相反。Rust 的 `char` 型別大小為四個位元組，並代表一個 Unicode 純量值 (Unicode scalar value)，這表示它可以表示比 ASCII 更多的內容。帶重音的字母；中文、日文和韓文字元；表情符號；以及零寬度空白都是 Rust 中有效的 `char` 值。Unicode 純量值的範圍從 `U+0000` 到 `U+D7FF` 以及 `U+E000` 到 `U+10FFFF`（含）。然而，在 Unicode 中，「字元」並不是一個真正的概念，所以你對「字元」的人類直覺可能與 Rust 中的 `char` 不符。我們將在第八章「[使用字串儲存 UTF-8 編碼文本](https://doc.rust-lang.org/book/ch08-02-strings.html#storing-utf-8-encoded-text-with-strings)」中詳細討論這個主題。

### 複合型別 (Compound Types)

*複合型別* (Compound types) 可以將多個值組合為一個型別。Rust 有兩種原始複合型別：元組 (tuples) 和陣列 (arrays)。

#### 元組型別 (The Tuple Type)

*元組* (tuple) 是一種將多個具有各種型別的值分組為一個複合型別的通用方式。元組具有固定長度：一旦宣告，它們的大小就不能增加或減少。

我們透過將逗號分隔的值列表寫在括號內來建立一個元組。元組中的每個位置都有一個型別，並且元組中不同值的型別不必相同。我們在這個範例中添加了可選的型別註釋：

檔案名稱：src/main.rs

```rust
fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
```

變數 `tup` 綁定到整個 tuple，因為 tuple 被視為一個單一的複合元素。要從 tuple 中取出單獨的值，我們可以使用 pattern matching 來解構 tuple 值，如下所示：

檔案名稱：src/main.rs

```rust
fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!("The value of y is: {y}");
}
```

這個程式首先建立一個 tuple 並將其綁定到變數 `tup`。然後它使用帶有 `let` 的 pattern 將 `tup` 轉換為三個獨立的變數 `x`、`y` 和 `z`。這稱為*解構* (destructuring)，因為它將單一 tuple 分解為三個部分。最後，程式印出 `y` 的值，即 `6.4`。

我們也可以透過使用句點 (`.`) 後跟我們要存取的值的索引來直接存取 tuple 元素。例如：

檔案名稱：src/main.rs

```rust
fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}
```

這個程式建立 tuple `x`，然後使用各自的索引存取 tuple 的每個元素。與大多數程式語言一樣，tuple 的第一個索引是 0。

沒有任何值的 tuple 有一個特殊名稱，*unit*（單元）。這個值及其對應的型別都寫作 `()`，並表示一個空值或一個空回傳型別。表達式如果沒有回傳任何其他值，則會隱式回傳 unit 值。

#### 陣列型別 (The Array Type)

另一種包含多個值集合的方式是使用*陣列* (array)。與元組 (tuple) 不同，陣列的每個元素都必須具有相同的型別。與某些其他語言中的陣列不同，Rust 中的陣列具有固定長度。

我們將陣列中的值寫成用逗號分隔的列表，並放在方括號內：

檔案名稱：src/main.rs

```rust
fn main() {
    let a = [1, 2, 3, 4, 5];
}
```

當你希望資料在 stack 上分配，就像我們目前看到的其他型別一樣，而不是在 heap 上時（我們將在[第四章](https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html)中更多地討論 stack 和 heap），或者當你希望確保始終擁有固定數量的元素時，陣列非常有用。不過，陣列不像 vector 型別那樣靈活。*vector* 是標準函式庫提供的類似 collection 型別，它*允許*大小增長或縮小，因為其內容位於 heap 上。如果你不確定應該使用陣列還是 vector，很有可能你應該使用 vector。第八章會更詳細地討論 vectors。

然而，當你知道元素數量不需要改變時，陣列會更有用。例如，如果你在程式中使用月份名稱，你可能會使用陣列而不是 vector，因為你知道它將始終包含 12 個元素：

```rust
let months = ["January", "February", "March", "April", "May", "June", "July",
              "August", "September", "October", "November", "December"];
```

你使用方括號寫一個陣列的型別，其中包含每個元素的型別、一個分號，然後是陣列中元素的數量，如下所示：

```rust
let a: [i32; 5] = [1, 2, 3, 4, 5];
```

在這裡，`i32` 是每個元素的型別。分號後面的數字 `5` 表示該陣列包含五個元素。

你也可以透過指定初始值、接著一個分號，然後在方括號中指定陣列長度來初始化陣列，使每個元素都包含相同的值，如下所示：

```rust
let a = [3; 5];
```

名為 `a` 的陣列最初將包含 5 個元素，所有這些元素都將被設定為值 `3`。這與寫 `let a = [3, 3, 3, 3, 3];` 相同，但方式更為簡潔。

##### 存取陣列元素 (Accessing Array Elements)

陣列是一個已知、固定大小的單一記憶體區塊，可以在 stack 上分配。你可以使用索引來存取陣列中的元素，如下所示：

檔案名稱：src/main.rs

```rust
fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}
```

在這個範例中，名為 `first` 的變數將獲得值 `1`，因為這是陣列中索引 `[0]` 處的值。名為 `second` 的變數將從陣列中索引 `[1]` 處獲得值 `2`。

##### 無效的陣列元素存取 (Invalid Array Element Access)

讓我們看看如果你嘗試存取陣列末端之外的元素會發生什麼事。假設你執行這段程式碼，類似於[第二章](https://doc.rust-lang.org/book/ch02-00-guessing-game-tutorial.html)中的猜數字遊戲，從使用者那裡獲取陣列索引：

檔案名稱：src/main.rs

```rust
use std::io;

fn main() {
    let a = [1, 2, 3, 4, 5];

    println!("Please enter an array index.");

    let mut index = String::new();

    io::stdin()
        .read_line(&mut index)
        .expect("Failed to read line");

    let index: usize = index
        .trim()
        .parse()
        .expect("Index entered was not a number");

    let element = a[index];

    println!("The value of the element at index {index} is: {element}");
}
```

這段程式碼編譯成功。如果你使用 `cargo run` 執行這段程式碼並輸入 `0`、`1`、`2`、`3` 或 `4`，程式將印出陣列中該索引處的相應值。如果你輸入一個超出陣列末端的數字，例如 `10`，你將會看到類似這樣的輸出：

```
thread 'main' panicked at src/main.rs:19:19:
index out of bounds: the len is 5 but the index is 10
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```

程式在索引操作中使用無效值時產生了*執行時* (runtime) 錯誤。程式以錯誤訊息退出，並且沒有執行最終的 `println!` 陳述式。當你嘗試使用索引存取元素時，Rust 將檢查你指定的索引是否小於陣列長度。如果索引大於或等於長度，Rust 將會 panic。此檢查必須在執行時進行，尤其是在此情況下，因為編譯器無法知道使用者在稍後執行程式碼時將輸入什麼值。

這是 Rust 記憶體安全原則實際運作的一個範例。在許多低階語言中，此類檢查並未執行，當你提供不正確的索引時，可能會存取無效記憶體。Rust 透過立即退出而不是允許記憶體存取並繼續來保護你免受此類錯誤的影響。[第九章](https://doc.rust-lang.org/book/ch09-00-error-handling.html)討論了更多 Rust 的錯誤處理以及如何編寫可讀、安全且不會 panic 也沒有無效記憶體存取的程式碼。

## 函數 (Functions)

函數在 Rust 程式碼中很常見。你已經見過語言中最重要的函數之一：`main` 函數，它是許多程式的進入點。你也見過 `fn` 關鍵字，它允許你宣告新函數。

Rust 程式碼使用 *snake case* 作為函數和變數名稱的慣例風格，其中所有字母都是小寫，單字之間用底線分隔。這是一個包含函數定義範例的程式：

檔案名稱：src/main.rs

```rust
fn main() {
    println!("Hello, world!");

    another_function();
}

fn another_function() {
    println!("Another function.");
}
```

我們透過輸入 `fn` 後跟函數名稱和一組括號來在 Rust 中定義一個函數。大括號告訴編譯器函數主體 (function body) 的開始和結束位置。

我們可以透過輸入函數名稱後跟一組括號來呼叫任何我們定義的函數。因為 `another_function` 在程式中定義，所以可以在 `main` 函數內部呼叫它。請注意，我們在原始碼中將 `another_function` 定義在 `main` 函數*之後*；我們也可以將它定義在之前。Rust 不在乎你把函數定義在哪裡，只在乎它們是否定義在一個呼叫者可以看到的作用域內。

讓我們建立一個名為 *functions* 的新 binary project 來進一步探索函數。將 `another_function` 範例放在 *src/main.rs* 中並執行它。你應該會看到以下輸出：

```
$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.28s
     Running `target/debug/functions`
Hello, world!
Another function.
```

程式碼行按照它們在 `main` 函數中出現的順序執行。首先印出「Hello, world!」訊息，然後呼叫 `another_function` 並印出其訊息。

### 參數 (Parameters)

我們可以定義函數具有*參數* (parameters)，這些參數是函數簽章 (function’s signature) 的一部分的特殊變數。當一個函數有參數時，你可以為這些參數提供具體的值。嚴格來說，這些具體的值稱為*引數* (arguments)，但在日常對話中，人們傾向於將*參數*和*引數*交替使用，無論是函數定義中的變數還是呼叫函數時傳入的具體值。

在這個版本的 `another_function` 中，我們新增了一個參數：

檔案名稱：src/main.rs

```rust
fn main() {
    another_function(5);
}

fn another_function(x: i32) {
    println!("The value of x is: {x}");
}
```

嘗試執行這個程式；你應該會得到以下輸出：

```
$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 1.21s
     Running `target/debug/functions`
The value of x is: 5
```

`another_function` 的宣告有一個名為 `x` 的參數。`x` 的型別被指定為 `i32`。當我們將 `5` 傳遞給 `another_function` 時，`println!` macro 將 `5` 放在格式字串中包含 `x` 的大括號對的位置。

在函數簽章中，你*必須*宣告每個參數的型別。這是 Rust 設計中的一個刻意決定：要求在函數定義中進行型別註釋意味著編譯器幾乎從不需要你在程式碼的其他地方使用它們來弄清楚你指的是哪種型別。如果編譯器知道函數預期哪些型別，它也能提供更有用的錯誤訊息。

當定義多個參數時，請用逗號分隔參數宣告，如下所示：

檔案名稱：src/main.rs

```rust
fn main() {
    print_labeled_measurement(5, 'h');
}

fn print_labeled_measurement(value: i32, unit_label: char) {
    println!("The measurement is: {value}{unit_label}");
}
```

這個範例建立了一個名為 `print_labeled_measurement` 的函數，它有兩個參數。第一個參數名為 `value`，型別為 `i32`。第二個參數名為 `unit_label`，型別為 `char`。然後函數會印出包含 `value` 和 `unit_label` 的文本。

讓我們嘗試執行這段程式碼。將你 *functions* 專案的 *src/main.rs* 檔案中目前的程式替換為上述範例，並使用 `cargo run` 執行它：

```
$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/functions`
The measurement is: 5h
```

因為我們以 `5` 作為 `value` 的值，並以 `'h'` 作為 `unit_label` 的值來呼叫該函數，所以程式輸出中包含了這些值。

### 陳述式與表達式 (Statements and Expressions)

函數主體由一系列陳述式組成，可選地以表達式結尾。到目前為止，我們討論的函數沒有包含結尾的表達式，但你已經看到一個表達式作為陳述式的一部分。因為 Rust 是一種基於表達式的語言，所以理解這個重要的區別很重要。其他語言沒有相同的區別，所以讓我們看看陳述式和表達式是什麼，以及它們的差異如何影響函數的主體。

*   陳述式 (Statements) 是執行某些動作且不回傳值的指令。
*   表達式 (Expressions) 則會計算出一個結果值。

讓我們看一些例子。

我們實際上已經使用過陳述式和表達式。使用 `let` 關鍵字建立變數並為其賦值就是一個陳述式。在清單 3-1 中，`let y = 6;` 是一個陳述式。

src/main.rs

```rust
fn main() {
    let y = 6;
}
```

清單 3-1：包含一個陳述式的 `main` 函數宣告

函數定義也是陳述式；整個上述範例本身就是一個陳述式。（不過，正如我們稍後將看到的，*呼叫*一個函數並不是一個陳述式。）

陳述式不回傳值。因此，你不能將 `let` 陳述式賦值給另一個變數，如下列程式碼嘗試執行的那樣；你會得到一個錯誤：

檔案名稱：src/main.rs

```rust
fn main() {
    let x = (let y = 6);
}
```

當你執行這個程式時，你會得到類似這樣的錯誤：

```
$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
error: expected expression, found `let` statement
 --> src/main.rs:2:14
  |
2 |     let x = (let y = 6);
  |              ^^^
  |
  = note: only supported directly in conditions of `if` and `while` expressions

warning: unnecessary parentheses around assigned value
 --> src/main.rs:2:13
  |
2 |     let x = (let y = 6);
  |             ^         ^
  |
  = note: `#[warn(unused_parens)]` on by default
help: remove these parentheses
  |
2 -     let x = (let y = 6);
2 +     let x = let y = 6;
  |

warning: `functions` (bin "functions") generated 1 warning
error: could not compile `functions` (bin "functions") due to 1 previous error; 1 warning emitted
```

`let y = 6` 陳述式不回傳值，所以沒有任何東西可以讓 `x` 綁定。這與其他語言（例如 C 和 Ruby）中發生的情況不同，在那些語言中，賦值會回傳賦值的值。在那些語言中，你可以寫 `x = y = 6`，並且 `x` 和 `y` 都會有值 `6`；但在 Rust 中情況並非如此。

表達式 (Expressions) 會計算出一個值，並構成你在 Rust 中會編寫的大部分程式碼。考慮一個數學運算，例如 `5 + 6`，這是一個計算出值 `11` 的表達式。表達式可以是陳述式的一部分：在清單 3-1 中，陳述式 `let y = 6;` 中的 `6` 是一個計算出值 `6` 的表達式。呼叫函數是一個表達式。呼叫 macro 是一個表達式。用大括號建立的新範圍區塊是一個表達式，例如：

檔案名稱：src/main.rs

```rust
fn main() {
    let y = {
        let x = 3;
        x + 1
    };

    println!("The value of y is: {y}");
}
```

這個表達式：

```
{
    let x = 3;
    x + 1
}
```

是一個區塊，在這種情況下，它的計算結果為 `4`。該值作為 `let` 陳述式的一部分被綁定到 `y`。請注意，`x + 1` 這行末尾沒有分號，這與你目前為止看到的大多數行不同。表達式不包含結尾分號。如果你在表達式末尾添加分號，你會將其變成一個陳述式，然後它將不回傳值。當你接下來探索函數回傳值和表達式時，請記住這一點。

### 帶有回傳值的函數 (Functions with Return Values)

函數可以將值回傳給呼叫它們的程式碼。我們不命名回傳值，但我們必須在箭頭 (`->`) 後面宣告它們的型別。在 Rust 中，函數的回傳值與函數主體區塊中最後一個表達式的值是同義詞。你可以使用 `return` 關鍵字並指定一個值來提早從函數中回傳，但大多數函數都會隱式地回傳最後一個表達式。這是一個回傳值的函數範例：

檔案名稱：src/main.rs

```rust
fn five() -> i32 {
    5
}

fn main() {
    let x = five();

    println!("The value of x is: {x}");
}
```

`five` 函數中沒有函數呼叫、macro 甚至 `let` 陳述式——只有數字 `5` 本身。這在 Rust 中是一個完全有效的函數。請注意，函數的回傳型別也指定為 `-> i32`。嘗試執行這段程式碼；輸出應該會像這樣：

```
$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/functions`
The value of x is: 5
```

`five` 中的 `5` 是函數的回傳值，這就是為什麼回傳型別是 `i32`。讓我們更詳細地檢視這一點。有兩個重要部分：首先，行 `let x = five();` 顯示我們正在使用函數的回傳值來初始化一個變數。因為函數 `five` 回傳 `5`，所以這行與以下內容相同：

```rust
let x = 5;
```

其次，`five` 函數沒有參數，並定義了回傳值的型別，但函數的主體是一個孤零零的 `5`，沒有分號，因為它是一個我們想要回傳值的表達式。

讓我們看另一個範例：

檔案名稱：src/main.rs

```rust
fn main() {
    let x = plus_one(5);

    println!("The value of x is: {x}");
}

fn plus_one(x: i32) -> i32 {
    x + 1
}
```

執行這段程式碼將會印出 `The value of x is: 6`。但是，如果我們在包含 `x + 1` 的行末尾加上一個分號，將其從表達式變為陳述式，我們將會得到一個錯誤：

檔案名稱：src/main.rs

```rust
fn main() {
    let x = plus_one(5);

    println!("The value of x is: {x}");
}

fn plus_one(x: i32) -> i32 {
    x + 1;
}
```

編譯這段程式碼會產生錯誤，如下所示：

```
$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
error[E0308]: mismatched types
 --> src/main.rs:7:24
  |
7 | fn plus_one(x: i32) -> i32 {
  |    --------            ^^^ expected `i32`, found `()`
  |    |
  |    implicitly returns `()` as its body has no tail or `return` expression
8 |     x + 1;
  |          - help: remove this semicolon to return this value

For more information about this error, try `rustc --explain E0308`.
error: could not compile `functions` (bin "functions") due to 1 previous error
```

主要的錯誤訊息 `mismatched types` 揭示了此程式碼的核心問題。函數 `plus_one` 的定義表明它將回傳一個 `i32`，但陳述式不會計算出一個值，這由 `()`（unit type）表示。因此，沒有任何東西被回傳，這與函數定義相矛盾並導致錯誤。在此輸出中，Rust 提供了一條訊息，可能可以幫助解決此問題：它建議刪除分號，這將會修復錯誤。

## 註解 (Comments)

所有程式設計師都努力讓他們的程式碼易於理解，但有時需要額外的解釋。在這些情況下，程式設計師會在原始碼中留下*註解* (comments)，這些註解將被編譯器忽略，但對於閱讀原始碼的人來說可能很有用。

這是一個簡單的註解：

```
// hello, world
```

在 Rust 中，慣用的註解風格是以兩個斜線開頭，註解持續到行尾。對於超過單行的註解，你需要在每行都包含 `//`，如下所示：

```
// So we're doing something complicated here, long enough that we need
// multiple lines of comments to do it! Whew! Hopefully, this comment will
// explain what's going on.
```

註解也可以放在包含程式碼的行尾：

檔案名稱：src/main.rs

```rust
fn main() {
    let lucky_number = 7; // I'm feeling lucky today
}
```

但你更常會看到它們以這種格式使用，註解放在其所註釋的程式碼上方單獨一行：

檔案名稱：src/main.rs

```rust
fn main() {
    // I'm feeling lucky today
    let lucky_number = 7;
}
```

Rust 還有另一種註解，即文件註解 (documentation comments)，我們將在[第十四章](https://doc.rust-lang.org/book/ch14-02-publishing-to-crates-io.html#publishing-a-crate-to-cratesio)的「[發布 crate 到 Crates.io](https://doc.rust-lang.org/book/ch14-02-publishing-to-crates-io.html#publishing-a-crate-to-cratesio)」一節中討論。

## 控制流程 (Control Flow)

根據條件是否為 `true` 來執行某些程式碼，以及在條件為 `true` 時重複執行某些程式碼，是大多數程式語言中的基本組成部分。在 Rust 程式碼中，最常用的控制執行流程的結構是 `if` 表達式和迴圈 (loops)。

### if 表達式 (if Expressions)

`if` 表達式允許你根據條件來分支你的程式碼。你提供一個條件，然後聲明：「如果滿足這個條件，就執行這個程式碼區塊。如果條件不滿足，就不要執行這個程式碼區塊。」

在你的 *projects* 目錄中建立一個名為 *branches* 的新專案，以探索 `if` 表達式。在 *src/main.rs* 檔案中，輸入以下內容：

檔案名稱：src/main.rs

```rust
fn main() {
    let number = 3;

    if number < 5 {
        println!("condition was true");
    } else {
        println!("condition was false");
    }
}
```

所有 `if` 表達式都以關鍵字 `if` 開頭，後跟一個條件。在此情況下，條件檢查變數 `number` 的值是否小於 5。如果條件為 `true`，我們將要執行的程式碼區塊緊接在條件之後，放在大括號內。與 `if` 表達式中的條件相關聯的程式碼區塊有時稱為*分支* (arms)，就像我們在[第二章](https://doc.rust-lang.org/book/ch02-00-guessing-game-tutorial.html)「[比較猜測與秘密數字](https://doc.rust-lang.org/book/ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number)」一節中討論的 `match` 表達式中的分支一樣。

可選地，我們也可以包含一個 `else` 表達式，我們在這裡選擇這樣做，以便在條件評估為 `false` 時為程式提供一個替代的程式碼區塊來執行。如果你沒有提供 `else` 表達式並且條件為 `false`，程式將會跳過 `if` 區塊並繼續執行下一段程式碼。

嘗試執行這段程式碼；你應該會看到以下輸出：

```
$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
condition was true
```

讓我們試著將 `number` 的值更改為一個使條件為 `false` 的值，看看會發生什麼：

```rust
    let number = 7;
```

再次執行程式，並查看輸出：

```
$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
condition was false
```

還值得注意的是，這段程式碼中的條件*必須*是 `bool` 型別。如果條件不是 `bool` 型別，我們就會得到一個錯誤。例如，嘗試執行以下程式碼：

檔案名稱：src/main.rs

```rust
fn main() {
    let number = 3;

    if number {
        println!("number was three");
    }
}
```

這次 `if` 條件評估為值 `3`，Rust 拋出了一個錯誤：

```
$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
error[E0308]: mismatched types
 --> src/main.rs:4:8
  |
4 |     if number {
  |        ^^^^^^ expected `bool`, found integer

For more information about this error, try `rustc --explain E0308`.
error: could not compile `branches` (bin "branches") due to 1 previous error
```

錯誤訊息表明 Rust 預期的是 `bool` 型別，但卻得到了整數型別。與 Ruby 和 JavaScript 等語言不同，Rust 不會自動嘗試將非布林型別轉換為布林型別。你必須明確地提供 `if` 一個布林值作為其條件。例如，如果我們希望 `if` 程式碼區塊僅在數字不等於 `0` 時才運行，我們可以將 `if` 表達式更改為以下內容：

檔案名稱：src/main.rs

```rust
fn main() {
    let number = 3;

    if number != 0 {
        println!("number was something other than zero");
    }
}
```

執行這段程式碼將會印出 `number was something other than zero`。

#### 使用 `else if` 處理多個條件 (Handling Multiple Conditions with else if)

你可以透過在 `else if` 表達式中結合 `if` 和 `else` 來使用多個條件。例如：

檔案名稱：src/main.rs

```rust
fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!("number is divisible by 4");
    } else if number % 3 == 0 {
        println!("number is divisible by 3");
    } else if number % 2 == 0 {
        println!("number is divisible by 2");
    } else {
        println!("number is not divisible by 4, 3, or 2");
    }
}
```

這個程式有四種可能的執行路徑。執行後，你應該會看到以下輸出：

```
$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
number is divisible by 3
```

當這個程式執行時，它會依序檢查每個 `if` 表達式，並執行條件評估為 `true` 的第一個區塊。請注意，即使 6 可以被 2 整除，我們也不會看到輸出 `number is divisible by 2`，也不會看到 `else` 區塊中的 `number is not divisible by 4, 3, or 2` 文本。這是因為 Rust 只執行第一個 `true` 條件的區塊，一旦找到一個，它甚至不會檢查其餘的。

使用過多的 `else if` 表達式會使你的程式碼變得混亂，所以如果你有多個 `else if` 表達式，你可能需要重構你的程式碼。第六章描述了一種強大的 Rust 分支結構，稱為 `match`，用於處理這些情況。

#### 在 `let` 陳述式中使用 `if` (Using if in a let Statement)

因為 `if` 是一個表達式，我們可以在 `let` 陳述式的右側使用它，將結果賦值給一個變數，如清單 3-2 所示。

src/main.rs

```rust
fn main() {
    let condition = true;
    let number = if condition { 5 } else { 6 };

    println!("The value of number is: {number}");
}
```

清單 3-2：將 `if` 表達式的結果賦值給變數

`number` 變數將根據 `if` 表達式的結果綁定到一個值。執行這段程式碼以查看會發生什麼：

```
$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/branches`
The value of number is: 5
```

請記住，程式碼區塊會評估為其中的最後一個表達式，而數字本身也是表達式。在這種情況下，整個 `if` 表達式的值取決於哪個程式碼區塊執行。這意味著每個 `if` 分支中可能產生的值必須是相同的型別；在清單 3-2 中，`if` 分支和 `else` 分支的結果都是 `i32` 整數。如果型別不匹配，如下例所示，我們將會得到一個錯誤：

檔案名稱：src/main.rs

```rust
fn main() {
    let condition = true;

    let number = if condition { 5 } else { "six" };

    println!("The value of number is: {number}");
}
```

當我們嘗試編譯這段程式碼時，我們會得到一個錯誤。`if` 和 `else` 分支的值型別不相容，Rust 會精確地指出在程式中哪裡找到問題：

```
$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
error[E0308]: `if` and `else` have incompatible types
 --> src/main.rs:4:44
  |
4 |     let number = if condition { 5 } else { "six" };
  |                                 -          ^^^^^ expected integer, found `&str`
  |                                 |
  |                                 expected because of this

For more information about this error, try `rustc --explain E0308`.
error: could not compile `branches` (bin "branches") due to 1 previous error
```

`if` 區塊中的表達式評估為整數，而 `else` 區塊中的表達式評估為字串。這將不起作用，因為變數必須具有單一型別，並且 Rust 需要在編譯時確定 `number` 變數的型別。知道 `number` 的型別可以讓編譯器驗證我們使用 `number` 的每個地方的型別都是有效的。如果 `number` 的型別僅在執行時確定，Rust 將無法做到這一點；如果編譯器必須追蹤任何變數的多個假設型別，它將會更複雜，並且對程式碼的保證也會減少。

### 使用迴圈重複執行 (Repetition with Loops)

重複執行一個程式碼區塊通常很有用。為此，Rust 提供了幾種*迴圈* (loops)，它們將重複執行迴圈主體內的程式碼直到結束，然後立即從頭開始。為了實驗迴圈，讓我們建立一個名為 *loops* 的新專案。

Rust 有三種迴圈：`loop`、`while` 和 `for`。讓我們逐一嘗試。

#### 使用 `loop` 重複程式碼 (Repeating Code with loop)

`loop` 關鍵字告訴 Rust 不斷重複執行一個程式碼區塊，直到你明確地告訴它停止為止。

例如，將你 *loops* 目錄中的 *src/main.rs* 檔案更改為以下內容：

檔案名稱：src/main.rs

```rust
fn main() {
    loop {
        println!("again!");
    }
}
```

當我們執行這個程式時，我們會看到 `again!` 不斷重複印出，直到我們手動停止程式。大多數終端機都支援 <kbd>ctrl</kbd>-<kbd>c</kbd> 鍵盤快捷鍵來中斷一個陷入連續迴圈的程式。試試看：

```
$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.08s
     Running `target/debug/loops`
again!
again!
again!
again!
^Cagain!
```

符號 `^C` 代表你按下 <kbd>ctrl</kbd>-<kbd>c</kbd> 的位置。

你可能會或可能不會在 `^C` 後面看到 `again!` 這個詞，這取決於程式碼在收到中斷訊號時在迴圈中的位置。

幸運的是，Rust 也提供了一種透過程式碼跳出迴圈的方法。你可以在迴圈內放置 `break` 關鍵字來告訴程式何時停止執行迴圈。回想一下，我們在[第二章](https://doc.rust-lang.org/book/ch02-00-guessing-game-tutorial.html)「[猜對後退出](https://doc.rust-lang.org/book/ch02-00-guessing-game-tutorial.html#quitting-after-a-correct-guess)」一節中的猜數字遊戲中這樣做，當使用者猜對數字贏得遊戲時退出程式。

我們也在猜數字遊戲中使用了 `continue`，它在迴圈中告訴程式跳過這次迴圈迭代中所有剩餘的程式碼，並進入下一次迭代。

#### 從迴圈回傳值 (Returning Values from Loops)

`loop` 的其中一個用途是重試你可能知道會失敗的操作，例如檢查執行緒是否已完成其工作。你可能還需要將該操作的結果從迴圈中傳遞給程式碼的其餘部分。為此，你可以在用於停止迴圈的 `break` 表達式後添加你想要回傳的值；該值將從迴圈中回傳，以便你可以使用它，如下所示：

```rust
fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    println!("The result is {result}");
}
```

在迴圈之前，我們宣告一個名為 `counter` 的變數並將其初始化為 `0`。然後我們宣告一個名為 `result` 的變數來儲存從迴圈回傳的值。在迴圈的每次迭代中，我們將 `1` 加到 `counter` 變數中，然後檢查 `counter` 是否等於 `10`。當它等於 `10` 時，我們使用 `break` 關鍵字和值 `counter * 2`。在迴圈之後，我們使用分號來結束將值賦值給 `result` 的陳述式。最後，我們印出 `result` 中的值，在這個例子中是 `20`。

你也可以從迴圈內部 `return`。雖然 `break` 只會退出目前的迴圈，但 `return` 總是會退出目前的函數。

#### 迴圈標籤以區分多個迴圈 (Loop Labels to Disambiguate Between Multiple Loops)

如果你的迴圈中還有迴圈，那麼 `break` 和 `continue` 將作用於當時最內層的迴圈。你可以選擇在迴圈上指定一個*迴圈標籤* (loop label)，然後你可以搭配 `break` 或 `continue` 使用該標籤，以指定這些關鍵字作用於該標籤所指的迴圈，而不是最內層的迴圈。迴圈標籤必須以單引號開頭。以下是一個包含兩個巢狀迴圈的範例：

```rust
fn main() {
    let mut count = 0;
    'counting_up: loop {
        println!("count = {count}");
        let mut remaining = 10;

        loop {
            println!("remaining = {remaining}");
            if remaining == 9 {
                break;
            }
            if count == 2 {
                break 'counting_up;
            }
            remaining -= 1;
        }

        count += 1;
    }
    println!("End count = {count}");
}
```

外層迴圈有標籤 `'counting_up`，它將從 0 數到 2。不帶標籤的內層迴圈從 10 倒數到 9。第一個沒有指定標籤的 `break` 只會退出內層迴圈。`break 'counting_up;` 陳述式將退出外層迴圈。這段程式碼印出：

```
$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.58s
     Running `target/debug/loops`
count = 0
remaining = 10
remaining = 9
count = 1
remaining = 10
remaining = 9
count = 2
remaining = 10
End count = 2
```

#### 使用 `while` 進行條件式迴圈 (Conditional Loops with while)

程式經常需要在迴圈中評估一個條件。當條件為 `true` 時，迴圈執行。當條件不再為 `true` 時，程式呼叫 `break`，停止迴圈。使用 `loop`、`if`、`else` 和 `break` 的組合可以實現這種行為；如果你願意，你現在就可以在程式中嘗試。然而，這種模式非常常見，以至於 Rust 有一個內建的語言結構，稱為 `while` 迴圈。在清單 3-3 中，我們使用 `while` 迴圈三次，每次倒數，然後在迴圈結束後，印出一條訊息並退出。

src/main.rs

```rust
fn main() {
    let mut number = 3;

    while number != 0 {
        println!("{number}!");

        number -= 1;
    }

    println!("LIFTOFF!!!");
}
```

清單 3-3：使用 `while` 迴圈在條件評估為 `true` 時執行程式碼

這個結構消除了使用 `loop`、`if`、`else` 和 `break` 所需的許多巢狀結構，並且它更清晰。當條件評估為 `true` 時，程式碼運行；否則，它會退出迴圈。

#### 使用 `for` 迴圈遍歷集合 (Looping Through a Collection with for)

你可以選擇使用 `while` 結構來遍歷集合（例如陣列）的元素。例如，清單 3-4 中的迴圈印出陣列 `a` 中的每個元素。

src/main.rs

```rust
fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut index = 0;

    while index < 5 {
        println!("the value is: {}", a[index]);

        index += 1;
    }
}
```

清單 3-4：使用 `while` 迴圈遍歷集合中的每個元素

在這裡，程式碼透過陣列中的元素進行計數。它從索引 `0` 開始，然後迴圈直到到達陣列中的最終索引（即當 `index < 5` 不再為 `true` 時）。執行這段程式碼將印出陣列中的每個元素：

```
$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.32s
     Running `target/debug/loops`
the value is: 10
the value is: 20
the value is: 30
the value is: 40
the value is: 50
```

所有五個陣列值都按預期出現在終端機中。儘管 `index` 在某個時候會達到 `5` 的值，但在嘗試從陣列中獲取第六個值之前，迴圈就停止執行了。

然而，這種方法容易出錯；如果索引值或測試條件不正確，我們可能會導致程式 panic。例如，如果你將陣列 `a` 的定義更改為四個元素，但忘記將條件更新為 `while index < 4`，程式碼將會 panic。它也很慢，因為編譯器會在迴圈的每次迭代中添加執行時程式碼來執行索引是否在陣列範圍內的條件檢查。

作為一種更簡潔的替代方案，你可以使用 `for` 迴圈並為集合中的每個項目執行一些程式碼。`for` 迴圈看起來像清單 3-5 中的程式碼。

src/main.rs

```rust
fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a {
        println!("the value is: {element}");
    }
}
```

清單 3-5：使用 `for` 迴圈遍歷集合中的每個元素

當我們執行這段程式碼時，我們將看到與清單 3-4 相同的輸出。更重要的是，我們現在提高了程式碼的安全性，並消除了可能因超出陣列末端或未能足夠遍歷而遺漏某些項目所導致的錯誤機會。從 `for` 迴圈產生的機器碼也可能更有效率，因為在每次迭代時不需要將索引與陣列長度進行比較。

使用 `for` 迴圈，如果你更改陣列中的值數量，則無需記住更改任何其他程式碼，就像你在清單 3-4 中使用的方法那樣。

`for` 迴圈的安全性和簡潔性使其成為 Rust 中最常用的迴圈結構。即使在你想要執行某些程式碼特定次數的情況下，例如在清單 3-3 中使用 `while` 迴圈的倒數範例，大多數 Rustaceans 也會使用 `for` 迴圈。這樣做的方法是使用標準函式庫提供的 `Range`，它會產生從一個數字開始到另一個數字之前的所有連續數字。

以下是使用 `for` 迴圈和我們尚未討論的另一個方法 `rev` 來反轉範圍的倒數範例：

檔案名稱：src/main.rs

```rust
fn main() {
    for number in (1..4).rev() {
        println!("{number}!");
    }
    println!("LIFTOFF!!!");
}
```

這段程式碼是不是更好一些？

## 總結 (Summary)

你成功了！這是一個內容豐富的章節：你學習了變數、純量和複合資料型別、函數、註解、`if` 表達式和迴圈！為了練習本章討論的概念，請嘗試建立程式來執行以下任務：

*   在華氏和攝氏之間轉換溫度。
*   產生第 *n* 個費波那契數列。
*   印出聖誕頌歌「十二聖誕日」的歌詞，利用歌曲中的重複部分。

當你準備好繼續時，我們將討論 Rust 中一個不常見於其他程式語言的概念：所有權 (ownership)。