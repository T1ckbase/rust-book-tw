<!-- DO NOT EDIT THIS FILE.

This file is periodically generated from the content in the `/src/`
directory, so all fixes need to be made in `/src/`.
-->

[TOC]

# 常見的程式設計概念

本章節涵蓋了幾乎所有程式語言中都會出現的概念，以及它們在 Rust 中如何運作。許多程式語言的核心有很多共通之處。本章介紹的概念都不是 Rust 獨有的，但我們將在 Rust 的脈絡下討論它們，並解釋使用這些概念時的慣例。

具體來說，你將學習變數、基本型別、函式、註解和控制流程。這些基礎知識將會出現在每個 Rust 程式中，及早學習它們將為你打下堅實的基礎。

> #### 關鍵字
>
> Rust 語言有一組_關鍵字_，跟其他語言一樣，這些關鍵字是保留給語言本身使用的。請記住，你不能用這些字詞作為變數或函式的名稱。大多數關鍵字都有特殊意義，你將會用它們來在你的 Rust 程式中執行各種任務；少數關鍵字目前沒有與之相關的功能，但是為了未來可能加入 Rust 的功能而被保留。你可以在附錄 A 中找到關鍵字列表。

## 變數與可變性

如同在「用變數儲存值」章節中提到的，變數預設是 immutable 的。這是 Rust 為了讓你寫出能利用其安全性和易於並行性的程式碼而提供的眾多提示之一。然而，你仍然可以選擇讓你的變數成為 mutable。讓我們來探討 Rust 如何以及為何鼓勵你偏好 immutability，以及為什麼有時候你可能會想選擇不這麼做。

當一個變數是 immutable 時，一旦一個值被綁定到一個名稱上，你就不能改變那個值。為了說明這一點，請在你的 _projects_ 目錄中使用 `cargo new variables` 來產生一個名為 _variables_ 的新專案。

然後，在你的新 _variables_ 目錄中，打開 _src/main.rs_ 並將其程式碼替換為以下程式碼，這段程式碼目前還無法編譯：

檔案名稱：src/main.rs

```rust
fn main() {
    let x = 5;
    println!("The value of x is: {x}");
    x = 6;
    println!("The value of x is: {x}");
}
```

儲存並使用 `cargo run` 執行程式。你應該會收到一則關於 immutability 錯誤的訊息，如下方輸出所示：

```
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0384]: cannot assign twice to immutable variable `x`
 --> src/main.rs:4:5
  |
2 |     let x = 5;
  |         - first assignment to `x`
3 |     println!("The value of x is: {x}");
4 |     x = 6;
  |     ^^^^^ cannot assign twice to immutable variable
  |
help: consider making this binding mutable
  |
2 |     let mut x = 5;
  |         +++

For more information about this error, try `rustc --explain E0384`.
error: could not compile `variables` (bin "variables") due to 1 previous error
```

這個範例展示了編譯器如何幫助你在程式中找出錯誤。編譯器錯誤可能令人沮喪，但它們實際上只表示你的程式還沒有安全地執行你想要的功能；它們*不*代表你不是個好程式設計師！有經驗的 Rustacean 們仍然會遇到編譯器錯誤。

你收到了 `` cannot assign twice to immutable variable `x` `` 的錯誤訊息，因為你試圖將第二個值賦予 immutable 的 `x` 變數。

當我們試圖改變一個被指定為 immutable 的值時，能在編譯時期得到錯誤是很重要的，因為這種情況很容易導致 bug。如果我們程式碼的一部分是基於某個值永遠不會改變的假設下運作，而另一部分程式碼卻改變了那個值，那麼第一部分的程式碼可能就無法如預期般運作。這類 bug 的原因事後很難追查，特別是當第二段程式碼只在*某些時候*才改變值。Rust 編譯器保證，當你宣告一個值不會改變時，它就真的不會改變，所以你不需要自己去追蹤。因此，你的程式碼也更容易推理。

但 mutability 非常有用，而且可以讓程式碼寫起來更方便。雖然變數預設是 immutable 的，但你可以在變數名稱前加上 `mut` 使其成為 mutable，就像你在第 2 章做的那樣。加上 `mut` 也向未來閱讀程式碼的人傳達了意圖，表示程式碼的其他部分將會改變這個變數的值。

例如，讓我們將 _src/main.rs_ 改成以下內容：

檔案名稱：src/main.rs

```rust
fn main() {
    let mut x = 5;
    println!("The value of x is: {x}");
    x = 6;
    println!("The value of x is: {x}");
}
```

當我們現在執行程式時，會得到以下結果：

```
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/variables`
The value of x is: 5
The value of x is: 6
```

當使用 `mut` 時，我們就可以將綁定到 `x` 的值從 `5` 改為 `6`。最終，決定是否使用 mutability 取決於你，以及你認為在特定情況下什麼樣的寫法最清晰。

### 常數

就像 immutable 變數一樣，*常數*是綁定到一個名稱且不允許改變的值，但常數和變數之間有幾個差異。

首先，你不能對常數使用 `mut`。常數不只是預設 immutable——它們永遠都是 immutable。你使用 `const` 關鍵字而不是 `let` 關鍵字來宣告常數，而且值的型別*必須*被標註。我們將在下一節「資料型別」中涵蓋型別和型別標註，所以現在不用擔心細節。只要知道你必須永遠標註型別。

常數可以在任何 scope 中宣告，包含全域 scope，這使得它們對於程式碼中許多部分都需要知道的值很有用。

最後一個差異是，常數只能被設定為一個常數表達式，而不能是只能在 runtime 計算出來的值的結果。

以下是一個常數宣告的範例：

```rust
const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
```

常數的名稱是 `THREE_HOURS_IN_SECONDS`，它的值被設定為 60（一分鐘的秒數）乘以 60（一小時的分鐘數）再乘以 3（我們在這個程式中想要計算的小時數）的結果。Rust 對常數的命名慣例是使用全大寫字母，並用底線分隔單字。編譯器能夠在編譯時期評估一組有限的操作，這讓我們可以選擇用一種更容易理解和驗證的方式來寫出這個值，而不是直接將這個常數設定為 10,800。關於宣告常數時可以使用哪些操作的更多資訊，請參閱 Rust Reference 中關於常數評估的章節：_https://doc.rust-lang.org/reference/const_eval.html_。

常數在其宣告的 scope 內，於程式運行的整個期間都有效。這個特性使得常數對於應用程式領域中，需要讓程式多個部分知道的值非常有用，例如遊戲中任何玩家允許獲得的最高分數，或是光速。

將整個程式中使用的硬編碼值命名為常數，有助於向未來的程式碼維護者傳達該值的意義。如果未來需要更新這個硬編碼值，這樣也只需要在程式碼中的一個地方進行修改。

### Shadowing

如同你在第 2 章的猜數字遊戲教學中所見，你可以宣告一個與先前變數同名的新變數。Rustacean 們會說第一個變數被第二個變數 _shadowed_ 了，這意味著當你使用該變數名稱時，編譯器看到的是第二個變數。實際上，第二個變數遮蓋了第一個變數，任何對該變數名稱的使用都會指向它自己，直到它本身被另一個變數 shadowed，或是 scope 結束。我們可以使用相同的變數名稱並重複使用 `let` 關鍵字來 shadow 一個變數，如下所示：

檔案名稱：src/main.rs

```rust
fn main() {
    let x = 5;

    let x = x + 1;

    {
        let x = x * 2;
        println!("The value of x in the inner scope is: {x}");
    }

    println!("The value of x is: {x}");
}
```

這個程式首先將 `x` 綁定到值 `5`。然後它透過重複 `let x =` 來建立一個新的變數 `x`，取用原始值並加上 `1`，所以 `x` 的值變為 `6`。接著，在一個用大括號建立的內部 scope 中，第三個 `let` 陳述式也 shadows `x` 並建立一個新變數，將前一個值乘以 `2`，使 `x` 的值變為 `12`。當那個 scope 結束時，內部的 shadowing 也結束，`x` 的值回到 `6`。當我們執行這個程式時，它將輸出以下內容：

```
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/variables`
The value of x in the inner scope is: 12
The value of x is: 6
```

Shadowing 與將變數標記為 `mut` 不同，因為如果我們不小心在沒有使用 `let` 關鍵字的情況下試圖重新賦值給這個變數，我們會得到一個編譯時期錯誤。透過使用 `let`，我們可以對一個值進行一些轉換，但在這些轉換完成後，該變數會是 immutable 的。

`mut` 和 shadowing 的另一個區別是，因為當我們再次使用 `let` 關鍵字時，我們實際上是在建立一個新變數，所以我們可以改變值的型別，但重複使用相同的名稱。例如，假設我們的程式要求使用者輸入空格字元來表示他們想要在某些文字之間有多少空格，然後我們想將該輸入儲存為一個數字：

```rust
let spaces = "   ";
let spaces = spaces.len();
```

第一個 `spaces` 變數是字串型別，而第二個 `spaces` 變數是數字型別。因此，shadowing 讓我們免於想出不同的名稱，例如 `spaces_str` 和 `spaces_num`；相反地，我們可以重複使用更簡單的 `spaces` 名稱。然而，如果我們試圖對此使用 `mut`，如下所示，我們會得到一個編譯時期錯誤：

```rust
let mut spaces = "   ";
spaces = spaces.len();
```

錯誤訊息表示我們不允許改變一個變數的型別：

```
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0308]: mismatched types
 --> src/main.rs:3:14
  |
2 |     let mut spaces = "   ";
  |                      ----- expected due to this value
3 |     spaces = spaces.len();
  |              ^^^^^^^^^^^^ expected `&str`, found `usize`

For more information about this error, try `rustc --explain E0308`.
error: could not compile `variables` (bin "variables") due to 1 previous error
```

現在我們已經探討了變數的運作方式，讓我們來看看它們可以擁有的更多資料型別。

## 資料型別

在 Rust 中，每個值都有一個特定的_資料型別_，它告訴 Rust 正在指定哪種資料，以便它知道如何處理該資料。我們將探討兩個資料型別子集：scalar 和 compound。

請記住，Rust 是一種*靜態型別*語言，這意味著它必須在編譯時期知道所有變數的型別。編譯器通常可以根據值以及我們如何使用它來推斷我們想要使用的型別。在有多種可能型別的情況下，例如在第 2 章「比較猜測值與祕密數字」一節中，我們使用 `parse` 將 `String` 轉換為數字型別時，我們必須加上型別標註，像這樣：

```rust
let guess: u32 = "42".parse().expect("Not a number!");
```

如果我們不加上述程式碼中顯示的 `: u32` 型別標註，Rust 將會顯示以下錯誤，這表示編譯器需要我們提供更多資訊，才能知道我們想使用哪種型別：

```
$ cargo build
   Compiling no_type_annotations v0.1.0 (file:///projects/no_type_annotations)
error[E0284]: type annotations needed
 --> src/main.rs:2:9
  |
2 |     let guess = "42".parse().expect("Not a number!");
  |         ^^^^^        ----- type must be known at this point
  |
  = note: cannot satisfy `<_ as FromStr>::Err == _`
help: consider giving `guess` an explicit type
  |
2 |     let guess: /* Type */ = "42".parse().expect("Not a number!");
  |              ++++++++++++

For more information about this error, try `rustc --explain E0284`.
error: could not compile `no_type_annotations` (bin "no_type_annotations") due to 1 previous error
```

對於其他資料型別，你會看到不同的型別標註。

### Scalar 型別

_scalar_ 型別代表單一值。Rust 有四種主要的 scalar 型別：整數、浮點數、布林值和字元。你可能從其他程式語言中認得這些型別。讓我們來看看它們在 Rust 中是如何運作的。

#### 整數型別

*整數*是沒有小數部分的數字。我們在第 2 章中使用了一種整數型別，即 `u32` 型別。這個型別宣告表示與其相關聯的值應該是一個無符號整數（有符號整數型別以 `i` 開頭，而不是 `u`），佔用 32 位元的空間。表 3-1 顯示了 Rust 內建的整數型別。我們可以使用這些變體中的任何一種來宣告整數值的型別。

表 3-1：Rust 中的整數型別

| 長度     | 有符號  | 無符號  |
| -------- | ------- | ------- |
| 8-bit    | `i8`    | `u8`    |
| 16-bit   | `i16`   | `u16`   |
| 32-bit   | `i32`   | `u32`   |
| 64-bit   | `i64`   | `u64`   |
| 128-bit  | `i128`  | `u128`  |
| 依賴架構 | `isize` | `usize` |

每個變體可以是有符號或無符號，並且有明確的大小。*有符號*和*無符號*指的是數字是否可能為負數——換句話說，數字是否需要帶有符號（有符號），或者它是否永遠只會是正數，因此可以用無符號表示（無符號）。這就像在紙上寫數字一樣：當符號很重要時，數字會用正號或負號表示；然而，當可以安全地假設數字是正數時，它就沒有符號。有符號數字是使用二補數表示法儲存的。

每個有符號變體可以儲存從 −(2<sup>n − 1</sup>) 到 2<sup>n − 1</sup> − 1（包含邊界）的數字，其中 _n_ 是該變體使用的位元數。所以一個 `i8` 可以儲存從 −(2<sup>7</sup>) 到 2<sup>7</sup> − 1 的數字，也就是 −128 到 127。無符號變體可以儲存從 0 到 2<sup>n</sup> − 1 的數字，所以一個 `u8` 可以儲存從 0 到 2<sup>8</sup> − 1 的數字，也就是 0 到 255。

此外，`isize` 和 `usize` 型別取決於你的程式所執行的電腦架構：如果你在 64 位元架構上，它們是 64 位元；如果你在 32 位元架構上，它們是 32 位元。

你可以用表 3-2 中所示的任何形式來書寫整數常值。請注意，可以是多種數字型別的數字常值允許加上型別後綴，例如 `57u8`，來指定型別。數字常值也可以使用 `_` 作為視覺分隔符，使數字更容易閱讀，例如 `1_000`，其值與 `1000` 相同。

表 3-2：Rust 中的整數常值

| 數字常值           | 範例          |
| ------------------ | ------------- |
| 十進位             | `98_222`      |
| 十六進位           | `0xff`        |
| 八進位             | `0o77`        |
| 二進位             | `0b1111_0000` |
| 位元組 (`u8` only) | `b'A'`        |

那麼，你該如何知道要使用哪種整數型別呢？如果你不確定，Rust 的預設值通常是個好的起點：整數型別預設為 `i32`。你會使用 `isize` 或 `usize` 的主要情況是對某種集合進行索引時。

> ##### 整數溢位
>
> 假設你有一個 `u8` 型別的變數，它可以容納 0 到 255 之間的值。如果你試圖將該變數更改為超出該範圍的值，例如 256，就會發生_整數溢位_，這可能導致兩種行為之一。當你在 debug 模式下編譯時，Rust 會包含整數溢位檢查，如果發生這種行為，會導致你的程式在 runtime 時 _panic_。當程式因錯誤而退出時，Rust 使用 _panicking_ 這個術語；我們將在第 9 章的「使用 `panic!` 處理不可恢復的錯誤」一節中更深入地討論 panic。
>
> 當你使用 `--release` 旗標在 release 模式下編譯時，Rust *不*包含會導致 panic 的整數溢位檢查。相反地，如果發生溢位，Rust 會執行_二補數環繞_。簡而言之，大於該型別所能容納的最大值會「環繞」到該型別所能容納的最小值。以 `u8` 為例，值 256 會變成 0，值 257 會變成 1，依此類推。程式不會 panic，但變數的值可能不是你所期望的。依賴整數溢位的環繞行為被視為一種錯誤。
>
> 為了明確地處理溢位的可能性，你可以使用標準函式庫為基本數字型別提供的這些方法家族：
>
> - 使用 `wrapping_*` 方法在所有模式下進行環繞，例如 `wrapping_add`。
> - 如果發生溢位，使用 `checked_*` 方法回傳 `None` 值。
> - 使用 `overflowing_*` 方法回傳值和一個布林值，表示是否發生溢位。
> - 使用 `saturating_*` 方法將值飽和到其最小值或最大值。

#### 浮點數型別

Rust 也有兩種*浮點數*的基本型別，也就是帶有小數點的數字。Rust 的浮點數型別是 `f32` 和 `f64`，分別是 32 位元和 64 位元的大小。預設型別是 `f64`，因為在現代 CPU 上，它的速度與 `f32` 大致相同，但能提供更高的精確度。所有浮點數型別都是有符號的。

以下是一個展示浮點數運作的範例：

檔案名稱：src/main.rs

```rust
fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}
```

浮點數是根據 IEEE-754 標準表示的。

#### 數值運算

Rust 支援所有數字型別預期會有的基本數學運算：加法、減法、乘法、除法和餘數。整數除法會向零捨去到最接近的整數。以下程式碼展示了如何在 `let` 陳述式中使用每種數值運算：

檔案名稱：src/main.rs

```rust
fn main() {
    // addition
    let sum = 5 + 10;

    // subtraction
    let difference = 95.5 - 4.3;

    // multiplication
    let product = 4 * 30;

    // division
    let quotient = 56.7 / 32.2;
    let truncated = -5 / 3; // Results in -1

    // remainder
    let remainder = 43 % 5;
}
```

這些陳述式中的每個表達式都使用一個數學運算子並評估為單一值，然後綁定到一個變數上。附錄 B 包含了 Rust 提供的所有運算子列表。

#### 布林型別

如同大多數其他程式語言一樣，Rust 中的布林型別有兩個可能的值：`true` 和 `false`。布林值的大小為一個位元組。Rust 中的布林型別使用 `bool` 指定。例如：

檔案名稱：src/main.rs

```rust
fn main() {
    let t = true;

    let f: bool = false; // with explicit type annotation
}
```

使用布林值的主要方式是透過條件式，例如 `if` 表達式。我們將在「控制流程」一節中介紹 `if` 表達式在 Rust 中的運作方式。

#### 字元型別

Rust 的 `char` 型別是該語言最基本的字母型別。以下是一些宣告 `char` 值的範例：

檔案名稱：src/main.rs

```rust
fn main() {
    let c = 'z';
    let z: char = 'ℤ'; // with explicit type annotation
    let heart_eyed_cat = '😻';
}
```

請注意，我們用單引號指定 `char` 常值，而字串常值則使用雙引號。Rust 的 `char` 型別大小為四個位元組，代表一個 Unicode 純量值，這意味著它可以表示的遠不止是 ASCII。帶重音的字母、中文、日文和韓文字元、表情符號以及零寬度空格都是 Rust 中有效的 `char` 值。Unicode 純量值的範圍從 `U+0000` 到 `U+D7FF` 以及 `U+E000` 到 `U+10FFFF`（包含邊界）。然而，「字元」在 Unicode 中並不是一個真正的概念，所以你對「字元」的人類直覺可能與 Rust 中的 `char` 不符。我們將在第 8 章的「使用字串儲存 UTF-8 編碼的文字」中詳細討論這個主題。

### Compound 型別

*Compound 型別*可以將多個值組合成一個型別。Rust 有兩種基本的 compound 型別：tuple 和 array。

#### Tuple 型別

_tuple_ 是一種將多個不同型別的值組合成一個 compound 型別的通用方法。Tuple 的長度是固定的：一旦宣告，它們的大小就不能增長或縮小。

我們透過在括號內寫入一個以逗號分隔的值列表來建立一個 tuple。Tuple 中的每個位置都有一個型別，而 tuple 中不同值的型別不必相同。我們在這個範例中加入了可選的型別標註：

檔案名稱：src/main.rs

```rust
fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
```

變數 `tup` 綁定到整個 tuple，因為 tuple 被視為一個單一的 compound 元素。要從 tuple 中取出個別的值，我們可以使用模式匹配來解構一個 tuple 值，像這樣：

檔案名稱：src/main.rs

```rust
fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!("The value of y is: {y}");
}
```

這個程式首先建立一個 tuple 並將它綁定到變數 `tup`。然後它使用帶有 `let` 的模式將 `tup` 分解成三個獨立的變數 `x`、`y` 和 `z`。這被稱為_解構_，因為它將單一的 tuple 分解成三個部分。最後，程式印出 `y` 的值，也就是 `6.4`。

我們也可以使用句點 (`.`) 後面跟著我們想存取的值的索引，來直接存取 tuple 的元素。例如：

檔案名稱：src/main.rs

```rust
fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}
```

這個程式建立 tuple `x`，然後使用它們各自的索引來存取 tuple 的每個元素。如同大多數程式語言一樣，tuple 的第一個索引是 0。

沒有任何值的 tuple 有一個特殊的名稱，_unit_。這個值和它對應的型別都寫作 `()`，代表一個空值或一個空的回傳型別。如果表達式不回傳任何其他值，它們會隱含地回傳 unit 值。

#### Array 型別

另一種擁有多個值的集合的方式是_array_。與 tuple 不同，array 的每個元素都必須是相同型別。與某些其他語言的 array 不同，Rust 中的 array 長度是固定的。

我們將 array 中的值寫成一個在方括號內的逗號分隔列表：

檔案名稱：src/main.rs

```rust
fn main() {
    let a = [1, 2, 3, 4, 5];
}
```

當你希望你的資料配置在 stack 上，而不是 heap 上時（我們將在第 4 章更詳細地討論 stack 和 heap），或者當你想要確保你總是有固定數量的元素時，array 很有用，就像我們目前看到的所有其他型別一樣。不過，array 不如 vector 型別靈活。_vector_ 是由標準函式庫提供的類似集合型別，它*是*允許增長或縮小大小的，因為它的內容存放在 heap 上。如果你不確定要使用 array 還是 vector，那麼你很可能應該使用 vector。第 8 章會更詳細地討論 vector。

然而，當你知道元素數量不需要改變時，array 更為有用。例如，如果你在程式中使用月份的名稱，你可能會使用 array 而不是 vector，因為你知道它總是包含 12 個元素：

```rust
let months = ["January", "February", "March", "April", "May", "June", "July",
              "August", "September", "October", "November", "December"];
```

你可以使用方括號來寫 array 的型別，裡面包含每個元素的型別、一個分號，然後是 array 中的元素數量，像這樣：

```rust
let a: [i32; 5] = [1, 2, 3, 4, 5];
```

這裡，`i32` 是每個元素的型別。分號後面的數字 `5` 表示這個 array 包含五個元素。

你也可以初始化一個 array，讓每個元素都包含相同的值，方法是指定初始值，後面跟著一個分號，然後在方括號中指定 array 的長度，如下所示：

```rust
let a = [3; 5];
```

名為 `a` 的 array 將包含 `5` 個元素，它們的初始值都將被設定為 `3`。這與寫 `let a = [3, 3, 3, 3, 3];` 相同，但更簡潔。

##### 存取 Array 元素

array 是一個已知、固定大小的單一記憶體區塊，可以配置在 stack 上。你可以使用索引來存取 array 的元素，像這樣：

檔案名稱：src/main.rs

```rust
fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}
```

在這個範例中，名為 `first` 的變數將得到值 `1`，因為那是 array 中索引 `[0]` 的值。名為 `second` 的變數將從 array 的索引 `[1]` 得到值 `2`。

##### 無效的 Array 元素存取

讓我們看看如果你試圖存取一個超出 array 結尾的元素會發生什麼事。假設你執行這段程式碼，類似於第 2 章的猜數字遊戲，從使用者那裡取得一個 array 索引：

檔案名稱：src/main.rs

```rust
use std::io;

fn main() {
    let a = [1, 2, 3, 4, 5];

    println!("Please enter an array index.");

    let mut index = String::new();

    io::stdin()
        .read_line(&mut index)
        .expect("Failed to read line");

    let index: usize = index
        .trim()
        .parse()
        .expect("Index entered was not a number");

    let element = a[index];

    println!("The value of the element at index {index} is: {element}");
}
```

這段程式碼可以成功編譯。如果你使用 `cargo run` 執行這段程式碼並輸入 `0`、`1`、`2`、`3` 或 `4`，程式將會印出 array 中該索引對應的值。如果你輸入一個超出 array 結尾的數字，例如 `10`，你會看到像這樣的輸出：

<!-- manual-regeneration
cd listings/ch03-common-programming-concepts/no-listing-15-invalid-array-access
cargo run
10
-->

```
thread 'main' panicked at src/main.rs:19:19:
index out of bounds: the len is 5 but the index is 10
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```

程式在使用無效值進行索引操作時，發生了*runtime*錯誤。程式以錯誤訊息退出，並且沒有執行最後的 `println!` 陳述式。當你嘗試使用索引存取元素時，Rust 會檢查你指定的索引是否小於 array 的長度。如果索引大於或等於長度，Rust 將會 panic。這個檢查必須在 runtime 進行，特別是在這種情況下，因為編譯器不可能知道使用者在稍後執行程式碼時會輸入什麼值。

這是 Rust 記憶體安全原則的一個實例。在許多低階語言中，這種檢查是不會做的，當你提供一個不正確的索引時，可能會存取到無效的記憶體。Rust 透過立即退出而不是允許記憶體存取並繼續執行，來保護你免於這類錯誤。第 9 章將討論更多 Rust 的錯誤處理，以及如何編寫既不會 panic 也不會允許無效記憶體存取的可讀、安全程式碼。

## 函式

函式在 Rust 程式碼中很普遍。你已經見過語言中最重要的函式之一：`main` 函式，它是許多程式的進入點。你也見過 `fn` 關鍵字，它允許你宣告新的函式。

Rust 程式碼使用 _snake case_ 作為函式和變數名稱的慣例風格，其中所有字母都是小寫，並用底線分隔單字。以下是一個包含範例函式定義的程式：

檔案名稱：src/main.rs

```rust
fn main() {
    println!("Hello, world!");

    another_function();
}

fn another_function() {
    println!("Another function.");
}
```

我們在 Rust 中定義函式是透過輸入 `fn`，後面跟著函式名稱和一組括號。大括號告訴編譯器函式主體的開始和結束位置。

我們可以透過輸入函式名稱後接一組括號來呼叫任何我們已定義的函式。因為 `another_function` 是在程式中定義的，所以可以從 `main` 函式內部呼叫它。請注意，我們在原始碼中將 `another_function` 定義在 `main` 函式_之後_；我們也可以將它定義在前面。Rust 不在乎你在哪裡定義函式，只要它們被定義在呼叫者可見的 scope 中即可。

讓我們開始一個名為 _functions_ 的新二進位專案來進一步探索函式。將 `another_function` 的範例放在 _src/main.rs_ 中並執行它。你應該會看到以下輸出：

```
$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.28s
     Running `target/debug/functions`
Hello, world!
Another function.
```

程式碼行是按照它們在 `main` 函式中出現的順序執行的。首先印出「Hello, world!」訊息，然後呼叫 `another_function` 並印出它的訊息。

### 參數

我們可以定義函式來擁有_參數_，它們是函式簽章的一部分的特殊變數。當函式有參數時，你可以為這些參數提供具體的值。技術上來說，具體的值被稱為 _arguments_，但在日常對話中，人們傾向於將 _parameter_ 和 _argument_ 這兩個詞互換使用，無論是指函式定義中的變數，還是指呼叫函式時傳入的具體值。

在這個版本的 `another_function` 中，我們新增了一個參數：

檔案名稱：src/main.rs

```rust
fn main() {
    another_function(5);
}

fn another_function(x: i32) {
    println!("The value of x is: {x}");
}
```

試著執行這個程式；你應該會得到以下輸出：

```
$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 1.21s
     Running `target/debug/functions`
The value of x is: 5
```

`another_function` 的宣告有一個名為 `x` 的參數。`x` 的型別被指定為 `i32`。當我們將 `5` 傳入 `another_function` 時，`println!` 巨集會將 `5` 放在格式化字串中包含 `x` 的那對大括號的位置。

在函式簽章中，你*必須*宣告每個參數的型別。這是 Rust 設計中的一個刻意決定：要求在函式定義中進行型別標註，意味著編譯器幾乎不需要你在程式碼的其他地方使用它們來弄清楚你指的是什麼型別。如果編譯器知道函式期望的型別，它也能提供更有幫助的錯誤訊息。

當定義多個參數時，用逗號分隔參數宣告，像這樣：

檔案名稱：src/main.rs

```rust
fn main() {
    print_labeled_measurement(5, 'h');
}

fn print_labeled_measurement(value: i32, unit_label: char) {
    println!("The measurement is: {value}{unit_label}");
}
```

這個範例建立了一個名為 `print_labeled_measurement` 的函式，它有兩個參數。第一個參數名為 `value`，是 `i32` 型別。第二個名為 `unit_label`，是 `char` 型別。然後函式會印出包含 `value` 和 `unit_label` 的文字。

讓我們試著執行這段程式碼。將你 _functions_ 專案的 _src/main.rs_ 檔案中的程式替換為前述範例，並使用 `cargo run` 執行它：

```
$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/functions`
The measurement is: 5h
```

因為我們呼叫函式時，將 `5` 作為 `value` 的值，並將 `'h'` 作為 `unit_label` 的值，所以程式輸出包含了這些值。

### Statements and Expressions

函式主體由一系列 statements 組成，並可選擇性地以一個 expression 結尾。到目前為止，我們所涵蓋的函式都沒有包含結尾的 expression，但你已經看過作為 statement 一部分的 expression。因為 Rust 是一個以 expression 為基礎的語言，所以理解這個區別非常重要。其他語言沒有相同的區別，所以讓我們來看看 statements 和 expressions 是什麼，以及它們的差異如何影響函式的主體。

- Statements 是執行某些操作且不回傳值的指令。
- Expressions 會評估並產生一個結果值。

讓我們看一些範例。

我們其實已經用過 statements 和 expressions 了。使用 `let` 關鍵字建立變數並賦值給它是一個 statement。在列表 3-1 中，`let y = 6;` 是一個 statement。

src/main.rs

```rust
fn main() {
    let y = 6;
}
```

列表 3-1：一個包含單一 statement 的 `main` 函式宣告

函式定義也是 statements；前面整個範例本身就是一個 statement。（如同我們下面會看到的，*呼叫*函式不是一個 statement。）

Statements 不會回傳值。因此，你不能將一個 `let` statement 賦值給另一個變數，就像以下程式碼試圖做的那樣；你會得到一個錯誤：

檔案名稱：src/main.rs

```rust
fn main() {
    let x = (let y = 6);
}
```

當你執行這個程式時，你得到的錯誤看起來像這樣：

```
$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
error: expected expression, found `let` statement
 --> src/main.rs:2:14
  |
2 |     let x = (let y = 6);
  |              ^^^
  |
  = note: only supported directly in conditions of `if` and `while` expressions

warning: unnecessary parentheses around assigned value
 --> src/main.rs:2:13
  |
2 |     let x = (let y = 6);
  |             ^         ^
  |
  = note: `#[warn(unused_parens)]` on by default
help: remove these parentheses
  |
2 -     let x = (let y = 6);
2 +     let x = let y = 6;
  |

warning: `functions` (bin "functions") generated 1 warning
error: could not compile `functions` (bin "functions") due to 1 previous error; 1 warning emitted
```

`let y = 6` statement 不回傳值，所以 `x` 沒有任何東西可以綁定。這與其他語言（如 C 和 Ruby）中的情況不同，在那些語言中，賦值會回傳賦值的值。在那些語言中，你可以寫 `x = y = 6`，讓 `x` 和 `y` 的值都為 `6`；在 Rust 中並非如此。

Expressions 會評估為一個值，並構成你在 Rust 中會寫的大部分其餘程式碼。考慮一個數學運算，例如 `5 + 6`，這是一個會評估為 `11` 的 expression。Expressions 可以是 statements 的一部分：在列表 3-1 中，statement `let y = 6;` 中的 `6` 是一個會評估為 `6` 的 expression。呼叫函式是一個 expression。呼叫巨集是一個 expression。用大括號建立的新 scope 區塊也是一個 expression，例如：

檔案名稱：src/main.rs

```rust
fn main() {
    let y = {
        let x = 3;
        x + 1
    };

    println!("The value of y is: {y}");
}
```

這個 expression：

```rust
{
    let x = 3;
    x + 1
}
```

是一個區塊，在這種情況下，它會評估為 `4`。這個值作為 `let` statement 的一部分被綁定到 `y`。請注意，`x + 1` 這一行的結尾沒有分號，這與你目前看到的大多數程式碼行不同。Expressions 不包含結尾的分號。如果你在一個 expression 的結尾加上分號，你會把它變成一個 statement，然後它就不會回傳值。在你接下來探索函式回傳值和 expressions 時，請記住這一點。

### 帶有回傳值的函式

函式可以回傳值給呼叫它們的程式碼。我們不為回傳值命名，但我們必須在一個箭頭 (`->`) 後面宣告它們的型別。在 Rust 中，函式的回傳值等同於函式主體區塊中最後一個 expression 的值。你可以使用 `return` 關鍵字並指定一個值來提早從函式中回傳，但大多數函式會隱含地回傳最後一個 expression。以下是一個回傳值的函式範例：

檔案名稱：src/main.rs

```rust
fn five() -> i32 {
    5
}

fn main() {
    let x = five();

    println!("The value of x is: {x}");
}
```

在 `five` 函式中沒有函式呼叫、巨集，甚至沒有 `let` statements——只有數字 `5` 本身。這在 Rust 中是一個完全有效的函式。請注意，函式的回傳型別也被指定為 `-> i32`。試著執行這段程式碼；輸出應該看起來像這樣：

```
$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/functions`
The value of x is: 5
```

`five` 中的 `5` 是函式的回傳值，這就是為什麼回傳型別是 `i32`。讓我們更詳細地檢視一下。有兩個重要的部分：首先，`let x = five();` 這一行顯示我們正在使用函式的回傳值來初始化一個變數。因為函式 `five` 回傳 `5`，所以這一行等同於以下這行：

```rust
let x = 5;
```

其次，`five` 函式沒有參數並定義了回傳值的型別，但函式的主體是一個孤單的 `5`，沒有分號，因為它是一個我們想要回傳其值的 expression。

讓我們看另一個範例：

檔案名稱：src/main.rs

```rust
fn main() {
    let x = plus_one(5);

    println!("The value of x is: {x}");
}

fn plus_one(x: i32) -> i32 {
    x + 1
}
```

執行這段程式碼將會印出 `The value of x is: 6`。但如果我們在包含 `x + 1` 的那一行結尾加上分號，將它從一個 expression 變成一個 statement，我們將會得到一個錯誤：

檔案名稱：src/main.rs

```rust
fn main() {
    let x = plus_one(5);

    println!("The value of x is: {x}");
}

fn plus_one(x: i32) -> i32 {
    x + 1;
}
```

編譯這段程式碼會產生一個錯誤，如下所示：

```
$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
error[E0308]: mismatched types
 --> src/main.rs:7:24
  |
7 | fn plus_one(x: i32) -> i32 {
  |    --------            ^^^ expected `i32`, found `()`
  |    |
  |    implicitly returns `()` as its body has no tail or `return` expression
8 |     x + 1;
  |          - help: remove this semicolon to return this value

For more information about this error, try `rustc --explain E0308`.
error: could not compile `functions` (bin "functions") due to 1 previous error
```

主要的錯誤訊息 `mismatched types` 揭示了這段程式碼的核心問題。函式 `plus_one` 的定義說它將回傳一個 `i32`，但是 statements 不會評估為一個值，這由 `()`（unit 型別）表示。因此，沒有任何東西被回傳，這與函式定義相矛盾，並導致錯誤。在這個輸出中，Rust 提供了一條訊息可能可以幫助修正這個問題：它建議移除分號，這樣就可以修正錯誤。

## 註解

所有程式設計師都努力使他們的程式碼易於理解，但有時需要額外的解釋。在這些情況下，程式設計師會在他們的原始碼中留下_註解_，編譯器會忽略這些註解，但閱讀原始碼的人可能會覺得有用。

這是一個簡單的註解：

```rust
// hello, world
```

在 Rust 中，慣用的註解風格是以兩個斜線開始註解，註解會持續到該行的結尾。對於超過一行的註解，你需要在每一行都包含 `//`，像這樣：

```rust
// So we're doing something complicated here, long enough that we need
// multiple lines of comments to do it! Whew! Hopefully, this comment will
// explain what's going on.
```

註解也可以放在包含程式碼的行的末尾：

檔案名稱：src/main.rs

```rust
fn main() {
    let lucky_number = 7; // I'm feeling lucky today
}
```

但你更常會看到它們以這種格式使用，註解在它所標註的程式碼的上方，佔用單獨的一行：

檔案名稱：src/main.rs

```rust
fn main() {
    // I'm feeling lucky today
    let lucky_number = 7;
}
```

Rust 還有另一種註解，文件註解，我們將在第 14 章的「發布一個 crate 到 Crates.io」一節中討論。

## 控制流程

根據條件是否為 `true` 來執行某些程式碼，以及在條件為 `true` 時重複執行某些程式碼的能力，是大多數程式語言中的基本建構塊。讓你控制 Rust 程式碼執行流程的最常見結構是 `if` expressions 和 loops。

### `if` Expressions

一個 `if` expression 允許你根據條件來分支你的程式碼。你提供一個條件然後陳述：「如果這個條件滿足，就執行這段程式碼。如果條件不滿足，就不執行這段程式碼。」

在你的 _projects_ 目錄中建立一個名為 _branches_ 的新專案來探索 `if` expression。在 _src/main.rs_ 檔案中，輸入以下內容：

檔案名稱：src/main.rs

```rust
fn main() {
    let number = 3;

    if number < 5 {
        println!("condition was true");
    } else {
        println!("condition was false");
    }
}
```

所有 `if` expressions 都以關鍵字 `if` 開始，後面跟著一個條件。在這種情況下，條件檢查變數 `number` 的值是否小於 5。我們將在條件為 `true` 時要執行的程式碼區塊放在條件之後的大括號內。與 `if` expressions 中條件相關聯的程式碼區塊有時被稱為_分支 (arms)_，就像我們在第 2 章「比較猜測值與祕密數字」一節中討論的 `match` expressions 中的分支一樣。

可選地，我們也可以包含一個 `else` expression，就像我們在這裡所做的，來提供程式在條件評估為 `false` 時執行的替代程式碼區塊。如果你不提供 `else` expression 且條件為 `false`，程式將只會跳過 `if` 區塊，繼續執行下一段程式碼。

試著執行這段程式碼；你應該會看到以下輸出：

```
$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
condition was true
```

讓我們試著將 `number` 的值改成一個會讓條件變為 `false` 的值，看看會發生什麼事：

```rust
let number = 7;
```

再次執行程式，並查看輸出：

```
$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
condition was false
```

還值得注意的是，這段程式碼中的條件*必須*是一個 `bool`。如果條件不是 `bool`，我們會得到一個錯誤。例如，試著執行以下程式碼：

檔案名稱：src/main.rs

```rust
fn main() {
    let number = 3;

    if number {
        println!("number was three");
    }
}
```

這次 `if` 條件評估為值 `3`，而 Rust 拋出一個錯誤：

```
$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
error[E0308]: mismatched types
 --> src/main.rs:4:8
  |
4 |     if number {
  |        ^^^^^^ expected `bool`, found integer

For more information about this error, try `rustc --explain E0308`.
error: could not compile `branches` (bin "branches") due to 1 previous error
```

錯誤訊息指出 Rust 期望一個 `bool` 但得到了一個整數。與 Ruby 和 JavaScript 等語言不同，Rust 不會自動嘗試將非布林型別轉換為布林值。你必須明確地提供 `if` 一個布林值作為其條件。例如，如果我們希望 `if` 程式碼區塊只在數字不等於 `0` 時執行，我們可以將 `if` expression 改為以下內容：

檔案名稱：src/main.rs

```rust
fn main() {
    let number = 3;

    if number != 0 {
        println!("number was something other than zero");
    }
}
```

執行這段程式碼將會印出 `number was something other than zero`。

#### 使用 `else if` 處理多個條件

你可以透過在 `else if` expression 中結合 `if` 和 `else` 來使用多個條件。例如：

檔案名稱：src/main.rs

```rust
fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!("number is divisible by 4");
    } else if number % 3 == 0 {
        println!("number is divisible by 3");
    } else if number % 2 == 0 {
        println!("number is divisible by 2");
    } else {
        println!("number is not divisible by 4, 3, or 2");
    }
}
```

這個程式有四條可能的路徑可以走。執行它之後，你應該會看到以下輸出：

```
$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
number is divisible by 3
```

當這個程式執行時，它會依序檢查每個 `if` expression，並執行第一個條件評估為 `true` 的主體。請注意，即使 6 可以被 2 整除，我們也沒有看到 `number is divisible by 2` 的輸出，也沒有看到 `else` 區塊中的 `number is not divisible by 4, 3, or 2` 的文字。這是因為 Rust 只執行第一個 `true` 條件的區塊，一旦找到一個，它甚至不會檢查其餘的條件。

使用太多的 `else if` expressions 會讓你的程式碼變得混亂，所以如果你有一個以上，你可能會想重構你的程式碼。第 6 章將描述一個強大的 Rust 分支結構，稱為 `match`，適用於這些情況。

#### 在 `let` Statement 中使用 `if`

因為 `if` 是一個 expression，我們可以在 `let` statement 的右側使用它，將結果賦值給一個變數，如列表 3-2 所示。

src/main.rs

```rust
fn main() {
    let condition = true;
    let number = if condition { 5 } else { 6 };

    println!("The value of number is: {number}");
}
```

列表 3-2：將 `if` expression 的結果賦值給一個變數

`number` 變數將會根據 `if` expression 的結果被綁定到一個值。執行這段程式碼看看會發生什麼事：

```
$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/branches`
The value of number is: 5
```

請記住，程式碼區塊會評估為它們裡面的最後一個 expression，而數字本身也是 expressions。在這種情況下，整個 `if` expression 的值取決於哪個程式碼區塊被執行。這意味著 `if` 的每個分支可能產生的結果值必須是相同型別；在列表 3-2 中，`if` 分支和 `else` 分支的結果都是 `i32` 整數。如果型別不匹配，如下面的範例所示，我們會得到一個錯誤：

檔案名稱：src/main.rs

```rust
fn main() {
    let condition = true;

    let number = if condition { 5 } else { "six" };

    println!("The value of number is: {number}");
}
```

當我們試圖編譯這段程式碼時，我們會得到一個錯誤。`if` 和 `else` 分支的值型別不相容，Rust 會精確地指出程式中問題的位置：

```
$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
error[E0308]: `if` and `else` have incompatible types
 --> src/main.rs:4:44
  |
4 |     let number = if condition { 5 } else { "six" };
  |                                 -          ^^^^^ expected integer, found `&str`
  |                                 |
  |                                 expected because of this

For more information about this error, try `rustc --explain E0308`.
error: could not compile `branches` (bin "branches") due to 1 previous error
```

`if` 區塊中的 expression 評估為一個整數，而 `else` 區塊中的 expression 評估為一個字串。這行不通，因為變數必須有單一型別，而 Rust 需要在編譯時期明確知道 `number` 變數的型別。知道 `number` 的型別讓編譯器可以驗證我們使用 `number` 的所有地方型別都是有效的。如果 `number` 的型別要到 runtime 才決定，Rust 就無法做到這一點；如果編譯器必須為任何變數追蹤多種假設的型別，它會變得更複雜，並對程式碼提供更少的保證。

### 使用 Loops 進行重複

執行一段程式碼超過一次通常很有用。為此，Rust 提供了幾種_loops_，它們會執行迴圈主體內的程式碼直到結束，然後立即回到開頭重新開始。為了實驗 loops，讓我們建立一個名為 _loops_ 的新專案。

Rust 有三種 loops：`loop`、`while` 和 `for`。讓我們來試試每一種。

#### 使用 `loop` 重複程式碼

`loop` 關鍵字告訴 Rust 一遍又一遍地執行一段程式碼，直到永遠，或者直到你明確地告訴它停止。

舉個例子，將你的 _loops_ 目錄中的 _src/main.rs_ 檔案改成這樣：

檔案名稱：src/main.rs

```rust
fn main() {
    loop {
        println!("again!");
    }
}
```

當我們執行這個程式時，我們會看到 `again!` 被不斷地印出，直到我們手動停止程式。大多數終端機都支援鍵盤快捷鍵 <kbd>ctrl</kbd>-<kbd>c</kbd> 來中斷一個陷入連續迴圈的程式。試試看：

<!-- manual-regeneration
cd listings/ch03-common-programming-concepts/no-listing-32-loop
cargo run
CTRL-C
-->

```
$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.08s
     Running `target/debug/loops`
again!
again!
again!
again!
^Cagain!
```

符號 `^C` 代表你按下 <kbd>ctrl</kbd>-<kbd>c</kbd> 的地方。

你可能會或可能不會在 `^C` 之後看到 `again!` 這個詞被印出，這取決於程式碼在接收到中斷訊號時在迴圈中的位置。

幸運的是，Rust 也提供了一種使用程式碼跳出迴圈的方法。你可以在迴圈內放置 `break` 關鍵字，告訴程式何時停止執行迴圈。回想一下，我們在第 2 章「猜對後退出」一節的猜數字遊戲中就是這麼做的，當使用者猜對數字贏得遊戲時，就退出程式。

我們在猜數字遊戲中也使用了 `continue`，它在迴圈中告訴程式跳過這次迭代中剩餘的任何程式碼，並進入下一次迭代。

#### 從 Loops 回傳值

`loop` 的用途之一是重試你可能知道會失敗的操作，例如檢查一個 thread 是否已完成其工作。你可能還需要將該操作的結果從迴圈中傳遞給程式碼的其餘部分。要做到這一點，你可以在用來停止迴圈的 `break` expression 後面加上你想要回傳的值；該值將會從迴圈中回傳，以便你可以使用它，如下所示：

```rust
fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    println!("The result is {result}");
}
```

在迴圈之前，我們宣告一個名為 `counter` 的變數並將其初始化為 `0`。然後我們宣告一個名為 `result` 的變數來存放從迴圈回傳的值。在迴圈的每次迭代中，我們將 `counter` 變數加 `1`，然後檢查 `counter` 是否等於 `10`。當它等於 `10` 時，我們使用帶有 `counter * 2` 值的 `break` 關鍵字。在迴圈之後，我們用一個分號來結束將值賦予 `result` 的 statement。最後，我們印出 `result` 中的值，在這種情況下是 `20`。

你也可以從迴圈內部 `return`。雖然 `break` 只會退出當前的迴圈，但 `return` 總是會退出當前的函式。

#### 使用迴圈標籤來區分多個迴圈

如果你有迴圈中的迴圈，`break` 和 `continue` 會作用於當時最內層的迴圈。你可以選擇性地在一個迴圈上指定一個_迴圈標籤_，然後你可以將它與 `break` 或 `continue` 一起使用，以指定這些關鍵字作用於帶有標籤的迴圈，而不是最內層的迴圈。迴圈標籤必須以單引號開始。以下是一個有兩個巢狀迴圈的範例：

```rust
fn main() {
    let mut count = 0;
    'counting_up: loop {
        println!("count = {count}");
        let mut remaining = 10;

        loop {
            println!("remaining = {remaining}");
            if remaining == 9 {
                break;
            }
            if count == 2 {
                break 'counting_up;
            }
            remaining -= 1;
        }

        count += 1;
    }
    println!("End count = {count}");
}
```

外層迴圈的標籤是 `'counting_up`，它會從 0 數到 2。沒有標籤的內層迴圈會從 10 倒數到 9。第一個沒有指定標籤的 `break` 只會退出內層迴圈。`break 'counting_up;` statement 會退出外層迴圈。這段程式碼會印出：

```
$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.58s
     Running `target/debug/loops`
count = 0
remaining = 10
remaining = 9
count = 1
remaining = 10
remaining = 9
count = 2
remaining = 10
End count = 2
```

#### 使用 `while` 進行條件式迴圈

程式通常需要在迴圈內評估一個條件。當條件為 `true` 時，迴圈運行。當條件不再為 `true` 時，程式呼叫 `break`，停止迴圈。使用 `loop`、`if`、`else` 和 `break` 的組合可以實現這樣的行為；如果你願意，現在可以在一個程式中試試看。然而，這個模式非常普遍，以至於 Rust 有一個內建的語言結構，稱為 `while` loop。在列表 3-3 中，我們使用 `while` 來讓程式迴圈三次，每次倒數，然後在迴圈結束後，印出一條訊息並退出。

src/main.rs

```rust
fn main() {
    let mut number = 3;

    while number != 0 {
        println!("{number}!");

        number -= 1;
    }

    println!("LIFTOFF!!!");
}
```

列表 3-3：使用 `while` loop 在條件評估為 `true` 時執行程式碼

這種結構消除了如果你使用 `loop`、`if`、`else` 和 `break` 所需的大量巢狀結構，而且更清晰。當一個條件評估為 `true` 時，程式碼運行；否則，它退出迴圈。

#### 使用 `for` 遍歷集合

你可以選擇使用 `while` 結構來遍歷集合的元素，例如一個 array。舉例來說，列表 3-4 中的迴圈會印出 array `a` 中的每個元素。

src/main.rs

```rust
fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut index = 0;

    while index < 5 {
        println!("the value is: {}", a[index]);

        index += 1;
    }
}
```

列表 3-4：使用 `while` loop 遍歷集合的每個元素

在這裡，程式碼會遍歷 array 中的元素。它從索引 `0` 開始，然後迴圈直到達到 array 的最後一個索引（也就是，當 `index < 5` 不再為 `true` 時）。執行這段程式碼將會印出 array 中的每個元素：

```
$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.32s
     Running `target/debug/loops`
the value is: 10
the value is: 20
the value is: 30
the value is: 40
the value is: 50
```

所有五個 array 的值都如預期地出現在終端機中。即使 `index` 在某個時候會達到 `5`，迴圈在嘗試從 array 中取得第六個值之前就停止執行了。

然而，這種方法容易出錯；如果索引值或測試條件不正確，我們可能會導致程式 panic。例如，如果你將 `a` array 的定義改為有四個元素，但忘記將條件更新為 `while index < 4`，程式碼就會 panic。它也很慢，因為編譯器會在每次迴圈迭代時，增加 runtime 程式碼來執行索引是否在 array 範圍內的條件檢查。

作為一個更簡潔的替代方案，你可以使用 `for` loop 並為集合中的每個項目執行一些程式碼。一個 `for` loop 看起來像列表 3-5 中的程式碼。

src/main.rs

```rust
fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a {
        println!("the value is: {element}");
    }
}
```

列表 3-5：使用 `for` loop 遍歷集合的每個元素

當我們執行這段程式碼時，我們會看到與列表 3-4 相同的輸出。更重要的是，我們現在提高了程式碼的安全性，並消除了可能因超出 array 結尾或未達到結尾而遺漏某些項目所導致的 bug。由 `for` loops 產生的機器碼也可能更有效率，因為索引不需要在每次迭代時與 array 的長度進行比較。

使用 `for` loop，如果你改變 array 中的值的數量，就不需要記得去改動任何其他程式碼，不像列表 3-4 中使用的方法那樣。

`for` loops 的安全性和簡潔性使它們成為 Rust 中最常用的迴圈結構。即使在你想執行某段程式碼特定次數的情況下，例如在列表 3-3 中使用 `while` loop 的倒數計時範例，大多數 Rustacean 也會使用 `for` loop。這樣做的方法是使用標準函式庫提供的 `Range`，它會產生從一個數字開始到另一個數字之前的所有數字序列。

以下是使用 `for` loop 和另一個我們尚未談論過的方法 `rev`（用來反轉 range）的倒數計時範例：

檔案名稱：src/main.rs

```rust
fn main() {
    for number in (1..4).rev() {
        println!("{number}!");
    }
    println!("LIFTOFF!!!");
}
```

這段程式碼是不是更漂亮了？

## 總結

你做到了！這是一個內容相當豐富的章節：你學到了變數、scalar 和 compound 資料型別、函式、註解、`if` expressions 和 loops！為了練習本章討論的概念，試著建立程式來做以下事情：

- 在華氏和攝氏溫度之間進行轉換。
- 產生第 _n_ 個費波那契數。
- 印出聖誕頌歌「聖誕十二天」的歌詞，利用歌曲中的重複性。

當你準備好繼續前進時，我們將討論一個在其他程式語言中*不*常見的概念：ownership。
