<!-- DO NOT EDIT THIS FILE.

This file is periodically generated from the content in the `/src/`
directory, so all fixes need to be made in `/src/`.
-->

[TOC]

## 附錄 C: 可 derive 的 Trait

在本書的許多地方，我們都討論過 `derive` attribute，你可以將它應用於 struct 或 enum 的 definition。`derive` attribute 會產生程式碼，這些程式碼會在您使用 `derive` 語法標註的 type 上實作（implement）一個帶有其預設實作的 trait。

在本附錄中，我們提供了標準函式庫中所有可與 `derive` 搭配使用的 trait 的參考。每個章節涵蓋：

*   derive 這個 trait 會啟用哪些 operator 和 method
*   由 `derive` 提供的 trait 實作做了什麼
*   實作該 trait 對於該 type 意味著什麼
*   允許或不允許實作該 trait 的條件
*   需要該 trait 的操作範例

如果您希望有與 `derive` attribute 提供的行為不同的行為，請查閱每個 trait 的標準函式庫 documentation，以了解如何手動實作它們的詳細資訊。

此處列出的 trait 是標準函式庫中唯一可以使用 `derive` 在您的 type 上實作的 trait。標準函式庫中定義的其他 trait 沒有合理的預設行為，因此您需要根據您想達成的目標來實作它們。

一個無法 derive 的 trait 範例是 `Display`，它處理使用者端的格式化。您應該總是考慮向終端使用者顯示 type 的適當方式。終端使用者應該被允許看到 type 的哪些部分？他們會覺得哪些部分相關？哪種資料格式對他們最相關？Rust compiler 沒有這種洞察力，因此無法為您提供適當的預設行為。

本附錄中提供的可 derive 的 trait 清單並不全面：函式庫可以為它們自己的 trait 實作 `derive`，這使得您可以搭配 `derive` 使用的 trait 清單真正地無限擴展。實作 `derive` 涉及使用 procedural macro，這在第 XX 頁的「Macros」中有所介紹。

## Debug：用於程式設計師輸出

`Debug` trait 可以在 format strings 中啟用 debug 格式化，您可以在 `{}` placeholder 內添加 `:?` 來表示。

`Debug` trait 允許您為了 debug 目的而印出 type 的 instance，這樣您和使用您 type 的其他程式設計師就可以在程式執行中的特定點檢查 instance。

例如，在 `assert_eq!` macro 的使用中，`Debug` trait 是必需的。如果 equality assertion 失敗，這個 macro 會印出作為 argument 給定的 instance 的值，這樣程式設計師就可以看到為什麼這兩個 instance 不相等。

## PartialEq 和 Eq：用於相等比較

`PartialEq` trait 允許您比較 type 的 instance 以檢查 equality，並啟用 `==` 和 `!=` operator 的使用。

Derive `PartialEq` 會實作 `eq` method。當 `PartialEq` 在 struct 上 derive 時，只有當*所有* field 都相等時，兩個 instance 才相等；如果有任何 field 不相等，則 instance 不相等。當在 enum 上 derive 時，每個 variant 與其自身相等，而不與其他 variant 相等。

例如，在使用 `assert_eq!` macro 時，`PartialEq` trait 是必需的，因為它需要能夠比較兩個 type 的 instance 是否相等。

`Eq` trait 沒有 method。它的目的是表明對於被標註 type 的每個值，該值都等於其自身。`Eq` trait 只能應用於同時實作 `PartialEq` 的 type，儘管不是所有實作 `PartialEq` 的 type 都能實作 `Eq`。一個例子是 floating-point 數字 type：floating-point 數字的實作規定兩個 not-a-number (`NaN`) 值的 instance 互不相等。

需要 `Eq` 的一個例子是作為 `HashMap<K, V>` 中的 key，這樣 `HashMap<K, V>` 才能判斷兩個 key 是否相同。

## PartialOrd 和 Ord：用於排序比較

`PartialOrd` trait 允許您比較 type 的 instance 以用於 sorting 目的。實作了 `PartialOrd` 的 type 可以與 `<`, `>`, `<=`, 和 `>=` operator 一起使用。您只能將 `PartialOrd` trait 應用於同時實作 `PartialEq` 的 type。

Derive `PartialOrd` 會實作 `partial_cmp` method，它會返回一個 `Option<Ordering>`，當給定的值無法產生 ordering 時，它將是 `None`。一個即使其大多數值可以比較，但仍無法產生 ordering 的值的範例是 not-a-number (`NaN`) floating point 值。使用任何 floating-point 數字和 `NaN` floating-point 值呼叫 `partial_cmp` 都會返回 `None`。

當在 struct 上 derive 時，`PartialOrd` 會按照 field 在 struct definition 中出現的順序來比較每個 field 的值，以此比較兩個 instance。當在 enum 上 derive 時，在 enum definition 中較早宣告的 enum variant 被認為小於後面列出的 variant。

例如，`rand` crate 的 `gen_range` method 需要 `PartialOrd` trait，該 method 根據 range expression 指定的範圍生成一個隨機值。

`Ord` trait 讓您知道對於被標註 type 的任何兩個值，都將存在一個有效的 ordering。`Ord` trait 實作 `cmp` method，它返回一個 `Ordering` 而不是 `Option<Ordering>`，因為總是可能存在一個有效的 ordering。您只能將 `Ord` trait 應用於同時實作 `PartialOrd` 和 `Eq` 的 type（且 `Eq` 需要 `PartialEq`）。當在 struct 和 enum 上 derive 時，`cmp` 的行為與 `partial_cmp` 在 `PartialOrd` 上的 derive 實作方式相同。

需要 `Ord` 的一個例子是將值儲存在 `BTreeSet<T>` 中，這是一個根據值的 sorting order 儲存資料的 data structure。

## Clone 和 Copy：用於複製值

`Clone` trait 允許您明確地建立一個值的 deep copy，並且複製過程可能涉及執行任意程式碼和複製 heap 資料。有關 `Clone` 的更多資訊，請參閱第 XX 頁的「Variables and Data Interacting with Clone」。

Derive `Clone` 會實作 `clone` method，當為整個 type 實作時，它會呼叫 type 的每個部分的 `clone`。這意味著 type 中的所有 field 或值也必須實作 `Clone` 才能 derive `Clone`。

需要 `Clone` 的一個例子是在 slice 上呼叫 `to_vec` method 時。slice 不擁有其包含的 type instance，但從 `to_vec` 返回的 vector 需要擁有其 instance，因此 `to_vec` 會對每個 item 呼叫 `clone`。因此，儲存在 slice 中的 type 必須實作 `Clone`。

`Copy` trait 允許您僅透過複製儲存在 stack 上的 bits 來複製值；不需要任意程式碼。有關 `Copy` 的更多資訊，請參閱第 XX 頁的「Stack-Only Data: Copy」。

`Copy` trait 沒有定義任何 method，以防止程式設計師重載這些 method 並違反不執行任意程式碼的假設。這樣一來，所有程式設計師都可以假設複製一個值會非常快。

您可以在其所有部分都實作 `Copy` 的任何 type 上 derive `Copy`。實作 `Copy` 的 type 也必須實作 `Clone`，因為實作 `Copy` 的 type 具有 `Clone` 的一個 trivial 實作，它執行與 `Copy` 相同的任務。

`Copy` trait 很少被要求；實作 `Copy` 的 type 具有可用的 optimizations，這意味著您不必呼叫 `clone`，這使得程式碼更簡潔。

所有可以用 `Copy` 完成的事情，您也可以用 `Clone` 完成，但程式碼可能會更慢或者必須在某些地方使用 `clone`。

## Hash：用於將值映射到固定大小的值

`Hash` trait 允許您取得任意大小的 type 的 instance，並使用 hash function 將該 instance 映射到固定大小的值。Derive `Hash` 會實作 `hash` method。`hash` method 的 derive 實作會將 type 的每個部分呼叫 `hash` 的結果結合起來，這意味著所有 field 或值也必須實作 `Hash` 才能 derive `Hash`。

需要 `Hash` 的一個例子是將 key 儲存在 `HashMap<K, V>` 中，以便高效地儲存 data。

## Default：用於預設值

`Default` trait 允許您為 type 建立一個 default value。Derive `Default` 會實作 `default` function。`default` function 的 derive 實作會對 type 的每個部分呼叫 `default` function，這意味著 type 中的所有 field 或值也必須實作 `Default` 才能 derive `Default`。

`Default::default` function 通常與第 XX 頁「Creating Instances from Other Instances with Struct Update Syntax」中討論的 struct update syntax 結合使用。您可以自訂 struct 的幾個 field，然後使用 `..Default::default()` 來設定和使用其餘 field 的 default value。

例如，當您在 `Option<T>` instance 上使用 `unwrap_or_default` method 時，`Default` trait 是必需的。如果 `Option<T>` 是 `None`，`unwrap_or_default` method 將返回儲存在 `Option<T>` 中的 type `T` 的 `Default::default` 的結果。