<!-- DO NOT EDIT THIS FILE.

This file is periodically generated from the content in the `/src/`
directory, so all fixes need to be made in `/src/`.
-->

[TOC]

# 無懼的並行 (Fearless Concurrency)

安全且有效地處理並行程式設計，是 Rust 的另一個主要目標。_並行程式設計 (Concurrent programming)_ 指的是程式的不同部分獨立執行，而 _平行程式設計 (parallel programming)_ 則指程式的不同部分同時執行，隨著越來越多電腦利用其多個處理器，這兩者變得越來越重要。歷史上，在這些情況下進行程式設計一直很困難且容易出錯。Rust 希望改變這一點。

最初，Rust 團隊認為確保記憶體安全和防止並行問題是兩個獨立的挑戰，需要用不同的方法來解決。隨著時間的推移，團隊發現 ownership 和型別系統是強大的工具組合，可用於管理記憶體安全*和*並行問題！透過利用 ownership 和型別檢查，許多並行錯誤在 Rust 中是 compile-time errors 而不是 runtime errors。因此，與其讓你花費大量時間試圖重現 runtime 並行錯誤發生的確切情況，不正確的程式碼將拒絕編譯並顯示錯誤解釋問題。結果是，你可以在開發程式碼時就修復它，而不是等到可能已部署到生產環境之後。我們將 Rust 的這一方面戲稱為 _無懼的並行 (fearless concurrency)_。無懼的並行使你能夠編寫沒有微妙錯誤的程式碼，並且易於重構而不會引入新的錯誤。

> 註：為了簡化起見，我們將許多問題稱為 _concurrent_，而不是更精確地說 _concurrent 和/或 parallel_。對於本章，請在我們使用 _concurrent_ 時，在腦海中代入 _concurrent 和/或 parallel_。在下一章，當區別變得更重要時，我們會更具體。

許多語言對於處理並行問題提供的解決方案是教條式的。例如，Erlang 具有用於 message-passing concurrency 的優雅功能，但只有不清楚的方式在 threads 之間共享 state。僅支援部分可能的解決方案對於高階語言來說是一種合理的策略，因為高階語言承諾放棄一些控制以獲得抽象的好處。然而，低階語言預期在任何給定情況下提供最佳效能的解決方案，並且對硬體的抽象較少。因此，Rust 提供了各種工具，可以根據你的情況和要求，以任何適當的方式建模問題。

本章將涵蓋以下主題：

- 如何建立 threads 以同時執行多段程式碼
- _訊息傳遞 (Message-passing)_ 並行，其中 channels 在 threads 之間發送訊息
- _共享狀態 (Shared-state)_ 並行，其中多個 threads 可以存取某個資料片段
- `Sync` 和 `Send` traits，它們將 Rust 的並行保證擴展到使用者自訂型別以及標準函式庫提供的型別

## 使用 Threads 同時執行程式碼

在大多數目前的作業系統中，已執行的程式碼在一個 _process_ 中執行，作業系統將同時管理多個 processes。在一個程式中，你也可以有獨立的部分同時執行。執行這些獨立部分的功能稱為 _threads_。例如，一個網頁伺服器可以有多個 threads，這樣它就能同時回應多個請求。

將程式中的計算拆分成多個 threads 以同時執行多個任務，可以提高效能，但也會增加複雜性。由於 threads 可以同時執行，因此無法保證不同 threads 上程式碼各部分的執行順序。這可能導致以下問題：

- race conditions (競態條件)，其中 threads 以不一致的順序存取資料或資源
- deadlocks (死鎖)，其中兩個 threads 互相等待，阻止兩者繼續執行
- 僅在特定情況下發生且難以可靠重現和修復的 bugs

Rust 試圖減輕使用 threads 的負面影響，但在多執行緒環境中進行程式設計仍然需要仔細思考，並且需要與單一執行緒程式不同的程式碼結構。

程式語言以幾種不同的方式實作 threads，許多作業系統提供了程式語言可以呼叫的 API 以建立新的 threads。Rust 標準函式庫使用 _1:1_ 的 thread 實作模型，程式使用一個作業系統 thread 對應一個語言 thread。也有 crates 實作了其他 thread 模型，這些模型與 1:1 模型有不同的取捨。（Rust 的 `async` 系統，我們將在下一章看到，也提供了另一種並行方法。）

### 使用 spawn 建立新的 Thread

要建立一個新的 thread，我們呼叫 `thread::spawn` 函式，並傳遞一個 closure（我們在第 13 章討論過 closure），其中包含我們想在新 thread 中執行的程式碼。範例 16-1 中的程式碼從主 thread 打印一些文字，並從新 thread 打印其他文字。

<span class="filename">src/main.rs</span>

```rust
use std::thread;
use std::time::Duration;

fn main() {
    thread::spawn(|| {
        for i in 1..10 {
            println!("hi number {i} from the spawned thread!");
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!("hi number {i} from the main thread!");
        thread::sleep(Duration::from_millis(1));
    }
}
```

列表 16-1：建立一個新 thread 在主 thread 打印其他東西時打印一個東西

請注意，當 Rust 程式的主 thread 完成時，所有 spawned threads 都會被關閉，無論它們是否已完成執行。這個程式的輸出每次可能會略有不同，但會類似於以下內容：

```
hi number 1 from the main thread!
hi number 1 from the spawned thread!
hi number 2 from the main thread!
hi number 2 from the spawned thread!
hi number 3 from the main thread!
hi number 3 from the spawned thread!
hi number 4 from the main thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
```

對 `thread::sleep` 的呼叫會強制 thread 暫停執行一小段時間，允許其他 thread 運行。這些 threads 可能會輪流執行，但這並非保證：它取決於你的作業系統如何排程這些 threads。在這次執行中，即使 spawned thread 的打印語句在程式碼中先出現，主 thread 還是先打印了。而且儘管我們告訴 spawned thread 打印直到 `i` 為 `9`，它在主 thread 關閉之前只打印到 `5`。

如果你執行這段程式碼並且只看到主 thread 的輸出，或者沒有看到任何重疊，請嘗試增加 ranges 中的數字，為作業系統在 threads 之間切換創造更多機會。

### 使用 join Handles 等待所有 Threads 完成

列表 16-1 中程式碼不僅大多數時候由於主 thread 結束而導致 spawned thread 過早停止，而且由於無法保證 threads 的執行順序，我們也無法保證 spawned thread 會執行！

我們可以透過將 `thread::spawn` 的回傳值儲存到變數中，來解決 spawned thread 未執行或過早結束的問題。`thread::spawn` 的回傳型別是 `JoinHandle<T>`。`JoinHandle<T>` 是一個 owned value，當我們呼叫其上的 `join` 方法時，它會等待其 thread 完成。列表 16-2 顯示了如何使用我們在列表 16-1 中建立的 thread 的 `JoinHandle<T>`，以及如何呼叫 `join` 來確保 spawned thread 在 `main` 結束之前完成。

<span class="filename">src/main.rs</span>

```rust
use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!("hi number {i} from the spawned thread!");
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!("hi number {i} from the main thread!");
        thread::sleep(Duration::from_millis(1));
    }

    handle.join().unwrap();
}
```

列表 16-2：儲存 `thread::spawn` 的 `JoinHandle<T>` 以確保 thread 執行完成

在 handle 上呼叫 `join` 會阻塞當前正在執行的 thread，直到該 handle 所代表的 thread 終止。_阻塞 (Blocking)_ 一個 thread 意味著該 thread 被阻止執行工作或退出。因為我們將 `join` 的呼叫放在主 thread 的 `for` 迴圈之後，執行列表 16-2 應該產生類似以下的輸出：

```
hi number 1 from the main thread!
hi number 2 from the main thread!
hi number 1 from the spawned thread!
hi number 3 from the main thread!
hi number 2 from the spawned thread!
hi number 4 from the main thread!
hi number 3 from the spawned thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
hi number 6 from the spawned thread!
hi number 7 from the spawned thread!
hi number 8 from the spawned thread!
hi number 9 from the spawned thread!
```

兩個 threads 繼續交替執行，但由於呼叫了 `handle.join()`，主 thread 會等待，直到 spawned thread 完成才結束。

但讓我們看看當我們將 `handle.join()` 移到 `main` 中的 `for` 迴圈之前會發生什麼，像這樣：

<span class="filename">src/main.rs</span>

```rust
use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!("hi number {i} from the spawned thread!");
            thread::sleep(Duration::from_millis(1));
        }
    });

    handle.join().unwrap();

    for i in 1..5 {
        println!("hi number {i} from the main thread!");
        thread::sleep(Duration::from_millis(1));
    }
}
```

主 thread 將等待 spawned thread 完成，然後才執行其 `for` 迴圈，因此輸出將不再交錯，如下所示：

```
hi number 1 from the spawned thread!
hi number 2 from the spawned thread!
hi number 3 from the spawned thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
hi number 6 from the spawned thread!
hi number 7 from the spawned thread!
hi number 8 from the spawned thread!
hi number 9 from the spawned thread!
hi number 1 from the main thread!
hi number 2 from the main thread!
hi number 3 from the main thread!
hi number 4 from the main thread!
```

像 `join` 在何處被呼叫這樣的小細節，會影響你的 threads 是否同時執行。

### 將 move Closures 與 Threads 一起使用

我們經常將 `move` 關鍵字與傳遞給 `thread::spawn` 的 closures 一起使用，因為 closure 將取得其從環境中使用的值的 ownership，從而將這些值的 ownership 從一個 thread 轉移到另一個 thread。在第 13 章的「捕捉參考或移動 ownership」一節中，我們討論了 closure 環境中的 `move`。現在我們將更專注於 `move` 和 `thread::spawn` 之間的互動。

注意在列表 16-1 中，我們傳遞給 `thread::spawn` 的 closure 沒有任何參數：我們沒有在 spawned thread 的程式碼中使用主 thread 中的任何資料。要在 spawned thread 中使用主 thread 中的資料，spawned thread 的 closure 必須捕獲它需要的值。列表 16-3 顯示了在主 thread 中建立一個 vector 並試圖在 spawned thread 中使用它的嘗試。然而，這目前還行不通，你很快就會看到原因。

<span class="filename">src/main.rs</span>

```rust
use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        println!("Here's a vector: {v:?}");
    });

    handle.join().unwrap();
}
```

列表 16-3：嘗試在另一個 thread 中使用由主 thread 建立的 vector

closure 使用了 `v`，因此它會捕獲 `v` 並使其成為 closure 環境的一部分。因為 `thread::spawn` 在一個新的 thread 中執行這個 closure，我們應該能夠在新 thread 內部存取 `v`。但是當我們編譯這個範例時，我們會得到以下錯誤：

```
$ cargo run
   Compiling threads v0.1.0 (file:///projects/threads)
error[E0373]: closure may outlive the current function, but it borrows `v`, which is owned by the current function
 --> src/main.rs:6:32
  |
6 |     let handle = thread::spawn(|| {
  |                                ^^ may outlive borrowed value `v`
7 |         println!("Here's a vector: {v:?}");
  |                                     - `v` is borrowed here
  |
note: function requires argument type to outlive `'static`
 --> src/main.rs:6:18
  |
6 |       let handle = thread::spawn(|| {
  |  __________________^
7 | |         println!("Here's a vector: {v:?}");
8 | |     });
  | |______^
help: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword
  |
6 |     let handle = thread::spawn(move || {
  |                                ++++

For more information about this error, try `rustc --explain E0373`.
error: could not compile `threads` (bin "threads") due to 1 previous error
```

Rust *推斷*如何捕獲 `v`，而且因為 `println!` 只需要 `v` 的 reference，所以 closure 試圖借用 `v`。然而，這裡有一個問題：Rust 無法判斷 spawned thread 會執行多久，所以它不知道 `v` 的 reference 是否會一直有效。

列表 16-4 提供了一個更有可能導致 `v` 的 reference 無效的場景。

<span class="filename">src/main.rs</span>

```rust
use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        println!("Here's a vector: {v:?}");
    });

    drop(v); // oh no!

    handle.join().unwrap();
}
```

列表 16-4：一個包含 closure 的 thread 嘗試從執行 `drop v` 的主 thread 中捕獲 `v` 的 reference

如果 Rust 允許我們執行這段程式碼，spawned thread 有可能在完全沒有執行的情況下立即被放到後台。spawned thread 內部有一個 `v` 的 reference，但主 thread 立即使用我們在第 15 章討論過的 `drop` 函式將 `v` 丟棄。然後，當 spawned thread 開始執行時，`v` 不再有效，因此它的 reference 也無效。糟糕！

為了修復列表 16-3 中的編譯器錯誤，我們可以參考錯誤訊息的建議：

```
help: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword
  |
6 |     let handle = thread::spawn(move || {
  |                                ++++
```

透過在 closure 前面加上 `move` 關鍵字，我們強制 closure 取得它所使用值的 ownership，而不是讓 Rust 推斷它應該借用這些值。列表 16-5 中對列表 16-3 的修改將會編譯並如我們所願地執行。

<span class="filename">src/main.rs</span>

```rust
use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(move || {
        println!("Here's a vector: {v:?}");
    });

    handle.join().unwrap();
}
```

列表 16-5：使用 `move` 關鍵字強制 closure 取得其使用值的 ownership

我們可能會想嘗試用同樣的方式來修復列表 16-4 中主 thread 呼叫 `drop` 的程式碼，即使用 `move` closure。然而，這個修復不會奏效，因為列表 16-4 試圖做的事情基於不同的原因是不被允許的。如果我們在 closure 中加入 `move`，我們會將 `v` 移動到 closure 的環境中，然後我們就不能在主 thread 中對它呼叫 `drop` 了。我們會得到以下編譯器錯誤：

```
$ cargo run
   Compiling threads v0.1.0 (file:///projects/threads)
error[E0382]: use of moved value: `v`
  --> src/main.rs:10:10
   |
4  |     let v = vec![1, 2, 3];
   |         - move occurs because `v` has type `Vec<i32>`, which does not implement the `Copy` trait
5  |
6  |     let handle = thread::spawn(move || {
   |                                ------- value moved into closure here
7  |         println!("Here's a vector: {v:?}");
   |                                     - variable moved due to use in closure
...
10 |     drop(v); // oh no!
   |          ^ value used here after move

For more information about this error, try `rustc --explain E0382`.
error: could not compile `threads` (bin "threads") due to 1 previous error
```

Rust 的 ownership 規則再次拯救了我們！我們在列表 16-3 的程式碼中得到了錯誤，因為 Rust 比較保守，只為 thread 借用了 `v`，這意味著主 thread 理論上可能會使 spawned thread 的 reference 無效。透過告訴 Rust 將 `v` 的 ownership 移動到 spawned thread，我們向 Rust 保證主 thread 將不再使用 `v`。如果我們以相同的方式改變列表 16-4，那麼我們在主 thread 中試圖使用 `v` 時就違反了 ownership 規則。`move` 關鍵字會覆蓋 Rust 借用的保守預設；它不允許我們違反 ownership 規則。

現在我們已經涵蓋了 threads 是什麼以及 thread API 提供的各種方法，接下來讓我們看看一些可以使用 threads 的情況。

## 使用訊息傳遞在 Threads 之間傳輸資料

一種日益流行的確保安全並行的方法是 _訊息傳遞 (message passing)_，其中 threads 或 actors 透過互相發送包含資料的訊息來進行通訊。這是一個來自 Go 語言文件 (`https://golang.org/doc/effective_go.html#concurrency`) 的標語中的想法：「不要透過共享記憶體來通訊；相反地，透過通訊來共享記憶體。」

為了實現訊息傳遞並行，Rust 的標準函式庫提供了 channels 的實作。_channel (通道)_ 是一個通用的程式設計概念，透過它資料從一個 thread 發送到另一個 thread。

你可以把程式設計中的 channel 想像成一個單向的水道，例如一條溪流或一條河流。如果你把像橡皮鴨一樣的東西放進河裡，它就會順流而下，到達水道的盡頭。

一個 channel 有兩半：一個 transmitter (發送端) 和一個 receiver (接收端)。transmitter 半是上游你把橡皮鴨放進河裡的位置，而 receiver 半是橡皮鴨最終到達下游的位置。你的程式碼的一部分在 transmitter 上呼叫方法，帶上你想發送的資料，另一部分則檢查接收端是否有訊息到達。如果 transmitter 或 receiver 的任何一半被 drop 掉了，則該 channel 被稱為 _關閉 (closed)_。

在這裡，我們將逐步建構一個程式，它有一個 thread 用來產生值並將它們發送到 channel 中，另一個 thread 則接收這些值並將它們打印出來。我們將使用 channel 在 threads 之間傳送簡單的值以說明這個特性。一旦你熟悉了這個技術，你就可以將 channels 用於任何需要互相通訊的 threads，例如聊天系統，或是一個許多 threads 執行部分計算並將這些部分發送到一個聚合結果的 thread 的系統。

首先，在列表 16-6 中，我們將建立一個 channel，但不對它做任何操作。請注意，這目前還無法編譯，因為 Rust 無法判斷我們希望透過 channel 發送什麼型別的值。

<span class="filename">src/main.rs</span>

```rust
use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();
}
```

列表 16-6：建立一個 channel 並將兩半分配給 `tx` 和 `rx`

我們使用 `mpsc::channel` 函式建立一個新的 channel；`mpsc` 代表 _multiple producer, single consumer_ (多生產者，單消費者)。簡而言之，Rust 標準函式庫實作 channels 的方式意味著一個 channel 可以有多個產生值的 _發送_ 端，但只有一個消耗這些值的 _接收_ 端。想像多條溪流匯合成一條大河：所有沿著任何一條溪流發送的東西最終都會匯集到終點的那條河。我們將從單一生產者開始，但當這個範例開始運作時，我們將新增多個生產者。

`mpsc::channel` 函式回傳一個 tuple，其中第一個元素是發送端——transmitter——第二個元素是接收端——receiver。縮寫 `tx` 和 `rx` 傳統上在許多領域分別用於 _transmitter_ 和 _receiver_，所以我們將變數命名為此，以表示每一端。我們使用帶有模式的 `let` 語句來解構 tuples；我們將在第 19 章討論在 `let` 語句中使用模式和解構。目前，你只需要知道以這種方式使用 `let` 語句是提取 `mpsc::channel` 回傳的 tuple 片段的便捷方法。

讓我們將發送端移動到一個 spawned thread 中，讓它發送一個字串，這樣 spawned thread 就能與主 thread 通訊，如列表 16-7 所示。這就像把一隻橡皮鴨放進上游的河裡，或者從一個 thread 向另一個 thread 發送聊天訊息。

<span class="filename">src/main.rs</span>

```rust
use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("hi");
        tx.send(val).unwrap();
    });
}
```

列表 16-7：將 `tx` 移動到一個 spawned thread 並發送 `"hi"`

我們再次使用 `thread::spawn` 建立一個新 thread，然後使用 `move` 將 `tx` 移動到 closure 中，這樣 spawned thread 就擁有 `tx`。spawned thread 需要擁有 transmitter 才能透過 channel 發送訊息。

transmitter 有一個 `send` 方法，它接收我們想發送的值。`send` 方法回傳一個 `Result<T, E>` 型別，所以如果 receiver 已經被 drop 掉了，並且沒有地方可以發送值，send 操作將會回傳一個錯誤。在這個範例中，我們呼叫 `unwrap` 以在發生錯誤時 panic。但在實際應用程式中，我們會妥善處理它：請回到第 9 章回顧正確錯誤處理的策略。

在列表 16-8 中，我們將在主 thread 中從 receiver 獲取值。這就像從河的盡頭打撈橡皮鴨，或接收聊天訊息一樣。

<span class="filename">src/main.rs</span>

```rust
use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("hi");
        tx.send(val).unwrap();
    });

    let received = rx.recv().unwrap();
    println!("Got: {received}");
}
```

列表 16-8：在主 thread 中接收值 `"hi"` 並打印

接收端有兩個有用的方法：`recv` 和 `try_recv`。我們使用的是 `recv`，它是 _receive_ 的縮寫，它會阻塞主 thread 的執行，並等待直到一個值被發送到 channel。一旦值被發送，`recv` 會將其以 `Result<T, E>` 的形式回傳。當 transmitter 關閉時，`recv` 會回傳一個錯誤，表示不會再有值傳來。

`try_recv` 方法不會阻塞，而是會立即回傳一個 `Result<T, E>`：如果有一個訊息可用，則是一個包含訊息的 `Ok` 值；如果這次沒有任何訊息，則是一個 `Err` 值。如果這個 thread 在等待訊息時還有其他工作要做，使用 `try_recv` 會很有用：我們可以編寫一個迴圈，每隔一段時間呼叫 `try_recv`，如果訊息可用就處理，否則做其他工作一小段時間直到再次檢查。

為了簡便起見，我們在這個範例中使用了 `recv`；主 thread 除了等待訊息之外沒有其他工作要做，因此阻塞主 thread 是合適的。

當我們執行列表 16-8 中的程式碼時，我們會看到從主 thread 打印出的值：

```
Got: hi
```

完美！

### Channels 和 Ownership 的轉移

ownership 規則在訊息傳遞中扮演著至關重要的角色，因為它們幫助你編寫安全的並行程式碼。防止並行程式設計中的錯誤是貫穿你的 Rust 程式思考 ownership 的優勢。讓我們做一個實驗來展示 channels 和 ownership 如何協同工作以防止問題：我們將嘗試在透過 channel 發送 `val` 值_之後_，在 spawned thread 中使用它。試著編譯列表 16-9 中的程式碼，看看為什麼不允許這段程式碼。

<span class="filename">src/main.rs</span>

```rust
use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("hi");
        tx.send(val).unwrap();
        println!("val is {val}");
    });

    let received = rx.recv().unwrap();
    println!("Got: {received}");
}
```

列表 16-9：試圖在透過 channel 發送 `val` 後使用它

在這裡，我們試圖在透過 `tx.send` 將 `val` 沿著 channel 發送後打印它。允許這樣做會是一個壞主意：一旦值被發送到另一個 thread，該 thread 可能會在我們再次嘗試使用該值之前修改或 drop 掉它。潛在的，另一個 thread 的修改可能會因為資料不一致或不存在而導致錯誤或意外結果。然而，如果我們嘗試編譯列表 16-9 中的程式碼，Rust 會給我們一個錯誤：

```
$ cargo run
   Compiling message-passing v0.1.0 (file:///projects/message-passing)
error[E0382]: borrow of moved value: `val`
  --> src/main.rs:10:26
   |
8  |         let val = String::from("hi");
   |             --- move occurs because `val` has type `String`, which does not implement the `Copy` trait
9  |         tx.send(val).unwrap();
   |                 --- value moved here
10 |         println!("val is {val}");
   |                          ^^^^^ value borrowed here after move
   |
   = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

For more information about this error, try `rustc --explain E0382`.
error: could not compile `message-passing` (bin "message-passing") due to 1 previous error
```

我們的並行錯誤導致了一個 compile-time error。`send` 函式取得了其參數的 ownership，當值被移動時，接收端取得了它的 ownership。這阻止了我們在發送值後意外地再次使用它；ownership 系統檢查一切是否正常。

### 發送多個值並查看 Receiver 等待

列表 16-8 中的程式碼已編譯並執行，但它沒有清楚地顯示兩個獨立的 threads 正在透過 channel 互相通訊。

在列表 16-10 中，我們進行了一些修改，將證明列表 16-8 中的程式碼正在並行執行：spawned thread 現在將發送多條訊息，並在每條訊息之間暫停一秒鐘。

<span class="filename">src/main.rs</span>

```rust
use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let vals = vec![
            String::from("hi"),
            String::from("from"),
            String::from("the"),
            String::from("thread"),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {
        println!("Got: {received}");
    }
}
```

列表 16-10：發送多個訊息並在每個訊息之間暫停

這次，spawned thread 有一個字串 vector，我們想將其發送到主 thread。我們迭代它們，逐個發送，並透過呼叫 `thread::sleep` 函式並傳遞一個 `Duration` 值為一秒來在每個之間暫停。

在主 thread 中，我們不再明確呼叫 `recv` 函式：相反，我們將 `rx` 視為一個 iterator。對於每個收到的值，我們都會打印它。當 channel 關閉時，迭代將結束。

當執行列表 16-10 中的程式碼時，你應該會看到以下輸出，每行之間暫停一秒：

```
Got: hi
Got: from
Got: the
Got: thread
```

因為我們在主 thread 的 `for` 迴圈中沒有任何暫停或延遲的程式碼，所以我們可以判斷主 thread 正在等待從 spawned thread 接收值。

### 透過複製 Transmitter 建立多個 Producers

前面我們提到 `mpsc` 是 _multiple producer, single consumer_ 的縮寫。讓我們來利用 `mpsc`，並擴展列表 16-10 中的程式碼，建立多個 threads，它們都將值發送到同一個 receiver。我們可以透過複製 transmitter 來實現，如列表 16-11 所示。

<span class="filename">src/main.rs</span>

```rust
    // --snip--

    let (tx, rx) = mpsc::channel();

    let tx1 = tx.clone();
    thread::spawn(move || {
        let vals = vec![
            String::from("hi"),
            String::from("from"),
            String::from("the"),
            String::from("thread"),
        ];

        for val in vals {
            tx1.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    thread::spawn(move || {
        let vals = vec![
            String::from("more"),
            String::from("messages"),
            String::from("for"),
            String::from("you"),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {
        println!("Got: {received}");
    }

    // --snip--
```

列表 16-11：從多個生產者發送多個訊息

這次，在我們建立第一個 spawned thread 之前，我們在 transmitter 上呼叫了 `clone`。這會給我們一個新的 transmitter，我們可以將其傳遞給第一個 spawned thread。我們將原始的 transmitter 傳遞給第二個 spawned thread。這就給了我們兩個 threads，每個都向同一個 receiver 發送不同的訊息。

當你執行程式碼時，你的輸出應該類似這樣：

```
Got: hi
Got: more
Got: from
Got: messages
Got: for
Got: the
Got: thread
Got: you
```

你可能會看到值以不同的順序出現，這取決於你的系統。這就是並行既有趣又困難的地方。如果你嘗試使用 `thread::sleep`，在不同的 threads 中給予它不同的值，每次執行都會更加不確定，並產生不同的輸出。

現在我們已經了解了 channels 的運作方式，接下來讓我們看看另一種並行方法。

## 共享狀態並行 (Shared-State Concurrency)

訊息傳遞是處理並行的一種好方法，但它不是唯一的方法。另一種方法是讓多個 threads 存取相同的共享資料。再次思考 Go 語言文件中標語的這部分：「不要透過共享記憶體來通訊。」

透過共享記憶體進行通訊會是什麼樣子？此外，為什麼訊息傳遞愛好者會警告不要使用記憶體共享？

在某種程度上，任何程式語言中的 channels 都類似於單一 ownership，因為一旦你透過 channel 傳輸了一個值，你就不應該再使用那個值。共享記憶體並行則像多重 ownership：多個 threads 可以同時存取相同的記憶體位置。正如你在第 15 章看到的，智能指標使得多重 ownership 成為可能，多重 ownership 會增加複雜性，因為這些不同的 owner 需要管理。Rust 的型別系統和 ownership 規則在正確管理這方面提供了極大的幫助。作為範例，讓我們看看 mutexes，這是共享記憶體最常見的並行原語之一。

### 使用 Mutexes 允許一次從一個 Thread 存取資料

_Mutex_ 是 _mutual exclusion (互斥)_ 的縮寫，意指 mutex 在任何給定時間只允許一個 thread 存取某些資料。要存取 mutex 中的資料，thread 必須首先透過要求取得 mutex 的 lock 來表示它想要存取。_lock (鎖)_ 是 mutex 的一部分，它追蹤誰當前對資料擁有獨佔存取權限。因此，mutex 被描述為透過鎖定系統來 _保護 (guarding)_ 它所持有的資料。

Mutexes 因難以使用而聞名，因為你必須記住兩條規則：

1. 在使用資料之前，你必須嘗試取得 lock。
2. 當你完成使用 mutex 保護的資料後，你必須解鎖資料，以便其他 threads 可以取得 lock。

對於 mutex 的現實世界比喻，想像一下會議中的小組討論，只有一個麥克風。在小組成員發言之前，他們必須詢問或表示他們想使用麥克風。當他們拿到麥克風後，他們可以隨心所欲地講話，然後將麥克風遞給下一個要求發言的小組成員。如果小組成員在使用完麥克風後忘記將其交出，其他人就無法發言。如果共享麥克風的管理出了問題，小組討論就無法按計畫進行！

Mutexes 的管理可能極其棘手，這就是為什麼這麼多人熱衷於 channels 的原因。然而，由於 Rust 的型別系統和 ownership 規則，你不可能將鎖定和解鎖搞錯。

#### Mutex<T> 的 API

作為如何使用 mutex 的範例，讓我們首先在單一執行緒環境中使用 mutex，如列表 16-12 所示。

<span class="filename">src/main.rs</span>

```rust
use std::sync::Mutex;

fn main() {
    let m = Mutex::new(5);

    {
        let mut num = m.lock().unwrap();
        *num = 6;
    }

    println!("m = {m:?}");
}
```

列表 16-12：為簡化起見，在單執行緒環境中探索 `Mutex<T>` 的 API

與許多型別一樣，我們使用關聯函式 `new` 建立一個 `Mutex<T>`。要存取 mutex 內部資料，我們使用 `lock` 方法來取得 lock。這個呼叫將會阻塞當前 thread，使其無法執行任何工作，直到輪到我們取得 lock 為止。

如果持有 lock 的另一個 thread panic 了，對 `lock` 的呼叫就會失敗。在這種情況下，沒有人能再取得 lock，所以我們選擇 `unwrap` 並讓這個 thread 在這種情況下 panic。

在我們取得了 lock 之後，我們可以將回傳值（在此情況下命名為 `num`）視為內部資料的 mutable reference。型別系統確保我們在使用 `m` 中的值之前取得 lock。`m` 的型別是 `Mutex<i32>`，而不是 `i32`，所以我們*必須*呼叫 `lock` 才能使用 `i32` 值。我們不能忘記；否則型別系統不允許我們存取內部的 `i32`。

對 `lock` 的呼叫會回傳一個名為 `MutexGuard` 的型別，它被包裝在一個我們用 `unwrap` 處理的 `LockResult` 中。`MutexGuard` 型別實作了 `Deref` 以指向我們的內部資料；該型別還實作了 `Drop`，當 `MutexGuard` 超出 scope 時（這發生在內部 scope 結束時），會自動釋放 lock。因此，我們不會有忘記釋放 lock 並阻止其他 threads 使用 mutex 的風險，因為 lock 會自動釋放。

在 drop 掉 lock 之後，我們可以打印 mutex 值，並看到我們能夠將內部 `i32` 更改為 `6`。

#### 在多個 Threads 之間共享 Mutex<T>

現在讓我們嘗試使用 `Mutex<T>` 在多個 threads 之間共享一個值。我們將啟動 10 個 threads，讓它們每個將計數器值增加 1，這樣計數器將從 0 增加到 10。列表 16-13 中的範例將會有一個編譯器錯誤，我們將利用這個錯誤來學習更多關於使用 `Mutex<T>` 以及 Rust 如何幫助我們正確使用它的知識。

<span class="filename">src/main.rs</span>

```rust
use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Mutex::new(0);
    let mut handles = vec![];

    for _ in 0..10 {
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap());
}
```

列表 16-13：十個 threads，每個都增加一個由 `Mutex<T>` 保護的計數器

我們建立了一個 `counter` 變數來在 `Mutex<T>` 內部保存一個 `i32`，就像我們在列表 16-12 中做的那樣。接下來，我們透過迭代一系列數字來建立 10 個 threads。我們使用 `thread::spawn` 並給所有 threads 相同的 closure：一個將計數器移動到 thread 中，透過呼叫 `lock` 方法取得 `Mutex<T>` 的 lock，然後將 mutex 中的值加 1。當 thread 完成執行其 closure 時，`num` 將超出 scope 並釋放 lock，以便另一個 thread 可以取得它。

在主 thread 中，我們收集所有 join handles。然後，就像我們在列表 16-2 中所做的那樣，我們在每個 handle 上呼叫 `join` 以確保所有 threads 都完成。此時，主 thread 將取得 lock 並打印這個程式的結果。

我們暗示這個範例無法編譯。現在讓我們找出原因！

```
$ cargo run
   Compiling shared-state v0.1.0 (file:///projects/shared-state)
error[E0382]: borrow of moved value: `counter`
  --> src/main.rs:21:29
   |
5  |     let counter = Mutex::new(0);
   |         ------- move occurs because `counter` has type `Mutex<i32>`, which does not implement the `Copy` trait
...
8  |     for _ in 0..10 {
   |     -------------- inside of this loop
9  |         let handle = thread::spawn(move || {
   |                                    ------- value moved into closure here, in previous iteration of loop
...
21 |     println!("Result: {}", *counter.lock().unwrap());
   |                             ^^^^^^^ value borrowed here after move
   |
help: consider moving the expression out of the loop so it is only moved once
   |
8  ~     let mut value = counter.lock();
9  ~     for _ in 0..10 {
10 |         let handle = thread::spawn(move || {
11 ~             let mut num = value.unwrap();
   |

For more information about this error, try `rustc --explain E0382`.
error: could not compile `shared-state` (bin "shared-state") due to 1 previous error
```

錯誤訊息指出 `counter` 值在迴圈的上一次迭代中被移動了。Rust 告訴我們不能將 lock `counter` 的 ownership 移動到多個 threads 中。讓我們用我們在第 15 章討論過的多重 ownership 方法來修復這個編譯器錯誤。

#### 多執行緒下的多重 Ownership

在第 15 章，我們透過使用智能指標 `Rc<T>` 建立一個 reference counted value 來將一個值賦予多個 owner。讓我們在這裡也這樣做，看看會發生什麼。我們將在列表 16-14 中將 `Mutex<T>` 包裝在 `Rc<T>` 中，並在將 ownership 移動到 thread 之前複製 `Rc<T>`。

<span class="filename">src/main.rs</span>

```rust
use std::rc::Rc;
use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Rc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Rc::clone(&counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap());
}
```

列表 16-14：嘗試使用 `Rc<T>` 允許多個 threads 擁有 `Mutex<T>`

再一次，我們編譯並得到了……不同的錯誤！編譯器教會了我們很多東西。

```
$ cargo run
   Compiling shared-state v0.1.0 (file:///projects/shared-state)
error[E0277]: `Rc<Mutex<i32>>` cannot be sent between threads safely
  --> src/main.rs:11:36
   |
11 |           let handle = thread::spawn(move || {
   |                        ------------- ^------
   |                        |             |
   |  ______________________|_____________within this `{closure@src/main.rs:11:36: 11:43}`
   | |                      |
   | |                      required by a bound introduced by this call
12 | |             let mut num = counter.lock().unwrap();
13 | |
14 | |             *num += 1;
15 | |         });
   | |_________^ `Rc<Mutex<i32>>` cannot be sent between threads safely
   |
   = help: within `{closure@src/main.rs:11:36: 11:43}`, the trait `Send` is not implemented for `Rc<Mutex<i32>>`
note: required because it's used within this closure
  --> src/main.rs:11:36
   |
11 |         let handle = thread::spawn(move || {
   |                                    ^^^^^^^
note: required by a bound in `spawn`
  --> /rustc/4eb161250e340c8f48f66e2b929ef4a5bed7c181/library/std/src/thread/mod.rs:728:1

For more information about this error, try `rustc --explain E0277`.
error: could not compile `shared-state` (bin "shared-state") due to 1 previous error
```

哇，這錯誤訊息真囉嗦！這裡最重要的部分是：「`Rc<Mutex<i32>>` 不能在 threads 之間安全地傳送。」編譯器也告訴了我們原因：「`Send` trait 沒有為 `Rc<Mutex<i32>>` 實作。」我們將在下一節討論 `Send`：它是確保我們與 threads 一起使用的型別適用於並行情況的 traits 之一。

不幸的是，`Rc<T>` 無法安全地在 threads 之間共享。當 `Rc<T>` 管理 reference count 時，它在每次呼叫 `clone` 時增加計數，並在每個 clone 被 drop 時減少計數。但它沒有使用任何 concurrency primitives 來確保計數的更改不會被另一個 thread 中斷。這可能導致錯誤的計數——微妙的錯誤，進而可能導致記憶體洩漏或一個值在我們完成使用之前就被 drop 掉。我們需要的是一個與 `Rc<T>` 完全相同的型別，但能以 thread-safe 的方式修改 reference count。

#### 使用 Arc<T> 進行原子參考計數

幸運的是，`Arc<T>` *是*一種像 `Rc<T>` 那樣在並行情況下可以安全使用的型別。_a_ 代表 _atomic_，意思是它是一個 _原子參考計數 (atomically reference-counted)_ 型別。原子操作是另一種並行原語，我們在這裡不會詳細介紹：更多細節請參閱 `std::sync::atomic` 的標準函式庫文件。此時，你只需要知道原子操作像 primitive types 一樣工作，但可以安全地在 threads 之間共享。

你可能會想，為什麼所有 primitive types 都不是原子的，以及為什麼標準函式庫的型別預設不實作 `Arc<T>`。原因在於 thread 安全性會帶來效能損失，你只會在真正需要時才願意付出這種代價。如果你只是在單一 thread 內對值執行操作，你的程式碼如果不需要強制原子操作提供的保證，就可以執行得更快。

讓我們回到我們的範例：`Arc<T>` 和 `Rc<T>` 有著相同的 API，所以我們透過更改 `use` 行、對 `new` 的呼叫以及對 `clone` 的呼叫來修復我們的程式。列表 16-15 中的程式碼最終將會編譯並執行。

<span class="filename">src/main.rs</span>

```rust
use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap());
}
```

列表 16-15：使用 `Arc<T>` 包裝 `Mutex<T>` 以便在多個 threads 之間共享 ownership

這段程式碼將打印以下內容：

```
Result: 10
```

我們成功了！我們從 0 數到 10，這可能看起來不是很令人印象深刻，但它確實教會了我們很多關於 `Mutex<T>` 和 thread 安全性的知識。你也可以使用這個程式的結構來執行比僅增加計數器更複雜的操作。使用此策略，你可以將計算分成獨立的部分，將這些部分分配到不同的 threads 中，然後使用 `Mutex<T>` 讓每個 thread 用其部分更新最終結果。

請注意，如果你正在進行簡單的數值運算，標準函式庫的 `std::sync::atomic` 模組提供了比 `Mutex<T>` 型別更簡單的型別。這些型別提供了安全、並行、原子地存取 primitive types 的功能。我們選擇在此範例中使用 `Mutex<T>` 與 primitive type，以便我們能夠專注於 `Mutex<T>` 的運作方式。

### RefCell<T>/Rc<T> 與 Mutex<T>/Arc<T> 之間的相似性

你可能已經注意到 `counter` 是 immutable 的，但我們可以取得其內部值的 mutable reference；這意味著 `Mutex<T>` 提供了 interior mutability，就像 `Cell` 家族所做的那樣。我們在第 15 章使用 `RefCell<T>` 允許我們在 `Rc<T>` 內部修改內容，同樣地，我們使用 `Mutex<T>` 在 `Arc<T>` 內部修改內容。

另一個需要注意的細節是，當你使用 `Mutex<T>` 時，Rust 無法保護你免受所有類型的邏輯錯誤。回想一下第 15 章，使用 `Rc<T>` 存在產生 reference cycles 的風險，即兩個 `Rc<T>` 值互相參考，導致記憶體洩漏。類似地，`Mutex<T>` 存在產生 _deadlocks (死鎖)_ 的風險。當一個操作需要鎖定兩個資源，而兩個 threads 各自取得其中一個鎖定時，就會發生死鎖，導致它們永遠互相等待。如果你對死鎖感興趣，試著建立一個有死鎖的 Rust 程式；然後研究任何語言中 mutexes 的死鎖緩解策略，並嘗試在 Rust 中實作它們。`Mutex<T>` 和 `MutexGuard` 的標準函式庫 API 文件提供了有用的資訊。

我們將透過討論 `Send` 和 `Sync` traits 以及如何將它們與自訂型別一起使用來結束本章。

## 透過 Send 和 Sync Traits 擴展並行能力

有趣的是，本章到目前為止我們討論的幾乎所有並行功能都是標準函式庫的一部分，而不是語言本身。你處理並行的方式不限於語言或標準函式庫；你可以編寫自己的並行功能或使用他人編寫的功能。

然而，嵌入在語言而非標準函式庫中的關鍵並行概念是 `std::marker` traits `Send` 和 `Sync`。

### 透過 Send 允許 ownership 在 Threads 之間轉移

`Send` 標記 trait 表示實作 `Send` 的型別的 ownership 可以在 threads 之間轉移。幾乎所有 Rust 型別都實作了 `Send`，但也有一些例外，包括 `Rc<T>`：它無法實作 `Send`，因為如果你複製一個 `Rc<T>` 值並嘗試將複製品的 ownership 轉移到另一個 thread，兩個 threads 可能會同時更新 reference count。因此，`Rc<T>` 是為單執行緒情況設計的，你不希望為 thread-safe 支付效能損失。

因此，Rust 的型別系統和 trait bounds 確保你永遠不會不安全地意外地在 threads 之間傳送 `Rc<T>` 值。當我們在列表 16-14 中嘗試這樣做時，我們得到了錯誤：「`Send` trait 沒有為 `Rc<Mutex<i32>>` 實作。」當我們切換到實作了 `Send` 的 `Arc<T>` 時，程式碼就編譯成功了。

任何完全由 `Send` 型別組成的型別，也會自動被標記為 `Send`。除了 raw pointers 之外，幾乎所有 primitive types 都是 `Send`，我們將在第 20 章討論 raw pointers。

### 透過 Sync 允許從多個 Threads 存取

`Sync` 標記 trait 表示實作 `Sync` 的型別可以安全地從多個 threads 參考。換句話說，如果 `&T` (對 `T` 的 immutable reference) 實作了 `Send`，則任何型別 `T` 都實作了 `Sync`，這意味著該 reference 可以安全地發送到另一個 thread。類似於 `Send`，primitive types 都實作了 `Sync`，並且完全由實作 `Sync` 的型別組成的型別也實作了 `Sync`。

智能指標 `Rc<T>` 也沒有實作 `Sync`，原因與它沒有實作 `Send` 相同。`RefCell<T>` 型別（我們在第 15 章討論過）以及相關的 `Cell<T>` 型別家族都沒有實作 `Sync`。`RefCell<T>` 在 runtime 進行的借用檢查實作並非 thread-safe。智能指標 `Mutex<T>` 實作了 `Sync`，並且可以用於與多個 threads 共享存取，正如你在「在多個 Threads 之間共享 `Mutex<T>`」一節中看到的。

### 手動實作 Send 和 Sync 是不安全的

由於完全由實作 `Send` 和 `Sync` traits 的其他型別組成的型別也會自動實作 `Send` 和 `Sync`，我們不需要手動實作這些 traits。作為標記 traits，它們甚至沒有任何方法需要實作。它們只是用於強制執行與並行相關的不變式。

手動實作這些 traits 涉及實作 unsafe Rust 程式碼。我們將在第 20 章討論使用 unsafe Rust 程式碼；目前，重要的資訊是，建構不由 `Send` 和 `Sync` 部分組成的新並行型別需要仔細考慮以維持安全保證。_《Rustonomicon》_ (`https://doc.rust-lang.org/book/../nomicon/index.html`) 提供了更多關於這些保證以及如何維持它們的資訊。

## 總結

這不是本書中你最後一次看到並行：下一章將重點介紹 async 程式設計，第 21 章中的專案將在比這裡討論的小範例更現實的情況下使用本章中的概念。

如前所述，由於 Rust 處理並行的方式很少是語言本身的一部分，許多並行解決方案都實作為 crates。這些 crates 的演化速度比標準函式庫快，因此務必在線上搜尋目前最先進的 crates，以便在多執行緒環境中使用。

Rust 標準函式庫提供了用於訊息傳遞的 channels 以及智能指標型別，例如 `Mutex<T>` 和 `Arc<T>`，這些型別在並行環境中可以安全使用。型別系統和借用檢查器確保使用這些解決方案的程式碼不會出現 data races 或無效的 reference。一旦你的程式碼編譯成功，你就可以放心，它將愉快地在多個 threads 上運行，而不會出現其他語言中常見的難以追蹤的 bugs。並行程式設計不再是一個令人畏懼的概念：勇敢地去實現你的並行程式吧，無懼地！
