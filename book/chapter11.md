<!-- DO NOT EDIT THIS FILE.

This file is periodically generated from the content in the `/src/`
directory, so all fixes need to be made in `/src/`.
-->

[TOC]

# 撰寫自動化測試

Edsger W. Dijkstra 在他 1972 年的文章《謙卑的程式設計師》中說道：「程式測試可以是非常有效的方式來揭示 bug 的存在，但對於證明 bug 不存在卻是無可救藥地不足。」這並不意味著我們不應該盡可能地多做測試！

程式的正確性是指我們的程式碼在多大程度上符合我們的預期。Rust 在設計時高度關注程式的正確性，但正確性是複雜且不易證明的。Rust 的型別系統承擔了這項重任的一大部分，但型別系統無法捕捉所有問題。因此，Rust 內建了撰寫自動化軟體測試的支援。

假設我們寫了一個 `add_two` 函式，它會將傳入的數字加上 2。這個函式的簽名接受一個整數作為參數，並回傳一個整數作為結果。當我們實作並編譯這個函式時，Rust 會執行你至今所學的所有型別檢查和 borrow 檢查，以確保我們不會傳遞 `String` 值或無效的 reference 給這個函式。但 Rust *無法*檢查這個函式是否會精確地執行我們的意圖，也就是回傳參數加 2，而不是參數加 10 或參數減 50！這就是測試發揮作用的地方。

我們可以撰寫測試來斷言，例如，當我們將 `3` 傳遞給 `add_two` 函式時，回傳的值是 `5`。每當我們對程式碼進行變更時，我們都可以執行這些測試，以確保任何現有的正確行為都沒有改變。

測試是一項複雜的技能：雖然我們無法在一章之內涵蓋如何撰寫良好測試的每個細節，但在本章中，我們將討論 Rust 測試機制的原理。我們將討論撰寫測試時可用的標註和 macro、執行測試時的預設行為和選項，以及如何將測試組織成 unit test 和 integration test。

## 如何撰寫測試

測試是 Rust 函式，用於驗證非測試程式碼是否以預期的方式運作。測試函式的本體通常會執行以下三個動作：

- 設定任何需要的資料或狀態。
- 執行你想要測試的程式碼。
- 斷言結果符合你的預期。

讓我們來看看 Rust 專門為撰寫測試提供的功能，這些功能可以執行上述動作，包括 `test` 屬性、一些 macro，以及 `should_panic` 屬性。

### 測試函式的剖析

最簡單來說，Rust 中的測試是一個用 `test` 屬性標註的函式。屬性是關於 Rust 程式碼片段的中繼資料；其中一個例子是我們在第 5 章中用於 struct 的 `derive` 屬性。要將一個函式變成測試函式，請在 `fn` 前一行加上 `#[test]`。當你用 `cargo test` 指令執行測試時，Rust 會建立一個測試執行器二進位檔，該檔案會執行被標註的函式，並報告每個測試函式是通過還是失敗。

每當我們用 Cargo 建立一個新的 library 專案時，都會自動為我們產生一個包含測試函式的測試模組。這個模組提供了一個撰寫測試的樣板，這樣你每次開始新專案時就不必查找確切的結構和語法。你可以隨意增加任意數量的額外測試函式和測試模組！

在我們實際測試任何程式碼之前，我們將透過實驗樣板測試來探索測試運作的某些面向。然後，我們將撰寫一些真實世界的測試，呼叫我們寫的一些程式碼，並斷言其行為是正確的。

讓我們建立一個名為 `adder` 的新 library 專案，它會將兩個數字相加：

```
$ cargo new adder --lib
     Created library `adder` project
$ cd adder
```

你的 `adder` library 中 _src/lib.rs_ 檔案的內容應該如列表 11-1 所示。

src/lib.rs

<!-- manual-regeneration
cd listings/ch11-writing-automated-tests
rm -rf listing-11-01
cargo new listing-11-01 --lib --name adder
cd listing-11-01
echo "$ cargo test" > output.txt
RUSTFLAGS="-A unused_variables -A dead_code" RUST_TEST_THREADS=1 cargo test >> output.txt 2>&1
git diff output.txt # commit any relevant changes; discard irrelevant ones
cd ../../..
-->

```rust
pub fn add(left: u64, right: u64) -> u64 {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
}
```

列表 11-1：`cargo new` 自動產生的程式碼

檔案開頭是一個範例 `add` 函式，這樣我們就有東西可以測試。

目前，我們先專注於 `it_works` 函式。注意 `#[test]` 標註：這個屬性表示這是一個測試函式，所以測試執行器知道要將這個函式視為測試。我們也可能在 `tests` 模組中有非測試的函式，用來幫助設定通用場景或執行通用操作，所以我們總是需要標明哪些函式是測試。

範例函式的本體使用 `assert_eq!` macro 來斷言 `result`（其中包含呼叫 `add` 並傳入 2 和 2 的結果）等於 4。這個斷言作為典型測試格式的一個例子。讓我們執行它，看看這個測試是否通過。

`cargo test` 指令會執行我們專案中的所有測試，如列表 11-2 所示。

```
$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.57s
     Running unittests src/lib.rs (target/debug/deps/adder-01ad14159ff659ab)

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
```

列表 11-2：執行自動產生的測試後的輸出

Cargo 編譯並執行了測試。我們看到 `running 1 test` 這一行。下一行顯示了產生的測試函式名稱，稱為 `tests::it_works`，以及執行該測試的結果是 `ok`。總結 `test result: ok.` 表示所有測試都通過了，而 `1 passed; 0 failed` 部分則總計了通過或失敗的測試數量。

我們可以將一個測試標記為忽略，使其在特定情況下不執行；我們將在本章後面的「忽略某些測試，除非特別要求」一節中討論。因為我們在這裡沒有這樣做，所以摘要顯示 `0 ignored`。我們也可以傳遞一個參數給 `cargo test` 指令，只執行名稱符合某字串的測試；這稱為_篩選_，我們將在「依名稱執行部分的測試」一節中討論。在這裡我們沒有篩選要執行的測試，所以摘要的結尾顯示 `0 filtered out`。

`0 measured` 統計數據是用於測量效能的 benchmark test。截至本文撰寫時，benchmark test 僅在 nightly Rust 中可用。請參閱 _https://doc.rust-lang.org/unstable-book/library-features/test.html_ 中關於 benchmark test 的文件以了解更多資訊。

測試輸出的下一部分，從 `Doc-tests adder` 開始，是任何文件測試的結果。我們目前還沒有任何文件測試，但 Rust 可以編譯出現在我們 API 文件中的任何程式碼範例。這個功能有助於讓你的文件和程式碼保持同步！我們將在第 14 章的「文件註解作為測試」一節中討論如何撰寫文件測試。目前，我們將忽略 `Doc-tests` 的輸出。

讓我們開始根據自己的需求自訂測試。首先，將 `it_works` 函式的名稱改為不同的名稱，例如 `exploration`，如下所示：

檔案名稱：src/lib.rs

```rust
pub fn add(left: u64, right: u64) -> u64 {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn exploration() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
}
```

然後再次執行 `cargo test`。輸出現在會顯示 `exploration` 而不是 `it_works`：

```
$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.59s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::exploration ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
```

現在我們將新增另一個測試，但這次我們要做一個會失敗的測試！當測試函式中的某些東西 panic 時，測試就會失敗。每個測試都在一個新的 thread 中執行，當主 thread 看到一個測試 thread 已經死亡時，該測試就會被標記為失敗。在第 9 章中，我們談到最簡單的 panic 方式是呼叫 `panic!` macro。將新的測試輸入為名為 `another` 的函式，這樣你的 _src/lib.rs_ 檔案就會如列表 11-3 所示。

src/lib.rs

```rust
pub fn add(left: u64, right: u64) -> u64 {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn exploration() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }

    #[test]
    fn another() {
        panic!("Make this test fail");
    }
}
```

列表 11-3：新增第二個會因呼叫 `panic!` macro 而失敗的測試

再次使用 `cargo test` 執行測試。輸出應該如列表 11-4 所示，顯示我們的 `exploration` 測試通過了，而 `another` 失敗了。

```
$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.72s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 2 tests
test tests::another ... FAILED
test tests::exploration ... ok

failures:

---- tests::another stdout ----

thread 'tests::another' panicked at src/lib.rs:17:9:
Make this test fail
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::another

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
```

列表 11-4：一個測試通過、一個測試失敗時的測試結果

<!-- manual-regeneration
rg panicked listings/ch11-writing-automated-tests/listing-11-03/output.txt
check the line number of the panic matches the line number in the following paragraph
 -->

`test tests::another` 這一行顯示的是 `FAILED` 而不是 `ok`。在個別結果和摘要之間出現了兩個新的區塊：第一個區塊顯示每個測試失敗的詳細原因。在這種情況下，我們得到的細節是 `tests::another` 失敗了，因為它在 _src/lib.rs_ 檔案的第 17 行 panic 了，訊息是 `Make this test fail`。下一個區塊僅列出所有失敗測試的名稱，這在有很多測試和很多詳細失敗測試輸出時很有用。我們可以使用失敗測試的名稱來只執行該測試，以便更容易地進行除錯；我們將在「控制測試的執行方式」一節中更多地討論執行測試的方式。

摘要行顯示在最後：總體來說，我們的測試結果是 `FAILED`。我們有一個測試通過，一個測試失敗。

現在你已經看過不同情況下的測試結果，讓我們來看看除了 `panic!` 之外，在測試中有用的其他一些 macro。

### 使用 `assert!` Macro 檢查結果

標準函式庫提供的 `assert!` macro 在你想要確保測試中的某個條件評估為 `true` 時很有用。我們給 `assert!` macro 一個會評估為布林值的參數。如果值是 `true`，什麼都不會發生，測試通過。如果值是 `false`，`assert!` macro 會呼叫 `panic!` 使測試失敗。使用 `assert!` macro 有助於我們檢查程式碼是否按照我們預期的方式運作。

在第 5 章的列表 5-15 中，我們使用了一個 `Rectangle` struct 和一個 `can_hold` 方法，這裡在列表 11-5 中重複它們。讓我們把這段程式碼放到 _src/lib.rs_ 檔案中，然後使用 `assert!` macro 為它撰寫一些測試。

src/lib.rs

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}
```

列表 11-5：來自第 5 章的 `Rectangle` struct 及其 `can_hold` 方法

`can_hold` 方法回傳一個布林值，這意味著它是 `assert!` macro 的完美使用案例。在列表 11-6 中，我們撰寫一個測試來運用 `can_hold` 方法，方法是建立一個寬度為 8、高度為 7 的 `Rectangle` 實例，並斷言它可以容納另一個寬度為 5、高度為 1 的 `Rectangle` 實例。

src/lib.rs

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        let larger = Rectangle {
            width: 8,
            height: 7,
        };
        let smaller = Rectangle {
            width: 5,
            height: 1,
        };

        assert!(larger.can_hold(&smaller));
    }
}
```

列表 11-6：一個針對 `can_hold` 的測試，檢查較大的矩形是否確實能容納較小的矩形

注意 `tests` 模組內的 `use super::*;` 這一行。`tests` 模組是一個常規模組，遵循我們在第 7 章「用路徑參照模組樹中的項目」一節中介紹的常用可見性規則。因為 `tests` 模組是一個內部模組，我們需要將外部模組中待測的程式碼引入內部模組的範圍。我們在這裡使用 glob，所以我們在外部模組中定義的任何東西都可以在這個 `tests` 模組中使用。

我們將測試命名為 `larger_can_hold_smaller`，並建立了我們需要的兩個 `Rectangle` 實例。然後我們呼叫 `assert!` macro 並傳入呼叫 `larger.can_hold(&smaller)` 的結果。這個表達式應該回傳 `true`，所以我們的測試應該會通過。讓我們來看看！

```
$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)

running 1 test
test tests::larger_can_hold_smaller ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests rectangle

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
```

它通過了！讓我們再新增一個測試，這次斷言一個較小的矩形不能容納一個較大的矩形：

檔案名稱：src/lib.rs

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        // --snip--
    }

    #[test]
    fn smaller_cannot_hold_larger() {
        let larger = Rectangle {
            width: 8,
            height: 7,
        };
        let smaller = Rectangle {
            width: 5,
            height: 1,
        };

        assert!(!smaller.can_hold(&larger));
    }
}
```

因為在這種情況下 `can_hold` 函式的正確結果是 `false`，我們需要將該結果取反後再傳遞給 `assert!` macro。因此，如果 `can_hold` 回傳 `false`，我們的測試將會通過：

```
$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)

running 2 tests
test tests::larger_can_hold_smaller ... ok
test tests::smaller_cannot_hold_larger ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests rectangle

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
```

兩個測試都通過了！現在讓我們看看當我們在程式碼中引入一個 bug 時，我們的測試結果會發生什麼變化。我們將修改 `can_hold` 方法的實作，在比較寬度時將大於符號替換為小於符號：

```rust
// --snip--
impl Rectangle {
    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width < other.width && self.height > other.height
    }
}
```

現在執行測試會產生以下結果：

```
$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)

running 2 tests
test tests::larger_can_hold_smaller ... FAILED
test tests::smaller_cannot_hold_larger ... ok

failures:

---- tests::larger_can_hold_smaller stdout ----

thread 'tests::larger_can_hold_smaller' panicked at src/lib.rs:28:9:
assertion failed: larger.can_hold(&smaller)
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::larger_can_hold_smaller

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
```

我們的測試抓到了這個 bug！因為 `larger.width` 是 `8` 而 `smaller.width` 是 `5`，`can_hold` 中寬度的比較現在回傳 `false`：8 不小於 5。

### 使用 `assert_eq!` 與 `assert_ne!` Macro 測試相等性

一種常見的驗證功能的方式是測試待測程式碼的結果與你期望程式碼回傳的值是否相等。你可以使用 `assert!` macro 並傳入一個使用 `==` 運算子的表達式來做到這一點。然而，這是一個非常常見的測試，因此標準函式庫提供了一對 macro——`assert_eq!` 和 `assert_ne!`——來更方便地執行這個測試。這些 macro 分別比較兩個參數是否相等或不相等。如果斷言失敗，它們還會印出這兩個值，這使得更容易看出測試*為何*失敗；相反地，`assert!` macro 只會指出它得到的 `==` 表達式的值是 `false`，而不會印出導致 `false` 值的數值。

在列表 11-7 中，我們撰寫了一個名為 `add_two` 的函式，它會將其參數加上 `2`，然後我們使用 `assert_eq!` macro 來測試這個函式。

src/lib.rs

```rust
pub fn add_two(a: u64) -> u64 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_adds_two() {
        let result = add_two(2);
        assert_eq!(result, 4);
    }
}
```

列表 11-7：使用 `assert_eq!` macro 測試 `add_two` 函式

讓我們檢查它是否通過！

```
$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.58s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
```

我們建立了一個名為 `result` 的變數，它儲存了呼叫 `add_two(2)` 的結果。然後我們將 `result` 和 `4` 作為參數傳遞給 `assert_eq!` macro。這個測試的輸出行為 `test tests::it_adds_two ... ok`，而 `ok` 文字表示我們的測試通過了！

讓我們在程式碼中引入一個 bug，看看 `assert_eq!` 在失敗時是什麼樣子。將 `add_two` 函式的實作改為加上 `3`：

```rust
pub fn add_two(a: u64) -> u64 {
    a + 3
}
```

再次執行測試：

```
$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.61s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::it_adds_two ... FAILED

failures:

---- tests::it_adds_two stdout ----

thread 'tests::it_adds_two' panicked at src/lib.rs:12:9:
assertion `left == right` failed
  left: 5
 right: 4
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::it_adds_two

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
```

我們的測試抓到了這個 bug！`tests::it_adds_two` 測試失敗了，訊息告訴我們失敗的斷言是 `left == right`，以及 `left` 和 `right` 的值是什麼。這個訊息幫助我們開始除錯：`left` 參數（我們呼叫 `add_two(2)` 的結果）是 `5`，但 `right` 參數是 `4`。你可以想像當我們有很多測試在進行時，這會特別有幫助。

請注意，在某些語言和測試框架中，相等性斷言函式的參數被稱為 `expected` 和 `actual`，並且我們指定參數的順序很重要。然而，在 Rust 中，它們被稱為 `left` 和 `right`，我們指定期望值和程式碼產生值的順序並不重要。我們可以將這個測試中的斷言寫成 `assert_eq!(4, result)`，這將導致同樣的失敗訊息，顯示 `assertion`left == right`failed`。

`assert_ne!` macro 在我們給它的兩個值不相等時會通過，相等時會失敗。這個 macro 在我們不確定某個值*會*是什麼，但我們知道它絕對*不應該*是什麼的情況下最有用。例如，如果我們正在測試一個保證會以某種方式改變其輸入的函式，但輸入改變的方式取決於我們執行測試的星期幾，那麼最好的斷言可能是函式的輸出不等於輸入。

在底層，`assert_eq!` 和 `assert_ne!` macro 分別使用 `==` 和 `!=` 運算子。當斷言失敗時，這些 macro 會使用除錯格式印出它們的參數，這意味著被比較的值必須實作 `PartialEq` 和 `Debug` trait。所有的基本型別和大部分的標準函式庫型別都實作了這些 trait。對於你自己定義的 struct 和 enum，你需要實作 `PartialEq` 來斷言這些型別的相等性。當斷言失敗時，你還需要實作 `Debug` 來印出值。因為這兩個 trait 都是可衍生的 trait，如第 5 章的列表 5-12 所述，這通常就像在你的 struct 或 enum 定義上加上 `#[derive(PartialEq, Debug)]` 標註一樣簡單。請參閱附錄 C「可衍生的 Trait」以獲取更多關於這些和其他可衍生 trait 的詳細資訊。

### 新增自訂失敗訊息

你也可以將自訂訊息作為可選參數新增到 `assert!`、`assert_eq!` 和 `assert_ne!` macro 中，與失敗訊息一起印出。在必要參數之後指定的任何參數都會傳遞給 `format!` macro（在第 8 章「使用 `+` 運算子或 `format!` Macro 進行串接」中討論），所以你可以傳遞一個包含 `{}` 佔位符的格式化字串以及要放入這些佔位符的值。自訂訊息對於記錄斷言的意義很有用；當測試失敗時，你會更清楚程式碼出了什麼問題。

例如，假設我們有一個函式，它會用名字來問候人們，我們想測試我們傳入函式的名字是否出現在輸出中：

檔案名稱：src/lib.rs

```rust
pub fn greeting(name: &str) -> String {
    format!("Hello {name}!")
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn greeting_contains_name() {
        let result = greeting("Carol");
        assert!(result.contains("Carol"));
    }
}
```

這個程式的需求還沒有定案，我們很確定問候語開頭的 `Hello` 文字會改變。我們決定當需求改變時，我們不想要更新測試，所以我們不檢查與 `greeting` 函式回傳值的精確相等性，我們只斷言輸出包含輸入參數的文字。

現在讓我們透過修改 `greeting` 來排除 `name` 來引入一個 bug，看看預設的測試失敗是什麼樣子：

```rust
pub fn greeting(name: &str) -> String {
    String::from("Hello!")
}
```

執行這個測試會產生以下結果：

```
$ cargo test
   Compiling greeter v0.1.0 (file:///projects/greeter)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.91s
     Running unittests src/lib.rs (target/debug/deps/greeter-170b942eb5bf5e3a)

running 1 test
test tests::greeting_contains_name ... FAILED

failures:

---- tests::greeting_contains_name stdout ----

thread 'tests::greeting_contains_name' panicked at src/lib.rs:12:9:
assertion failed: result.contains("Carol")
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::greeting_contains_name

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
```

這個結果只表示斷言失敗了，以及斷言在哪一行。一個更有用的失敗訊息會印出 `greeting` 函式的值。讓我們新增一個自訂的失敗訊息，它由一個格式化字串組成，其中包含一個佔位符，用我們從 `greeting` 函式得到的實際值來填補：

```rust
#[test]
fn greeting_contains_name() {
    let result = greeting("Carol");
    assert!(
        result.contains("Carol"),
        "Greeting did not contain name, value was `{result}`"
    );
}
```

現在當我們執行測試時，我們會得到一個更具資訊性的錯誤訊息：

```
$ cargo test
   Compiling greeter v0.1.0 (file:///projects/greeter)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.93s
     Running unittests src/lib.rs (target/debug/deps/greeter-170b942eb5bf5e3a)

running 1 test
test tests::greeting_contains_name ... FAILED

failures:

---- tests::greeting_contains_name stdout ----

thread 'tests::greeting_contains_name' panicked at src/lib.rs:12:9:
Greeting did not contain name, value was `Hello!`
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::greeting_contains_name

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
```

我們可以在測試輸出中看到我們實際得到的值，這將幫助我們除錯發生了什麼，而不是我們期望發生什麼。

### 使用 `should_panic` 檢查 Panic

除了檢查回傳值，檢查我們的程式碼是否如預期處理錯誤情況也很重要。例如，考慮我們在第 9 章，列表 9-13 中建立的 `Guess` 型別。使用 `Guess` 的其他程式碼依賴於 `Guess` 實例只會包含 1 到 100 之間的值的保證。我們可以撰寫一個測試，確保嘗試用超出該範圍的值建立 `Guess` 實例會 panic。

我們透過在我們的測試函式上新增 `should_panic` 屬性來做到這一點。如果函式內的程式碼 panic，測試就會通過；如果函式內的程式碼沒有 panic，測試就會失敗。

列表 11-8 顯示了一個測試，它檢查 `Guess::new` 的錯誤條件是否在我們預期時發生。

src/lib.rs

```rust
pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -> Guess {
        if value < 1 || value > 100 {
            panic!("Guess value must be between 1 and 100, got {value}.");
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic]
    fn greater_than_100() {
        Guess::new(200);
    }
}
```

列表 11-8：測試一個條件是否會導致 `panic!`

我們將 `#[should_panic]` 屬性放在 `#[test]` 屬性之後，並在它所應用的測試函式之前。讓我們看看當這個測試通過時的結果：

```
$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.58s
     Running unittests src/lib.rs (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::greater_than_100 - should panic ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests guessing_game

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
```

看起來不錯！現在讓我們在程式碼中引入一個 bug，方法是移除 `new` 函式在值大於 100 時會 panic 的條件：

```rust
// --snip--
impl Guess {
    pub fn new(value: i32) -> Guess {
        if value < 1 {
            panic!("Guess value must be between 1 and 100, got {value}.");
        }

        Guess { value }
    }
}
```

當我們執行列表 11-8 中的測試時，它會失敗：

```
$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.62s
     Running unittests src/lib.rs (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::greater_than_100 - should panic ... FAILED

failures:

---- tests::greater_than_100 stdout ----
note: test did not panic as expected

failures:
    tests::greater_than_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
```

在這種情況下，我們沒有得到非常有幫助的訊息，但當我們查看測試函式時，我們看到它被標註了 `#[should_panic]`。我們得到的失敗意味著測試函式中的程式碼沒有引起 panic。

使用 `should_panic` 的測試可能不夠精確。即使測試因為與我們預期的不同原因而 panic，`should_panic` 測試也會通過。為了使 `should_panic` 測試更精確，我們可以在 `should_panic` 屬性中新增一個可選的 `expected` 參數。測試工具會確保失敗訊息包含所提供的文字。例如，考慮列表 11-9 中 `Guess` 的修改後程式碼，其中 `new` 函式會根據值是太小還是太大而 panic 並帶有不同的訊息。

src/lib.rs

```rust
// --snip--

impl Guess {
    pub fn new(value: i32) -> Guess {
        if value < 1 {
            panic!(
                "Guess value must be greater than or equal to 1, got {value}."
            );
        } else if value > 100 {
            panic!(
                "Guess value must be less than or equal to 100, got {value}."
            );
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic(expected = "less than or equal to 100")]
    fn greater_than_100() {
        Guess::new(200);
    }
}
```

列表 11-9：測試 `panic!`，其 panic 訊息包含指定的子字串

這個測試將會通過，因為我們放在 `should_panic` 屬性的 `expected` 參數中的值是 `Guess::new` 函式 panic 時訊息的子字串。我們可以指定我們期望的完整 panic 訊息，在這種情況下會是 `Guess value must be less than or equal to 100, got 200`。你選擇指定什麼取決於 panic 訊息中有多少是獨特或動態的，以及你希望你的測試有多精確。在這種情況下，panic 訊息的子字串足以確保測試函式中的程式碼執行 `else if value > 100` 的情況。

為了看看帶有 `expected` 訊息的 `should_panic` 測試失敗時會發生什麼，讓我們再次在程式碼中引入一個 bug，方法是交換 `if value < 1` 和 `else if value > 100` 區塊的本體：

```rust
if value < 1 {
    panic!(
        "Guess value must be less than or equal to 100, got {value}."
    );
} else if value > 100 {
    panic!(
        "Guess value must be greater than or equal to 1, got {value}."
    );
}
```

這次當我們執行 `should_panic` 測試時，它會失敗：

```
$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::greater_than_100 - should panic ... FAILED

failures:

---- tests::greater_than_100 stdout ----

thread 'tests::greater_than_100' panicked at src/lib.rs:12:13:
Guess value must be greater than or equal to 1, got 200.
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
note: panic did not contain expected string
      panic message: `"Guess value must be greater than or equal to 1, got 200."`,
 expected substring: `"less than or equal to 100"`

failures:
    tests::greater_than_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
```

失敗訊息指出，這個測試確實如我們預期地 panic 了，但 panic 訊息沒有包含預期的字串 `less than or equal to 100`。在這種情況下，我們得到的 panic 訊息是 `Guess value must be greater than or equal to 1, got 200.` 現在我們可以開始找出我們的 bug 在哪裡了！

### 在測試中使用 `Result<T, E>`

到目前為止，我們的測試在失敗時都會 panic。我們也可以撰寫使用 `Result<T, E>` 的測試！這是列表 11-1 中的測試，改寫為使用 `Result<T, E>` 並在失敗時回傳 `Err` 而不是 panic：

```rust
    #[test]
    fn it_works() -> Result<(), String> {
        let result = add(2, 2);

        if result == 4 {
            Ok(())
        } else {
            Err(String::from("two plus two does not equal four"))
        }
    }
```

`it_works` 函式現在有 `Result<(), String>` 的回傳型別。在函式的本體中，我們不是呼叫 `assert_eq!` macro，而是在測試通過時回傳 `Ok(())`，在測試失敗時回傳一個包含 `String` 的 `Err`。

將測試撰寫成回傳 `Result<T, E>` 的形式，可以讓你在測試本體中使用問號運算子，這對於撰寫如果其中任何操作回傳 `Err` variant 就應該失敗的測試來說，是一種方便的方式。

你不能在用 `Result<T, E>` 的測試上使用 `#[should_panic]` 標註。要斷言一個操作回傳 `Err` variant，*不要*在 `Result<T, E>` 值上使用問號運算子。而是使用 `assert!(value.is_err())`。

現在你已經知道幾種撰寫測試的方法，讓我們來看看當我們執行測試時發生了什麼，並探索我們可以與 `cargo test` 一起使用的不同選項。

## 控制測試的執行方式

就像 `cargo run` 會編譯你的程式碼然後執行產生的二進位檔一樣，`cargo test` 會在測試模式下編譯你的程式碼並執行產生的測試二進位檔。由 `cargo test` 產生的二進位檔的預設行為是平行執行所有測試並捕獲測試執行期間產生的輸出，防止輸出被顯示出來，從而使閱讀與測試結果相關的輸出更容易。然而，你可以指定命令列選項來改變這種預設行為。

一些命令列選項是給 `cargo test` 的，一些是給產生的測試二進位檔的。要區分這兩種類型的參數，你先列出給 `cargo test` 的參數，然後是分隔符 `--`，接著是給測試二進位檔的參數。執行 `cargo test --help` 會顯示你可以與 `cargo test` 一起使用的選項，而執行 `cargo test -- --help` 會顯示你可以在分隔符後使用的選項。這些選項也記錄在 rustc 書籍 _https://doc.rust-lang.org/rustc/index.html_ 的「測試」章節 _https://doc.rust-lang.org/rustc/tests/index.html_ 中。

### 平行或循序執行測試

當你執行多個測試時，預設情況下它們會使用 thread 平行執行，這意味著它們會更快完成，你也能更快得到回饋。因為測試是同時執行的，你必須確保你的測試之間沒有相互依賴，也沒有依賴任何共享狀態，包括共享的環境，例如當前工作目錄或環境變數。

例如，假設你的每個測試都執行一些程式碼，在磁碟上建立一個名為 _test-output.txt_ 的檔案並寫入一些資料。然後每個測試讀取該檔案中的資料並斷言檔案包含一個特定的值，這個值在每個測試中都不同。因為測試是同時執行的，一個測試可能會在另一個測試寫入和讀取檔案之間覆寫該檔案。那麼第二個測試就會失敗，不是因為程式碼不正確，而是因為測試在平行執行時相互干擾了。一個解決方案是確保每個測試都寫入不同的檔案；另一個解決方案是逐一執行測試。

如果你不想平行執行測試，或者你想要更精細地控制使用的 thread 數量，你可以將 `--test-threads` 旗標和你想要使用的 thread 數量傳遞給測試二進位檔。看看下面的例子：

```
$ cargo test -- --test-threads=1
```

我們將測試 thread 的數量設定為 `1`，告訴程式不要使用任何平行處理。使用一個 thread 執行測試會比平行執行花更長的時間，但如果測試共享狀態，它們就不會相互干擾。

### 顯示函式輸出

預設情況下，如果一個測試通過，Rust 的測試函式庫會捕獲任何印到標準輸出的內容。例如，如果我們在測試中呼叫 `println!` 並且測試通過，我們將不會在終端機中看到 `println!` 的輸出；我們只會看到表示測試通過的那一行。如果一個測試失敗，我們將會看到印到標準輸出的任何內容，以及其餘的失敗訊息。

舉例來說，列表 11-10 有一個愚蠢的函式，它會印出其參數的值並回傳 10，以及一個會通過的測試和一個會失敗的測試。

src/lib.rs

```rust
fn prints_and_returns_10(a: i32) -> i32 {
    println!("I got the value {a}");
    10
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn this_test_will_pass() {
        let value = prints_and_returns_10(4);
        assert_eq!(value, 10);
    }

    #[test]
    fn this_test_will_fail() {
        let value = prints_and_returns_10(8);
        assert_eq!(value, 5);
    }
}
```

列表 11-10：一個呼叫 `println!` 的函式的測試

當我們用 `cargo test` 執行這些測試時，我們會看到以下輸出：

```
$ cargo test
   Compiling silly-function v0.1.0 (file:///projects/silly-function)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.58s
     Running unittests src/lib.rs (target/debug/deps/silly_function-160869f38cff9166)

running 2 tests
test tests::this_test_will_fail ... FAILED
test tests::this_test_will_pass ... ok

failures:

---- tests::this_test_will_fail stdout ----
I got the value 8

thread 'tests::this_test_will_fail' panicked at src/lib.rs:19:9:
assertion `left == right` failed
  left: 10
 right: 5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::this_test_will_fail

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
```

請注意，在這個輸出中我們完全沒有看到 `I got the value 4`，這是通過的測試執行時印出的。那個輸出被捕獲了。失敗的測試的輸出 `I got the value 8` 出現在測試摘要輸出的部分，該部分也顯示了測試失敗的原因。

如果我們也想看到通過測試的印出值，我們可以告訴 Rust 同時顯示成功測試的輸出，使用 `--show-output`：

```
$ cargo test -- --show-output
```

當我們再次用 `--show-output` 旗標執行列表 11-10 中的測試時，我們會看到以下輸出：

```
$ cargo test -- --show-output
   Compiling silly-function v0.1.0 (file:///projects/silly-function)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.60s
     Running unittests src/lib.rs (target/debug/deps/silly_function-160869f38cff9166)

running 2 tests
test tests::this_test_will_fail ... FAILED
test tests::this_test_will_pass ... ok

successes:

---- tests::this_test_will_pass stdout ----
I got the value 4


successes:
    tests::this_test_will_pass

failures:

---- tests::this_test_will_fail stdout ----
I got the value 8

thread 'tests::this_test_will_fail' panicked at src/lib.rs:19:9:
assertion `left == right` failed
  left: 10
 right: 5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::this_test_will_fail

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
```

### 依名稱執行部分的測試

有時候，執行完整的測試套件可能會花費很長時間。如果你正在處理特定區域的程式碼，你可能只想執行與該程式碼相關的測試。你可以透過將你想執行的測試名稱作為參數傳遞給 `cargo test` 來選擇要執行的測試。

為了示範如何執行一部分的測試，我們首先為我們的 `add_two` 函式建立三個測試，如列表 11-11 所示，然後選擇要執行哪些。

src/lib.rs

```rust
pub fn add_two(a: u64) -> u64 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn add_two_and_two() {
        let result = add_two(2);
        assert_eq!(result, 4);
    }

    #[test]
    fn add_three_and_two() {
        let result = add_two(3);
        assert_eq!(result, 5);
    }

    #[test]
    fn one_hundred() {
        let result = add_two(100);
        assert_eq!(result, 102);
    }
}
```

列表 11-11：三個不同名稱的測試

如果我們在不傳遞任何參數的情況下執行測試，如前所述，所有的測試都會平行執行：

```
$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.62s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 3 tests
test tests::add_three_and_two ... ok
test tests::add_two_and_two ... ok
test tests::one_hundred ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
```

#### 執行單一測試

我們可以將任何測試函式的名稱傳遞給 `cargo test`，只執行該測試：

```
$ cargo test one_hundred
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.69s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::one_hundred ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out; finished in 0.00s
```

只有名稱為 `one_hundred` 的測試被執行了；其他兩個測試不符合該名稱。測試輸出透過在結尾顯示 `2 filtered out` 來讓我們知道我們有更多未執行的測試。

我們不能用這種方式指定多個測試的名稱；只有傳遞給 `cargo test` 的第一個值會被使用。但是有一種方法可以執行多個測試。

#### 篩選以執行多個測試

我們可以指定測試名稱的一部分，任何名稱符合該值的測試都將被執行。例如，因為我們有兩個測試的名稱包含 `add`，我們可以透過執行 `cargo test add` 來執行這兩個測試：

```
$ cargo test add
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.61s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 2 tests
test tests::add_three_and_two ... ok
test tests::add_two_and_two ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out; finished in 0.00s
```

這個指令執行了所有名稱中包含 `add` 的測試，並篩選掉了名為 `one_hundred` 的測試。另外請注意，測試所在的模組會成為測試名稱的一部分，所以我們可以透過篩選模組名稱來執行模組中的所有測試。

### 忽略某些測試，除非特別要求

有時候，某些特定的測試執行起來可能非常耗時，所以你可能希望在大多數 `cargo test` 執行時排除它們。與其將所有你想執行的測試都作為參數列出，你不如使用 `ignore` 屬性來標註耗時的測試以排除它們，如下所示：

檔案名稱：src/lib.rs

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }

    #[test]
    #[ignore]
    fn expensive_test() {
        // code that takes an hour to run
    }
}
```

在 `#[test]` 之後，我們在想要排除的測試上加上 `#[ignore]` 這一行。現在當我們執行測試時，`it_works` 會執行，但 `expensive_test` 不會：

```
$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.60s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 2 tests
test tests::expensive_test ... ignored
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 1 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
```

`expensive_test` 函式被列為 `ignored`。如果我們只想執行被忽略的測試，我們可以使用 `cargo test -- --ignored`：

```
$ cargo test -- --ignored
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.61s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::expensive_test ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
```

透過控制執行的測試，你可以確保你的 `cargo test` 結果會很快返回。當你到了檢查 `ignored` 測試結果的時機，並且有時間等待結果時，你可以執行 `cargo test -- --ignored`。如果你想執行所有測試，無論它們是否被忽略，你可以執行 `cargo test -- --include-ignored`。

## 測試的組織

如本章開頭所述，測試是一門複雜的學問，不同的人使用不同的術語和組織方式。Rust 社群將測試分為兩大類：unit test 和 integration test。_Unit test_ 規模較小且更專注，一次只在隔離的環境中測試一個模組，並且可以測試私有介面。_Integration test_ 完全在你的 library 外部，以與任何其他外部程式碼相同的方式使用你的程式碼，只使用公開的介面，並且每個測試可能涉及多個模組。

撰寫這兩種測試對於確保你的 library 的各個部分各自獨立以及協同運作時都能如你預期地運作，都是很重要的。

### Unit 測試

unit test 的目的是在與其餘程式碼隔離的情況下測試每個程式碼單元，以快速定位程式碼在哪裡正常運作，在哪裡不正常運作。你會將 unit test 放在 _src_ 目錄下，與它們所測試的程式碼放在同一個檔案中。慣例是在每個檔案中建立一個名為 `tests` 的模組來包含測試函式，並用 `cfg(test)` 來標註該模組。

#### `tests` 模組與 `#[cfg(test)]`

在 `tests` 模組上的 `#[cfg(test)]` 標註告訴 Rust 只有在你執行 `cargo test` 時才編譯和執行測試程式碼，而不是在你執行 `cargo build` 時。這在你只想建置 library 時可以節省編譯時間，並且因為測試不被包含在內，所以可以節省最終編譯成品的空間。你會看到，因為 integration test 放在不同的目錄中，它們不需要 `#[cfg(test)]` 標註。然而，因為 unit test 和程式碼放在同一個檔案中，你會使用 `#[cfg(test)]` 來指定它們不應該被包含在編譯結果中。

回想一下，當我們在本章第一節產生新的 `adder` 專案時，Cargo 為我們產生了這段程式碼：

檔案名稱：src/lib.rs

```rust
pub fn add(left: u64, right: u64) -> u64 {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
}
```

在自動產生的 `tests` 模組上，屬性 `cfg` 代表_configuration_，它告訴 Rust 後面的項目只有在給定某個設定選項時才應該被包含。在這種情況下，設定選項是 `test`，這是由 Rust 為編譯和執行測試提供的。透過使用 `cfg` 屬性，Cargo 只有在我們用 `cargo test` 主動執行測試時才會編譯我們的測試程式碼。這包括這個模組中任何可能的輔助函式，以及用 `#[test]` 標註的函式。

#### 測試私有函式

在測試社群中，對於是否應該直接測試私有函式存在爭議，而其他語言使得測試私有函式變得困難或不可能。無論你遵循哪種測試理念，Rust 的私有性規則確實允許你測試私有函式。考慮列表 11-12 中帶有私有函式 `internal_adder` 的程式碼。

src/lib.rs

```rust
pub fn add_two(a: u64) -> u64 {
    internal_adder(a, 2)
}

fn internal_adder(left: u64, right: u64) -> u64 {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn internal() {
        let result = internal_adder(2, 2);
        assert_eq!(result, 4);
    }
}
```

列表 11-12：測試一個私有函式

請注意，`internal_adder` 函式沒有標記為 `pub`。測試只是 Rust 程式碼，而 `tests` 模組也只是另一個模組。正如我們在「用路徑參照模組樹中的項目」中討論的，子模組中的項目可以使用其祖先模組中的項目。在這個測試中，我們用 `use super::*` 將 `tests` 模組父層的所有項目都引入作用域，然後測試就可以呼叫 `internal_adder`。如果你認為不應該測試私有函式，Rust 中沒有任何東西會強迫你這麼做。

### Integration 測試

在 Rust 中，integration test 完全在你的 library 外部。它們以與任何其他程式碼相同的方式使用你的 library，這意味著它們只能呼叫屬於你 library 公開 API 的函式。它們的目的是測試你 library 的許多部分是否能正確協同運作。各自獨立運作正常的程式碼單元在整合時可能會出現問題，因此對整合後的程式碼進行測試覆蓋也很重要。要建立 integration test，你首先需要一個 _tests_ 目錄。

#### `tests` 目錄

我們在專案目錄的頂層，與 _src_ 相鄰的位置建立一個 _tests_ 目錄。Cargo 知道在這個目錄中尋找 integration test 檔案。然後我們可以建立任意數量的測試檔案，Cargo 會將每個檔案編譯成一個獨立的 crate。

讓我們來建立一個 integration test。在 _src/lib.rs_ 檔案中仍保留列表 11-12 的程式碼的情況下，建立一個 _tests_ 目錄，並在其中建立一個名為 _tests/integration_test.rs_ 的新檔案。你的目錄結構應該如下：

```
adder
├── Cargo.lock
├── Cargo.toml
├── src
│   └── lib.rs
└── tests
    └── integration_test.rs
```

將列表 11-13 中的程式碼輸入到 _tests/integration_test.rs_ 檔案中。

tests/integration_test.rs

```rust
use adder::add_two;

#[test]
fn it_adds_two() {
    let result = add_two(2);
    assert_eq!(result, 4);
}
```

列表 11-13：`adder` crate 中一個函式的 integration test

_tests_ 目錄中的每個檔案都是一個獨立的 crate，所以我們需要將我們的 library 引入每個測試 crate 的作用域中。因此，我們在程式碼的頂部加上 `use adder::add_two;`，這在 unit test 中是不需要的。

我們不需要在 _tests/integration_test.rs_ 中的任何程式碼上標註 `#[cfg(test)]`。Cargo 會特別對待 _tests_ 目錄，只有在我們執行 `cargo test` 時才會編譯這個目錄中的檔案。現在執行 `cargo test`：

```
$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 1.31s
     Running unittests src/lib.rs (target/debug/deps/adder-1082c4b063a8fbe6)

running 1 test
test tests::internal ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/integration_test.rs (target/debug/deps/integration_test-1082c4b063a8fbe6)

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
```

輸出的三個區塊包括 unit test、integration test 和 doc test。請注意，如果某個區塊中的任何測試失敗，後續的區塊將不會執行。例如，如果一個 unit test 失敗，將不會有 integration test 和 doc test 的輸出，因為這些測試只在所有 unit test 都通過時才會執行。

第一個 unit test 區塊和我們之前看到的一樣：每個 unit test 一行（一個我們在列表 11-12 中新增的名為 `internal` 的測試），然後是 unit test 的摘要行。

integration test 區塊以 `Running tests/integration_test.rs` 這一行開始。接下來，該 integration test 中的每個測試函式都有一行，然後在 `Doc-tests adder` 區塊開始之前，是該 integration test 結果的摘要行。

每個 integration test 檔案都有自己的區塊，所以如果我們在 _tests_ 目錄中新增更多檔案，就會有更多的 integration test 區塊。

我們仍然可以透過將測試函式的名稱作為 `cargo test` 的參數來執行特定的 integration test 函式。要執行特定 integration test 檔案中的所有測試，請使用 `cargo test` 的 `--test` 參數，後面跟著檔案名稱：

```
$ cargo test --test integration_test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.64s
     Running tests/integration_test.rs (target/debug/deps/integration_test-82e7799c1bc62298)

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
```

這個指令只執行 _tests/integration_test.rs_ 檔案中的測試。

#### Integration 測試中的子模組

當你新增更多的 integration test 時，你可能會想在 _tests_ 目錄中建立更多的檔案來幫助組織它們；例如，你可以根據它們測試的功能來將測試函式分組。如前所述，_tests_ 目錄中的每個檔案都被編譯成自己獨立的 crate，這對於建立獨立的作用域以更貼近最終使用者使用你 crate 的方式很有用。然而，這意味著 _tests_ 目錄中的檔案與 _src_ 中的檔案行為不同，正如你在第 7 章中學到的關於如何將程式碼分離到模組和檔案中的那樣。

當你有一組輔助函式要在多個 integration test 檔案中使用，並且你試圖遵循第 7 章「將模組分離到不同檔案」一節中的步驟將它們提取到一個共用模組時，_tests_ 目錄檔案的不同行為最為明顯。例如，如果我們建立 _tests/common.rs_ 並在其中放置一個名為 `setup` 的函式，我們可以將一些我們想從多個測試檔案中的多個測試函式呼叫的程式碼加入 `setup` 中：

檔案名稱：tests/common.rs

```rust
pub fn setup() {
    // setup code specific to your library's tests would go here
}
```

當我們再次執行測試時，我們會在測試輸出中看到一個新的 _common.rs_ 檔案的區塊，即使這個檔案不包含任何測試函式，我們也沒有從任何地方呼叫 `setup` 函式：

```
$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.89s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::internal ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/common.rs (target/debug/deps/common-92948b65e88960b4)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/integration_test.rs (target/debug/deps/integration_test-92948b65e88960b4)

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
```

在測試結果中出現 `common` 並顯示 `running 0 tests` 並不是我們想要的。我們只是想與其他 integration test 檔案共用一些程式碼。為了避免 `common` 出現在測試輸出中，我們將建立 _tests/common/mod.rs_ 而不是 _tests/common.rs_。專案目錄現在看起來像這樣：

```
├── Cargo.lock
├── Cargo.toml
├── src
│   └── lib.rs
└── tests
    ├── common
    │   └── mod.rs
    └── integration_test.rs
```

這是我們在第 7 章「替代檔案路徑」中提到的 Rust 也理解的舊命名慣例。用這種方式命名檔案告訴 Rust 不要將 `common` 模組視為一個 integration test 檔案。當我們將 `setup` 函式的程式碼移到 _tests/common/mod.rs_ 並刪除 _tests/common.rs_ 檔案後，測試輸出中的那個區塊就不會再出現了。_tests_ 目錄子目錄中的檔案不會被編譯成獨立的 crate，也不會在測試輸出中有自己的區塊。

在我們建立 _tests/common/mod.rs_ 之後，我們可以從任何 integration test 檔案中將它作為一個模組來使用。這是一個從 _tests/integration_test.rs_ 的 `it_adds_two` 測試中呼叫 `setup` 函式的例子：

檔案名稱：tests/integration_test.rs

```rust
use adder::add_two;

mod common;

#[test]
fn it_adds_two() {
    common::setup();

    let result = add_two(2);
    assert_eq!(result, 4);
}
```

請注意，`mod common;` 宣告與我們在列表 7-21 中展示的模組宣告相同。然後，在測試函式中，我們可以呼叫 `common::setup()` 函式。

#### 二進位 Crate 的 Integration 測試

如果我們的專案是一個二進位 crate，只包含一個 _src/main.rs_ 檔案而沒有 _src/lib.rs_ 檔案，我們就無法在 _tests_ 目錄中建立 integration test，並用 `use` 陳述式將 _src/main.rs_ 檔案中定義的函式引入作用域。只有 library crate 會公開函式供其他 crate 使用；二進位 crate 是設計來獨立執行的。

這是 Rust 專案提供一個二進位檔時，會有一個簡單的 _src/main.rs_ 檔案來呼叫存在於 _src/lib.rs_ 檔案中邏輯的原因之一。使用那種結構，integration test *可以*用 `use` 來測試 library crate，以使重要功能可用。如果重要功能運作正常，那麼 _src/main.rs_ 檔案中的少量程式碼也會運作正常，而那少量程式碼並不需要被測試。

## 總結

Rust 的測試功能提供了一種方法來指定程式碼應該如何運作，以確保即使在你進行更改時，它仍然能如你預期地運作。Unit test 分別對 library 的不同部分進行測試，並且可以測試私有的實作細節。Integration test 檢查 library 的許多部分是否能正確協同運作，並且它們使用 library 的公開 API 來測試程式碼，方式與外部程式碼使用它的方式相同。儘管 Rust 的型別系統和 ownership 規則有助於防止某些類型的 bug，但測試對於減少與你的程式碼預期行為相關的邏輯 bug 仍然很重要。

讓我們結合你在本章和前面章節學到的知識來進行一個專案吧！
