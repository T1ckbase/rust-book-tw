<!-- DO NOT EDIT THIS FILE.

This file is periodically generated from the content in the `/src/`
directory, so all fixes need to be made in `/src/`.
-->

[TOC]

# 最終專案：建構多執行緒網頁伺服器

這是一段漫長的旅程，但我們已經走到了本書的盡頭。在本章中，我們將一起再建構一個專案，以展示我們在最後幾章中涵蓋的一些概念，並回顧一些早期的課程。

在我們的最終專案中，我們將製作一個網頁伺服器，它會在網頁瀏覽器中顯示「hello」，看起來像圖 21-1。

以下是我們建構網頁伺服器的計畫：

1. 學習一些關於 TCP 和 HTTP 的知識。
1. 在一個 socket 上監聽 TCP 連線。
1. 解析少量的 HTTP 請求。
1. 建立一個適當的 HTTP 回應。
1. 使用 thread pool 來提升我們伺服器的吞吐量。

![來自 Rust 的問候](https://doc.rust-lang.org/book/img/trpl21-01.png)

圖 21-1：我們最終的共享專案

在開始之前，我們應該提兩件事。首先，我們將使用的方法不會是用 Rust 建構網頁伺服器的最佳方式。社群成員已經在 crates.io（_https://crates.io/_）上發佈了許多生產就緒的 crate，它們提供了比我們將要建構的更完整的網頁伺服器和 thread pool 實作。然而，我們在本章的目的是幫助你學習，而不是走捷徑。因為 Rust 是一種系統程式語言，我們可以選擇我們想要的工作抽象層級，並且可以比其他語言中可能或實際可行的層級更低。

其次，我們在這裡不會使用 async 和 await。建構一個 thread pool 本身就是一個足夠大的挑戰，更不用說還要建構一個 async runtime 了！不過，我們會指出 async 和 await 可能如何應用於我們在本章中會遇到的一些相同問題。最終，正如我們在第 17 章中指出的，許多 async runtime 都使用 thread pool 來管理它們的工作。

因此，我們將手動編寫基本的 HTTP 伺服器和 thread pool，以便你能學習未來可能使用的 crate 背後的一般思想和技術。

## 建構單執行緒網頁伺服器

我們將從建構一個可運作的單執行緒網頁伺服器開始。在開始之前，讓我們先快速概覽一下建構網頁伺服器所涉及的協定。這些協定的細節超出了本書的範圍，但一個簡短的概述會給你所需的資訊。

網頁伺服器涉及的兩個主要協定是_超文本傳輸協定_（_Hypertext Transfer Protocol_，_HTTP_）和_傳輸控制協定_（_Transmission Control Protocol_，_TCP_）。這兩個協定都是_請求-回應_（_request-response_）協定，意味著一個_客戶端_（_client_）發起請求，而一個_伺服器_（_server_）監聽請求並向客戶端提供回應。這些請求和回應的內容由協定定義。

TCP 是較低層級的協定，它描述了資訊如何從一個伺服器傳輸到另一個伺服器的細節，但沒有指定這些資訊是什麼。HTTP 建立在 TCP 之上，定義了請求和回應的內容。技術上來說，HTTP 可以與其他協定一起使用，但在絕大多數情況下，HTTP 透過 TCP 傳送其資料。我們將處理 TCP 和 HTTP 請求與回應的原始位元組。

### 監聽 TCP 連線

我們的網頁伺服器需要監聽一個 TCP 連線，所以這是我們要做的第一部分。標準函式庫提供了一個 `std::net` 模組，讓我們可以做到這點。讓我們用通常的方式建立一個新專案：

```bash
$ cargo new hello
     Created binary (application) `hello` project
$ cd hello
```

現在將程式碼清單 21-1 的程式碼輸入到 _src/main.rs_ 中以開始。這段程式碼將在本地位址 `127.0.0.1:7878` 監聽傳入的 TCP stream。當它收到一個傳入的 stream 時，它會印出 `Connection established!`。

src/main.rs

```rust
use std::net::TcpListener;

fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        println!("Connection established!");
    }
}
```

程式碼清單 21-1：監聽傳入的 stream，並在收到 stream 時印出一則訊息

使用 `TcpListener`，我們可以在位址 `127.0.0.1:7878` 監聽 TCP 連線。在位址中，冒號前的部分是一個代表你電腦的 IP 位址（這在每台電腦上都一樣，並不特指作者的電腦），而 `7878` 是 port。我們選擇這個 port 有兩個原因：HTTP 通常不在此 port 上被接受，所以我們的伺服器不太可能與你機器上可能運行的任何其他網頁伺服器發生衝突，而且 7878 在電話鍵盤上輸入就是 _rust_。

在這種情況下，`bind` 函式的作用類似於 `new` 函式，它會回傳一個新的 `TcpListener` 實例。這個函式之所以被稱為 `bind`，是因為在網路中，連接到一個 port 以進行監聽被稱為「綁定到一個 port」。

`bind` 函式回傳一個 `Result<T, E>`，這表示綁定可能會失敗。例如，如果我們運行了兩個我們的程式實例，那麼就有兩個程式在監聽同一個 port。因為我們正在編寫一個僅用於學習目的的基本伺服器，我們不會擔心處理這類錯誤；相反，我們使用 `unwrap` 在發生錯誤時停止程式。

`TcpListener` 上的 `incoming` 方法回傳一個迭代器，給我們一系列的 stream（更具體地說，是 `TcpStream` 型別的 stream）。一個單一的 _stream_ 代表客戶端和伺服器之間的一個開放連線。一個_連線_（_connection_）是指完整的請求和回應過程的名稱，其中客戶端連接到伺服器，伺服器產生一個回應，然後伺服器關閉連線。因此，我們將從 `TcpStream` 中讀取以查看客戶端發送了什麼，然後將我們的回應寫入 stream 以將資料傳回給客戶端。總體來說，這個 `for` 迴圈將依次處理每個連線，並產生一系列供我們處理的 stream。

目前，我們對 stream 的處理包括呼叫 `unwrap`，如果 stream 有任何錯誤就終止我們的程式；如果沒有錯誤，程式會印出一則訊息。我們將在下一個程式碼清單中為成功的情況添加更多功能。當客戶端連接到伺服器時，我們可能會從 `incoming` 方法收到錯誤的原因是，我們實際上不是在迭代連線，而是在迭代_連線嘗試_。連線可能因為多種原因而不成功，其中許多是作業系統特定的。例如，許多作業系統對它們可以支援的同時開放連線數量有限制；超過該數量的新連線嘗試將產生錯誤，直到一些開放的連線被關閉。

讓我們來試試運行這段程式碼！在終端機中執行 `cargo run`，然後在網頁瀏覽器中載入 _127.0.0.1:7878_。瀏覽器應該會顯示一個錯誤訊息，如「連線已重設」，因為伺服器目前沒有回傳任何資料。但當你查看你的終端機時，你應該會看到幾條在瀏覽器連接到伺服器時印出的訊息！

```
     Running `target/debug/hello`
Connection established!
Connection established!
Connection established!
```

有時你會看到一個瀏覽器請求印出多則訊息；原因可能是瀏覽器正在請求頁面，同時也請求其他資源，例如出現在瀏覽器分頁中的 _favicon.ico_ 圖示。

也可能是瀏覽器試圖多次連接到伺服器，因為伺服器沒有回應任何資料。當 `stream` 在迴圈結束時離開作用域並被 drop 時，連線作為 `drop` 實作的一部分被關閉。瀏覽器有時會透過重試來處理已關閉的連線，因為問題可能是暫時的。

瀏覽器有時也會在不發送任何請求的情況下向伺服器開啟多個連線，這樣如果它們*之後*真的發送請求，那些請求可以更快地完成。當這種情況發生時，我們的伺服器會看到每個連線，無論該連線上是否有任何請求。例如，許多版本的 Chrome 瀏覽器都會這樣做；你可以透過使用私密瀏覽模式或使用不同的瀏覽器來停用該最佳化。

重要的是，我們已經成功地獲得了一個 TCP 連線的 handle！

當你運行完特定版本的程式碼後，記得按 <kbd>ctrl</kbd>-<kbd>C</kbd> 來停止程式。然後，在你每次進行程式碼變更後，透過執行 `cargo run` 指令重新啟動程式，以確保你正在運行最新的程式碼。

### 讀取請求

讓我們來實作讀取瀏覽器請求的功能！為了將首先獲取連線和接著對連線採取某些動作的關注點分開，我們將為處理連線啟動一個新的函式。在這個新的 `handle_connection` 函式中，我們將從 TCP stream 讀取資料並將其印出，以便我們可以看到從瀏覽器發送的資料。將程式碼更改為如程式碼清單 21-2 所示。

src/main.rs

```rust
use std::{
    io::{prelude::*, BufReader},
    net::{TcpListener, TcpStream},
};

fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        handle_connection(stream);
    }
}

fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&mut stream);
    let http_request: Vec<_> = buf_reader
        .lines()
        .map(|result| result.unwrap())
        .take_while(|line| !line.is_empty())
        .collect();

    println!("Request: {http_request:#?}");
}
```

程式碼清單 21-2：從 `TcpStream` 讀取並印出資料

我們將 `std::io::prelude` 和 `std::io::BufReader` 引入作用域，以取得讓我們能夠從 stream 中讀取和寫入的 trait 和型別。在 `main` 函式的 `for` 迴圈中，我們不再印出表示已建立連線的訊息，而是呼叫新的 `handle_connection` 函式並將 `stream` 傳遞給它。

在 `handle_connection` 函式中，我們建立了一個新的 `BufReader` 實例，它包裝了對 `stream` 的引用。`BufReader` 透過為我們管理對 `std::io::Read` trait 方法的呼叫來增加緩衝。

我們建立了一個名為 `http_request` 的變數，用來收集瀏覽器發送給我們伺服器的請求行。我們透過添加 `Vec<_>` 型別註釋來表示我們想要將這些行收集到一個 vector 中。

`BufReader` 實作了 `std::io::BufRead` trait，該 trait 提供了 `lines` 方法。`lines` 方法在每次看到換行位元組時，會將資料流分割，並回傳一個 `Result<String, std::io::Error>` 的迭代器。為了得到每個 `String`，我們對每個 `Result` 進行 map 和 `unwrap`。如果資料不是有效的 UTF-8，或者從 stream 讀取時出現問題，`Result` 可能會是個錯誤。同樣，一個生產環境的程式應該更優雅地處理這些錯誤，但為了簡單起見，我們選擇在錯誤情況下停止程式。

瀏覽器透過連續發送兩個換行符來表示 HTTP 請求的結束，所以為了從 stream 中獲取一個請求，我們會一直讀取行，直到我們得到一個空字串的行。一旦我們將這些行收集到 vector 中，我們就使用美化的偵錯格式將它們印出來，以便我們可以查看網頁瀏覽器發送給我們伺服器的指令。

讓我們來試試這段程式碼！啟動程式並在網頁瀏覽器中再次發出請求。請注意，我們在瀏覽器中仍然會得到一個錯誤頁面，但我們程式在終端機中的輸出現在會看起來像這樣：

```
$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 0.42s
     Running `target/debug/hello`
Request: [
    "GET / HTTP/1.1",
    "Host: 127.0.0.1:7878",
    "User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:99.0) Gecko/20100101 Firefox/99.0",
    "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8",
    "Accept-Language: en-US,en;q=0.5",
    "Accept-Encoding: gzip, deflate, br",
    "DNT: 1",
    "Connection: keep-alive",
    "Upgrade-Insecure-Requests: 1",
    "Sec-Fetch-Dest: document",
    "Sec-Fetch-Mode: navigate",
    "Sec-Fetch-Site: none",
    "Sec-Fetch-User: ?1",
    "Cache-Control: max-age=0",
]
```

根據你的瀏覽器，你可能會得到略有不同的輸出。現在我們正在印出請求資料，我們可以透過查看請求第一行 `GET` 後面的路徑，來了解為什麼一個瀏覽器請求會產生多個連線。如果重複的連線都是請求 `*/*`，我們就知道瀏覽器正在重複地請求 `*/*`，因為它沒有從我們的程式得到回應。

讓我們來分解這些請求資料，以了解瀏覽器在向我們的程式要求什麼。

### 深入了解 HTTP 請求

HTTP 是一種基於文字的協定，請求的格式如下：

```
Method Request-URI HTTP-Version CRLF
headers CRLF
message-body
```

第一行是_請求行_（_request line_），它包含了客戶端請求的資訊。請求行的第一部分指示了所使用的_方法_（_method_），例如 `GET` 或 `POST`，這描述了客戶端如何發出此請求。我們的客戶端使用了 `GET` 請求，這意味著它在請求資訊。

請求行的下一部分是 `*/*`，它指示了客戶端正在請求的_統一資源識別符_（_uniform resource identifier_，_URI_）：URI 與_統一資源定位符_（_uniform resource locator_，_URL_）幾乎相同，但又不完全一樣。在本章中，URI 和 URL 之間的差異對我們來說並不重要，但 HTTP 規範使用了*URI*這個詞，所以我們可以在這裡 mentally 將*URI*替換為_URL_。

最後一部分是客戶端使用的 HTTP 版本，然後請求行以 CRLF 序列結束。（CRLF 代表_歸位_（_carriage return_）和_換行_（_line feed_），這些是來自打字機時代的術語！）CRLF 序列也可以寫成 `\r\n`，其中 `\r` 是歸位，`\n` 是換行。*CRLF 序列*將請求行與請求資料的其餘部分分開。請注意，當 CRLF 被印出時，我們看到的是一個新行的開始，而不是 `\r\n`。

從我們目前運行程式收到的請求行資料來看，我們看到 `GET` 是方法，`*/*` 是請求 URI，`HTTP/1.1` 是版本。

請求行之後，從 `Host:` 開始的其餘行都是標頭（headers）。`GET` 請求沒有主體（body）。

試著從不同的瀏覽器發出請求，或請求不同的位址，例如 _127.0.0.1:7878/test_，來看看請求資料如何變化。

現在我們知道了瀏覽器在要求什麼，讓我們回傳一些資料吧！

### 寫入回應

我們將實作回應客戶端請求並發送資料的功能。回應的格式如下：

```
HTTP-Version Status-Code Reason-Phrase CRLF
headers CRLF
message-body
```

第一行是_狀態行_（_status line_），包含回應中使用的 HTTP 版本、一個總結請求結果的數字狀態碼，以及一個提供狀態碼文字描述的原因短語。在 CRLF 序列之後是任何標頭、另一個 CRLF 序列，以及回應的主體。

這是一個使用 HTTP 1.1 版本、狀態碼為 200、原因短語為 OK、沒有標頭且沒有主體的回應範例：

```
HTTP/1.1 200 OK\r\n\r\n
```

狀態碼 200 是標準的成功回應。這段文字是一個微小的成功 HTTP 回應。讓我們將它寫入 stream 作為對成功請求的回應！從 `handle_connection` 函式中，移除之前印出請求資料的 `println!`，並用程式碼清單 21-3 中的程式碼替換它。

src/main.rs

```rust
fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&mut stream);
    let http_request: Vec<_> = buf_reader
        .lines()
        .map(|result| result.unwrap())
        .take_while(|line| !line.is_empty())
        .collect();

    let response = "HTTP/1.1 200 OK\r\n\r\n";

    stream.write_all(response.as_bytes()).unwrap();
}
```

程式碼清單 21-3：向 stream 寫入一個微小的成功 HTTP 回應

第一行新程式碼定義了 `response` 變數，它持有成功訊息的資料。然後我們在 `response` 上呼叫 `as_bytes` 將字串資料轉換為位元組。`stream` 上的 `write_all` 方法接受一個 `&[u8]` 並將這些位元組直接沿著連線發送出去。因為 `write_all` 操作可能會失敗，所以我們像之前一樣對任何錯誤結果使用 `unwrap`。同樣，在一個真實的應用程式中，你應該在這裡添加錯誤處理。

有了這些變更，讓我們運行我們的程式碼並發出請求。我們不再向終端機印出任何資料，所以除了 Cargo 的輸出外，我們不會看到任何輸出。當你在網頁瀏覽器中載入 _127.0.0.1:7878_ 時，你應該會得到一個空白頁面而不是錯誤。你剛剛手動編寫了接收 HTTP 請求和發送回應的程式碼！

### 回傳真實的 HTML

讓我們實作回傳比空白頁面更多內容的功能。在你的專案根目錄下建立一個新檔案 _hello.html_，而不是在 _src_ 目錄中。你可以輸入任何你想要的 HTML；程式碼清單 21-4 顯示了一種可能性。

hello.html

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Hello!</title>
  </head>
  <body>
    <h1>Hello!</h1>
    <p>Hi from Rust</p>
  </body>
</html>
```

程式碼清單 21-4：一個在回應中回傳的範例 HTML 檔案

這是一個最小的 HTML5 文件，帶有一個標題和一些文字。為了在收到請求時從伺服器回傳這個文件，我們將修改 `handle_connection` 如程式碼清單 21-5 所示，以讀取 HTML 檔案，將其作為主體添加到回應中，並發送它。

src/main.rs

```rust
use std::{
    fs,
    io::{prelude::*, BufReader},
    net::{TcpListener, TcpStream},
};
// --snip--

fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&mut stream);
    let http_request: Vec<_> = buf_reader
        .lines()
        .map(|result| result.unwrap())
        .take_while(|line| !line.is_empty())
        .collect();

    let status_line = "HTTP/1.1 200 OK";
    let contents = fs::read_to_string("hello.html").unwrap();
    let length = contents.len();

    let response =
        format!("{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}");

    stream.write_all(response.as_bytes()).unwrap();
}
```

程式碼清單 21-5：將 _hello.html_ 的內容作為回應主體發送

我們在 `use` 語句中加入了 `fs`，以將標準函式庫的檔案系統模組引入作用域。將檔案內容讀取到字串的程式碼應該看起來很熟悉；我們在程式碼清單 12-4 的 I/O 專案中讀取檔案內容時用過它。

接下來，我們使用 `format!` 將檔案內容作為成功回應的主體添加進去。為確保一個有效的 HTTP 回應，我們添加了 `Content-Length` 標頭，它被設定為我們回應主體的大小，在這種情況下就是 `hello.html` 的大小。

用 `cargo run` 運行這段程式碼，並在你的瀏覽器中載入 _127.0.0.1:7878_；你應該會看到你的 HTML 被渲染出來！

目前，我們忽略了 `http_request` 中的請求資料，只是無條件地回傳 HTML 檔案的內容。這意味著如果你試著在瀏覽器中請求 _127.0.0.1:7878/something-else_，你仍然會得到同樣的 HTML 回應。目前，我們的伺服器非常有限，並沒有做大多數網頁伺服器所做的事情。我們希望根據請求來客製化我們的回應，並且只為格式正確的 `*/*` 請求回傳 HTML 檔案。

### 驗證請求並選擇性地回應

目前，無論客戶端請求什麼，我們的網頁伺服器都會回傳檔案中的 HTML。讓我們新增功能，在回傳 HTML 檔案前檢查瀏覽器是否請求 `*/*`，如果瀏覽器請求其他任何東西，就回傳一個錯誤。為此，我們需要修改 `handle_connection`，如程式碼清單 21-6 所示。這段新程式碼會檢查收到的請求內容是否與我們所知的 `*/*` 請求相符，並添加 `if` 和 `else` 區塊來不同地處理請求。

src/main.rs

```rust
// --snip--

fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&mut stream);
    let request_line = buf_reader.lines().next().unwrap().unwrap();

    if request_line == "GET / HTTP/1.1" {
        let status_line = "HTTP/1.1 200 OK";
        let contents = fs::read_to_string("hello.html").unwrap();
        let length = contents.len();

        let response = format!(
            "{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}"
        );

        stream.write_all(response.as_bytes()).unwrap();
    } else {
        // some other request
    }
}
```

程式碼清單 21-6：將 `*/*` 的請求與其他請求分開處理

我們只會查看 HTTP 請求的第一行，所以我們不將整個請求讀入一個 vector，而是呼叫 `next` 來從迭代器中取得第一個項目。第一個 `unwrap` 處理 `Option`，如果迭代器沒有項目，則停止程式。第二個 `unwrap` 處理 `Result`，其效果與程式碼清單 21-2 中 `map` 裡的 `unwrap` 相同。

接下來，我們檢查 `request_line` 是否等於一個對 `*/*` 路徑的 GET 請求行。如果是，`if` 區塊會回傳我們的 HTML 檔案內容。

如果 `request_line` _不_ 等於對 `*/*` 路徑的 GET 請求，這意味著我們收到了某個其他的請求。我們稍後會在 `else` 區塊中新增程式碼來回應所有其他請求。

現在運行這段程式碼並請求 _127.0.0.1:7878_；你應該會得到 _hello.html_ 中的 HTML。如果你發出任何其他請求，例如 _127.0.0.1:7878/something-else_，你會得到一個連線錯誤，就像你在運行程式碼清單 21-1 和 21-2 時看到的那樣。

現在讓我們在 `else` 區塊中加入程式碼清單 21-7 的程式碼，以回傳一個狀態碼為 404 的回應，這表示找不到請求的內容。我們也會回傳一些 HTML，以便在瀏覽器中渲染一個頁面，向終端使用者顯示回應。

src/main.rs

```rust
    // --snip--
    } else {
        let status_line = "HTTP/1.1 404 NOT FOUND";
        let contents = fs::read_to_string("404.html").unwrap();
        let length = contents.len();

        let response = format!(
            "{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}"
        );

        stream.write_all(response.as_bytes()).unwrap();
    }
```

程式碼清單 21-7：如果請求的不是 `*/*`，則回應狀態碼 404 和一個錯誤頁面

在這裡，我們的回應有一個狀態碼為 404 和原因短語 `NOT FOUND` 的狀態行。回應的主體將是檔案 _404.html_ 中的 HTML。你需要在 _hello.html_ 旁邊建立一個 _404.html_ 檔案作為錯誤頁面；同樣地，你可以使用任何你想要的 HTML，或者使用程式碼清單 21-8 中的範例 HTML。

404.html

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Hello!</title>
  </head>
  <body>
    <h1>Oops!</h1>
    <p>Sorry, I don't know what you're asking for.</p>
  </body>
</html>
```

程式碼清單 21-8：隨任何 404 回應一起發送的頁面範例內容

有了這些變更，再次運行你的伺服器。請求 _127.0.0.1:7878_ 應該會回傳 _hello.html_ 的內容，而任何其他請求，例如 _127.0.0.1:7878/foo_，應該會回傳 _404.html_ 中的錯誤 HTML。

### 一點重構

目前，`if` 和 `else` 區塊有很多重複之處：它們都在讀取檔案並將檔案內容寫入 stream。唯一的區別是狀態行和檔名。讓我們透過將這些差異提取到單獨的 `if` 和 `else` 行中來使程式碼更簡潔，這些行將狀態行和檔名的值賦給變數；然後我們可以無條件地在程式碼中使用這些變數來讀取檔案和寫入回應。程式碼清單 21-9 顯示了替換大型 `if` 和 `else` 區塊後的結果程式碼。

src/main.rs

```rust
// --snip--

fn handle_connection(mut stream: TcpStream) {
    // --snip--

    let (status_line, filename) = if request_line == "GET / HTTP/1.1" {
        ("HTTP/1.1 200 OK", "hello.html")
    } else {
        ("HTTP/1.1 404 NOT FOUND", "404.html")
    };

    let contents = fs::read_to_string(filename).unwrap();
    let length = contents.len();

    let response =
        format!("{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}");

    stream.write_all(response.as_bytes()).unwrap();
}
```

程式碼清單 21-9：重構 `if` 和 `else` 區塊，使其僅包含兩種情況之間不同的程式碼

現在 `if` 和 `else` 區塊只回傳一個 tuple，其中包含狀態行和檔名的適當值；然後我們使用解構，透過 `let` 語句中的模式將這兩個值賦給 `status_line` 和 `filename`，如第 19 章所討論的。

先前重複的程式碼現在位於 `if` 和 `else` 區塊之外，並使用 `status_line` 和 `filename` 變數。這使得更容易看出兩種情況之間的差異，也意味著如果我們想改變檔案讀取和回應寫入的工作方式，我們只需要更新一個地方的程式碼。程式碼清單 21-9 的行為將與程式碼清單 21-7 中的行為相同。

太棒了！我們現在有一個大約 40 行 Rust 程式碼的簡單網頁伺服器，它能對一個請求以一個內容頁面回應，並對所有其他請求以 404 回應。

目前，我們的伺服器在單一執行緒中運行，意味著它一次只能服務一個請求。讓我們透過模擬一些慢速請求來檢視這可能如何成為一個問題。然後我們將修復它，使我們的伺服器可以同時處理多個請求。

## 將我們的單執行緒伺服器轉換為多執行緒伺服器

目前，伺服器會依序處理每個請求，這意味著在第一個連線處理完成之前，它不會處理第二個連線。如果伺服器收到越來越多的請求，這種序列執行將越來越不理想。如果伺服器收到一個需要很長時間處理的請求，後續的請求將不得不等到那個長請求完成，即使新的請求可以很快地被處理。我們需要修復這個問題，但首先我們將實際看看這個問題。

<!-- Old headings. Do not remove or links may break. -->

<a id="simulating-a-slow-request-in-the-current-server-implementation"></a>

### 模擬慢速請求

我們將看看一個處理緩慢的請求如何影響對我們目前伺服器實作所做的其他請求。程式碼清單 21-10 實作了處理對 `*/sleep*` 的請求，並模擬了一個慢速回應，這將導致伺服器在回應前休眠五秒鐘。

src/main.rs

```rust
use std::{
    fs,
    io::{prelude::*, BufReader},
    net::{TcpListener, TcpStream},
    thread,
    time::Duration,
};
// --snip--

fn handle_connection(mut stream: TcpStream) {
    // --snip--

    let (status_line, filename) = match &request_line[..] {
        "GET / HTTP/1.1" => ("HTTP/1.1 200 OK", "hello.html"),
        "GET /sleep HTTP/1.1" => {
            thread::sleep(Duration::from_secs(5));
            ("HTTP/1.1 200 OK", "hello.html")
        }
        _ => ("HTTP/1.1 404 NOT FOUND", "404.html"),
    };

    // --snip--
}
```

程式碼清單 21-10：透過休眠五秒鐘來模擬慢速請求

我們現在有三種情況，所以從 `if` 切換到 `match`。我們需要明確地對 `request_line` 的 slice 進行 match，以便與字串常值進行模式匹配；`match` 不會像等號方法那樣進行自動的引用和解引用。

第一個分支與程式碼清單 21-9 中的 `if` 區塊相同。第二個分支匹配對 `*/sleep*` 的請求。當收到該請求時，伺服器將休眠五秒鐘，然後再渲染成功的 HTML 頁面。第三個分支與程式碼清單 21-9 中的 `else` 區塊相同。

你可以看到我們的伺服器有多麼原始：真正的函式庫會以一種遠不那麼冗長的方式來處理多個請求的辨識！

使用 `cargo run` 啟動伺服器。然後打開兩個瀏覽器視窗：一個用於 _http://127.0.0.1:7878_，另一個用於 _http://127.0.0.1:7878/sleep_。如果你像以前一樣多次輸入 `*/*` URI，你會看到它很快地回應。但如果你輸入 `*/sleep*` 然後再載入 `*/*`，你會看到 `*/*` 等待 `sleep` 完成其整整五秒鐘的休眠後才會載入。

我們可以使用多種技術來避免請求在一個慢速請求後面排隊，包括像我們在第 17 章中那樣使用 async；我們將要實作的是一個 thread pool。

### 使用 thread pool 提升吞吐量

_thread pool_ 是一組已 spawn 並準備好處理任務的執行緒。當程式收到一個新任務時，它會將池中的一個執行緒分配給該任務，而該執行緒將處理該任務。池中剩餘的執行緒可用於處理第一個執行緒在處理時進來的任何其他任務。當第一個執行緒完成其任務處理後，它會返回到空閒執行緒池中，準備處理新任務。thread pool 允許你並行處理連線，從而提高伺服器的吞吐量。

我們將池中的執行緒數量限制在一個小數目，以保護我們免受 DoS 攻擊；如果我們的程式為每個進來的請求建立一個新執行緒，那麼向我們的伺服器發出 1000 萬個請求的人可能會透過耗盡我們伺服器的所有資源並使請求處理停滯不前來製造混亂。

因此，我們不會 spawn 無限數量的執行緒，而是在池中有一組固定數量的執行緒在等待。進來的請求被發送到池中進行處理。池將維護一個傳入請求的佇列。池中的每個執行緒都會從這個佇列中取出一個請求，處理該請求，然後向佇列請求另一個請求。透過這種設計，我們可以同時處理多達 _`N`_ 個請求，其中 _`N`_ 是執行緒的數量。如果每個執行緒都在回應一個長時間運行的請求，後續的請求仍然可能在佇列中備份，但我們已經增加了在達到該點之前可以處理的長時間運行請求的數量。

這項技術只是提高網頁伺服器吞吐量的眾多方法之一。你可能想要探索的其他選項包括 fork/join 模型、單執行緒 async I/O 模型，以及多執行緒 async I/O 模型。如果你對這個主題感興趣，你可以閱讀更多關於其他解決方案的資料並嘗試實作它們；對於像 Rust 這樣低階的語言，所有這些選項都是可能的。

在我們開始實作 thread pool 之前，讓我們談談使用這個池應該是什麼樣子。當你試圖設計程式碼時，首先編寫客戶端介面可以幫助指導你的設計。將程式碼的 API 結構化為你想要呼叫它的方式；然後在該結構內實作功能，而不是先實作功能再設計公共 API。

類似於我們在第 12 章的專案中使用測試驅動開發的方式，我們在這裡將使用編譯器驅動開發。我們將編寫呼叫我們想要的函式的程式碼，然後我們將查看編譯器的錯誤來決定接下來應該改變什麼才能讓程式碼工作。然而，在我們這樣做之前，我們將探索我們不打算使用的技術作為一個起點。

<!-- Old headings. Do not remove or links may break. -->

<a id="code-structure-if-we-could-spawn-a-thread-for-each-request"></a>

<h4>為每個請求 spawn 一個執行緒</h4>

首先，讓我們探討一下如果我們的程式碼為每個連線建立一個新執行緒，它會是什麼樣子。如前所述，這不是我們的最終計畫，因為可能 spawn 無限數量的執行緒會帶來問題，但這是一個首先讓多執行緒伺服器運作起來的起點。然後我們將加入 thread pool 作為改進，這樣對比兩種解決方案會更容易。

程式碼清單 21-11 顯示了對 `main` 的更改，以便在 `for` 迴圈內為每個 stream spawn 一個新執行緒。

src/main.rs

```rust
fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        thread::spawn(|| {
            handle_connection(stream);
        });
    }
}
```

程式碼清單 21-11：為每個 stream spawn 一個新執行緒

正如你在第 16 章中學到的，`thread::spawn` 會建立一個新執行緒，然後在新執行緒中運行閉包中的程式碼。如果你運行這段程式碼並在瀏覽器中載入 `*/sleep*`，然後在另外兩個瀏覽器分頁中載入 `*/*`，你確實會看到對 `*/*` 的請求不必等待 `*/sleep*` 完成。然而，正如我們提到的，這最終會使系統不堪重負，因為你會無限制地建立新執行緒。

你可能還記得第 17 章中提到的，這正是 async 和 await 大放異彩的情況！在我們建構 thread pool 時請記住這一點，並思考使用 async 會讓事情有何不同或相同。

<!-- Old headings. Do not remove or links may break. -->

<a id="creating-a-similar-interface-for-a-finite-number-of-threads"></a>

<h4>建立有限數量的執行緒</h4>

我們希望我們的 thread pool 以類似、熟悉的方式工作，這樣從執行緒切換到 thread pool 就不需要對使用我們 API 的程式碼進行大的更改。程式碼清單 21-12 顯示了我們想要用來代替 `thread::spawn` 的 `ThreadPool` struct 的假設性介面。

src/main.rs

```rust
fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }
}
```

程式碼清單 21-12：我們理想的 `ThreadPool` 介面

我們使用 `ThreadPool::new` 來建立一個新的 thread pool，其執行緒數量是可配置的，本例中為四個。然後，在 `for` 迴圈中，`pool.execute` 的介面與 `thread::spawn` 類似，它接受一個閉包，該池應該為每個 stream 運行這個閉包。我們需要實作 `pool.execute`，使其接受閉包並將其交給池中的一個執行緒來運行。這段程式碼還不能編譯，但我們會嘗試一下，以便編譯器可以指導我們如何修復它。

<!-- Old headings. Do not remove or links may break. -->

<a id="building-the-threadpool-struct-using-compiler-driven-development"></a>

<h4>使用編譯器驅動開發來建構 ThreadPool</h4>

將程式碼清單 21-12 中的更改應用到 _src/main.rs_，然後讓我們使用 `cargo check` 的編譯器錯誤來驅動我們的開發。這是我們得到的第一個錯誤：

```
$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0433]: failed to resolve: use of undeclared type `ThreadPool`
  --> src/main.rs:11:16
   |
11 |     let pool = ThreadPool::new(4);
   |                ^^^^^^^^^^ use of undeclared type `ThreadPool`

For more information about this error, try `rustc --explain E0433`.
error: could not compile `hello` (bin "hello") due to 1 previous error
```

太好了！這個錯誤告訴我們需要一個 `ThreadPool` 型別或模組，所以我們現在就來建構一個。我們的 `ThreadPool` 實作將獨立於我們的網頁伺服器正在做的工作種類。所以讓我們將 `hello` crate 從一個二進位 crate 轉換為一個函式庫 crate，以容納我們的 `ThreadPool` 實作。在我們更改為函式庫 crate 之後，我們也可以將這個獨立的 thread pool 函式庫用於任何我們想用 thread pool 做的任何工作，而不僅僅是服務網頁請求。

建立一個 _src/lib.rs_ 檔案，其中包含以下內容，這是我們目前能有的最簡單的 `ThreadPool` struct 定義：

src/lib.rs

```rust
pub struct ThreadPool;
```

然後編輯 _main.rs_ 檔案，透過在 _src/main.rs_ 頂部加入以下程式碼，將 `ThreadPool` 從函式庫 crate 引入作用域：

src/main.rs

```rust
use hello::ThreadPool;
```

這段程式碼仍然無法運作，但讓我們再次檢查它，以得到我們需要處理的下一個錯誤：

```
$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0599]: no function or associated item named `new` found for struct `ThreadPool` in the current scope
  --> src/main.rs:12:28
   |
12 |     let pool = ThreadPool::new(4);
   |                            ^^^ function or associated item not found in `ThreadPool`

For more information about this error, try `rustc --explain E0599`.
error: could not compile `hello` (bin "hello") due to 1 previous error
```

這個錯誤表示接下來我們需要為 `ThreadPool` 建立一個名為 `new` 的關聯函式。我們也知道 `new` 需要有一個可以接受 `4` 作為引數的參數，並且應該回傳一個 `ThreadPool` 實例。讓我們實作一個具有這些特性的最簡單的 `new` 函式：

src/lib.rs

```rust
pub struct ThreadPool;

impl ThreadPool {
    pub fn new(size: usize) -> ThreadPool {
        ThreadPool
    }
}
```

我們選擇 `usize` 作為 `size` 參數的型別，因為我們知道負數的執行緒沒有任何意義。我們也知道我們將使用這個 `4` 作為執行緒集合中元素的數量，這正是 `usize` 型別的用途，如第 3 章「整數型別」中所討論的。

讓我們再次檢查程式碼：

```
$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0599]: no method named `execute` found for struct `ThreadPool` in the current scope
  --> src/main.rs:17:14
   |
17 |         pool.execute(|| {
   |         -----^^^^^^^ method not found in `ThreadPool`

For more information about this error, try `rustc --explain E0599`.
error: could not compile `hello` (bin "hello") due to 1 previous error
```

現在的錯誤是因為我們在 `ThreadPool` 上沒有一個 `execute` 方法。回想一下「建立有限數量的執行緒」，我們決定我們的 thread pool 應該有一個與 `thread::spawn` 類似的介面。此外，我們將實作 `execute` 函式，使其接受給定的閉包，並將其交給池中一個空閒的執行緒來運行。

我們將在 `ThreadPool` 上定義 `execute` 方法，使其接受一個閉包作為參數。回想一下第 13 章的「將捕獲的值移出閉包與 `Fn` trait」，我們可以使用三個不同的 trait 來接受閉包作為參數：`Fn`、`FnMut` 和 `FnOnce`。我們需要決定在這裡使用哪種閉包。我們知道我們最終會做一些類似於標準函式庫 `thread::spawn` 實作的事情，所以我們可以看看 `thread::spawn` 的簽名對其參數有什麼樣的界限。文件顯示如下：

```rust
pub fn spawn<F, T>(f: F) -> JoinHandle<T>
    where
        F: FnOnce() -> T,
        F: Send + 'static,
        T: Send + 'static,
```

`F` 型別參數是我們在這裡關心的；`T` 型別參數與回傳值相關，我們不關心那個。我們可以看到 `spawn` 使用 `FnOnce` 作為 `F` 的 trait bound。這可能也是我們想要的，因為我們最終會將在 `execute` 中得到的引數傳遞給 `spawn`。我們可以更確定 `FnOnce` 是我們想要使用的 trait，因為運行一個請求的執行緒只會執行該請求的閉包一次，這與 `FnOnce` 中的 `Once` 相符。

`F` 型別參數還有 `Send` trait bound 和 `'static` lifetime bound，這在我們的情況下很有用：我們需要 `Send` 來將閉包從一個執行緒轉移到另一個執行緒，而 `'static` 則是因為我們不知道執行緒需要多久才能執行完畢。讓我們在 `ThreadPool` 上建立一個 `execute` 方法，它將接受一個帶有這些界限的泛型參數 `F`：

src/lib.rs

```rust
impl ThreadPool {
    // --snip--
    pub fn execute<F>(&self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
    }
}
```

我們仍然在 `FnOnce` 後面使用 `()`，因為這個 `FnOnce` 代表一個不接受任何參數並回傳單元型別 `()` 的閉包。就像函式定義一樣，回傳型別可以從簽名中省略，但即使我們沒有參數，我們仍然需要括號。

同樣，這是 `execute` 方法最簡單的實作：它什麼也不做，但我們只是試圖讓我們的程式碼能夠編譯。讓我們再檢查一次：

```
$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.24s
```

它編譯了！但請注意，如果你嘗試 `cargo run` 並在瀏覽器中發出請求，你會看到我們在本章開頭看到的那些瀏覽器錯誤。我們的函式庫實際上還沒有呼叫傳遞給 `execute` 的閉包！

> 注意：關於像 Haskell 和 Rust 這樣有嚴格編譯器的語言，你可能會聽到一種說法：「如果程式碼能編譯，它就能運作。」但這種說法並非普遍適用。我們的專案能編譯，但它完全什麼也沒做！如果我們正在建構一個真實、完整的專案，這將是開始編寫單元測試以檢查程式碼是否能編譯*並且*具有我們想要的行為的好時機。

思考一下：如果我們要執行的是一個 future 而不是一個閉包，這裡會有什麼不同？

<h4>在 new 函式中驗證執行緒數量</h4>

我們還沒有對 `new` 和 `execute` 的參數做任何事。讓我們用我們想要的行為來實作這些函式的主體。首先，讓我們思考 `new`。早些時候，我們為 `size` 參數選擇了一個無號型別，因為一個有負數執行緒的池沒有任何意義。然而，一個有零個執行緒的池也沒有任何意義，但零是一個完全有效的 `usize`。我們將加入程式碼來檢查 `size` 是否大於零，然後才回傳一個 `ThreadPool` 實例，如果收到零，就使用 `assert!` 巨集讓程式 panic，如程式碼清單 21-13 所示。

src/lib.rs

```rust
impl ThreadPool {
    /// 建立一個新的 ThreadPool。
    ///
    /// `size` 是池中的執行緒數量。
    ///
    /// # Panics
    ///
    /// 如果 `size` 為零，`new` 函式將會 panic。
    pub fn new(size: usize) -> ThreadPool {
        assert!(size > 0);

        ThreadPool
    }

    // --snip--
}
```

程式碼清單 21-13：實作 `ThreadPool::new`，使其在 `size` 為零時 panic

我們也為我們的 `ThreadPool` 添加了一些文件，使用了文件註解。請注意，我們遵循了良好的文件實踐，添加了一個區塊來指出我們的函式可能 panic 的情況，如第 14 章所討論的。試著運行 `cargo doc --open` 並點擊 `ThreadPool` struct，看看 `new` 生成的文件是什麼樣子！

與我們在這裡做的添加 `assert!` 巨集不同，我們可以將 `new` 改為 `build` 並回傳一個 `Result`，就像我們在第 12 章的 I/O 專案中對 `Config::build` 所做的那樣（程式碼清單 12-9）。但在這種情況下，我們決定嘗試建立一個沒有任何執行緒的 thread pool 應該是一個不可恢復的錯誤。如果你有雄心壯志，試著寫一個名為 `build` 的函式，其簽名如下，以便與 `new` 函式進行比較：

```rust
pub fn build(size: usize) -> Result<ThreadPool, PoolCreationError> {
```

<h4>建立儲存執行緒的空間</h4>

既然我們有辦法知道池中有一個有效的執行緒數量可以儲存，我們就可以建立這些執行緒並將它們儲存在 `ThreadPool` struct 中，然後再回傳這個 struct。但是我們如何「儲存」一個執行緒呢？讓我們再看一下 `thread::spawn` 的簽名：

```rust
pub fn spawn<F, T>(f: F) -> JoinHandle<T>
    where
        F: FnOnce() -> T,
        F: Send + 'static,
        T: Send + 'static,
```

`spawn` 函式回傳一個 `JoinHandle<T>`，其中 `T` 是閉包回傳的型別。讓我們也試著使用 `JoinHandle`，看看會發生什麼。在我們的例子中，我們傳遞給 thread pool 的閉包將處理連線並且不回傳任何東西，所以 `T` 將是單元型別 `()`。

程式碼清單 21-14 中的程式碼可以編譯，但還沒有建立任何執行緒。我們已經更改了 `ThreadPool` 的定義，使其持有一個 `thread::JoinHandle<()>` 實例的 vector，用 `size` 的容量初始化了 vector，設定了一個 `for` 迴圈來運行一些程式碼以建立執行緒，並回傳一個包含它們的 `ThreadPool` 實例。

src/lib.rs

```rust
use std::thread;

pub struct ThreadPool {
    threads: Vec<thread::JoinHandle<()>>,
}

impl ThreadPool {
    // --snip--
    pub fn new(size: usize) -> ThreadPool {
        assert!(size > 0);

        let mut threads = Vec::with_capacity(size);

        for _ in 0..size {
            // create some threads and store them in the vector
        }

        ThreadPool { threads }
    }
    // --snip--
}
```

程式碼清單 21-14：為 `ThreadPool` 建立一個 vector 來存放執行緒

我們已經將 `std::thread` 引入函式庫 crate 的作用域，因為我們在 `ThreadPool` 中使用 `thread::JoinHandle` 作為 vector 中項目的型別。

一旦收到一個有效的大小，我們的 `ThreadPool` 就會建立一個可以容納 `size` 個項目的新 vector。`with_capacity` 函式執行的任務與 `Vec::new` 相同，但有一個重要的區別：它會預先在 vector 中分配空間。因為我們知道我們需要在 vector 中儲存 `size` 個元素，所以預先進行這個分配比使用 `Vec::new`（它會在插入元素時自行調整大小）稍微高效一些。

當你再次運行 `cargo check` 時，它應該會成功。

<!-- Old headings. Do not remove or links may break. -->

<a id ="a-worker-struct-responsible-for-sending-code-from-the-threadpool-to-a-thread"></a>

<h4>使用 Worker struct 負責將程式碼從 ThreadPool 傳送到執行緒</h4>

我們在程式碼清單 21-14 的 `for` 迴圈中留下了一條關於建立執行緒的註解。在這裡，我們將看看我們實際上如何建立執行緒。標準函式庫提供了 `thread::spawn` 作為建立執行緒的方式，而 `thread::spawn` 期望得到一些程式碼，讓執行緒在建立後立即運行。然而，在我們的例子中，我們想要建立執行緒並讓它們*等待*我們稍後會發送的程式碼。標準函式庫的執行緒實作不包含任何這樣做的方式；我們必須手動實作它。

我們將透過在 `ThreadPool` 和執行緒之間引入一個新的資料結構來管理這種新行為，從而實作這種行為。我們將稱這個資料結構為 _Worker_，這在 pooling 實作中是一個常見的術語。`Worker` 接收需要運行的程式碼，並在其執行緒中運行該程式碼。

想像一下在餐廳廚房工作的人們：工人們等到顧客的訂單進來，然後他們負責接收這些訂單並完成它們。

我們不會在 thread pool 中儲存一個 `JoinHandle<()>` 實例的 vector，而是儲存 `Worker` struct 的實例。每個 `Worker` 將儲存一個單一的 `JoinHandle<()>` 實例。然後我們將在 `Worker` 上實作一個方法，該方法將接受一個要運行的程式碼閉包，並將其發送到已經運行的執行緒以供執行。我們還會給每個 `Worker` 一個 `id`，以便我們在日誌記錄或偵錯時可以區分池中不同的 `Worker` 實例。

這是我們建立 `ThreadPool` 時將發生的新流程。我們將在這樣設定好 `Worker` 之後，實作發送閉包到執行緒的程式碼：

1. 定義一個 `Worker` struct，它持有一個 `id` 和一個 `JoinHandle<()>`。
2. 更改 `ThreadPool` 以持有一個 `Worker` 實例的 vector。
3. 定義一個 `Worker::new` 函式，它接受一個 `id` 數字並回傳一個 `Worker` 實例，該實例持有 `id` 和一個用空閉包 spawn 的執行緒。
4. 在 `ThreadPool::new` 中，使用 `for` 迴圈計數器來產生一個 `id`，用該 `id` 建立一個新的 `Worker`，並將該 `Worker` 儲存在 vector 中。

如果你想挑戰一下，試著在查看程式碼清單 21-15 的程式碼之前，自己實作這些更改。

準備好了嗎？這裡是程式碼清單 21-15，其中一種進行上述修改的方法。

src/lib.rs

```rust
use std::thread;

pub struct ThreadPool {
    workers: Vec<Worker>,
}

impl ThreadPool {
    // --snip--
    pub fn new(size: usize) -> ThreadPool {
        assert!(size > 0);

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id));
        }

        ThreadPool { workers }
    }
    // --snip--
}

struct Worker {
    id: usize,
    thread: thread::JoinHandle<()>,
}

impl Worker {
    fn new(id: usize) -> Worker {
        let thread = thread::spawn(|| {});

        Worker { id, thread }
    }
}
```

程式碼清單 21-15：修改 `ThreadPool` 以持有 `Worker` 實例，而不是直接持有執行緒

我們將 `ThreadPool` 上的欄位名稱從 `threads` 改為 `workers`，因為它現在持有 `Worker` 實例而不是 `JoinHandle<()>` 實例。我們使用 `for` 迴圈中的計數器作為 `Worker::new` 的引數，並將每個新的 `Worker` 儲存在名為 `workers` 的 vector 中。

外部程式碼（例如我們在 _src/main.rs_ 中的伺服器）不需要知道在 `ThreadPool` 中使用 `Worker` struct 的實作細節，所以我們將 `Worker` struct 及其 `new` 函式設為私有。`Worker::new` 函式使用我們給它的 `id` 並儲存一個 `JoinHandle<()>` 實例，該實例是透過使用一個空閉包 spawn 一個新執行緒而建立的。

> 注意：如果作業系統因為系統資源不足而無法建立執行緒，`thread::spawn` 將會 panic。這將導致我們的整個伺服器 panic，即使某些執行緒的建立可能成功。為了簡單起見，這種行為是可以接受的，但在一個生產環境的 thread pool 實作中，你可能想要使用 `std::thread::Builder` 及其 `spawn` 方法，該方法會回傳 `Result`。

這段程式碼將會編譯，並會儲存我們指定為 `ThreadPool::new` 引數的 `Worker` 實例數量。但我們*仍然*沒有處理我們在 `execute` 中得到的閉包。讓我們接下來看看如何做到這一點。

<h4>透過 channel 將請求傳送給執行緒</h4>

我們接下來要解決的問題是，傳遞給 `thread::spawn` 的閉包完全不做任何事情。目前，我們在 `execute` 方法中得到了我們想要執行的閉包。但是當我們在建立 `ThreadPool` 的過程中建立每個 `Worker` 時，我們需要給 `thread::spawn` 一個閉包來運行。

我們希望我們剛剛建立的 `Worker` struct 從 `ThreadPool` 中持有的佇列中獲取要運行的程式碼，並將該程式碼發送到它的執行緒去運行。

我們在第 16 章中學到的 channel——一種在兩個執行緒之間進行簡單通訊的方式——將非常適合這個用例。我們將使用一個 channel 作為工作的佇列，`execute` 將從 `ThreadPool` 發送一個工作到 `Worker` 實例，而 `Worker` 實例將把工作發送到它的執行緒。計畫如下：

1. `ThreadPool` 將建立一個 channel 並持有 sender。
2. 每個 `Worker` 將持有 receiver。
3. 我們將建立一個新的 `Job` struct，它將持有我們想要透過 channel 發送的閉包。
4. `execute` 方法將透過 sender 發送它想要執行的工作。
5. 在它的執行緒中，`Worker` 將在其 receiver 上迴圈，並執行它收到的任何工作的閉包。

讓我們從在 `ThreadPool::new` 中建立一個 channel 並在 `ThreadPool` 實例中持有 sender 開始，如程式碼清單 21-16 所示。`Job` struct 目前不包含任何東西，但它將是我們透過 channel 發送的項目型別。

src/lib.rs

```rust
use std::{sync::mpsc, thread};

pub struct ThreadPool {
    workers: Vec<Worker>,
    sender: mpsc::Sender<Job>,
}

struct Job;

impl ThreadPool {
    // --snip--
    pub fn new(size: usize) -> ThreadPool {
        assert!(size > 0);

        let (sender, receiver) = mpsc::channel();

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id));
        }

        ThreadPool { workers, sender }
    }
    // --snip--
}
```

程式碼清單 21-16：修改 `ThreadPool` 以儲存傳輸 `Job` 實例的 channel 的 sender

在 `ThreadPool::new` 中，我們建立我們的新 channel，並讓池持有 sender。這將成功編譯。

讓我們試著在 thread pool 建立 channel 時，將 channel 的 receiver 傳遞給每個 `Worker`。我們知道我們想要在 `Worker` 實例 spawn 的執行緒中使用 receiver，所以我們將在閉包中引用 `receiver` 參數。程式碼清單 21-17 中的程式碼還不能完全編譯。

src/lib.rs

```rust
impl ThreadPool {
    // --snip--
    pub fn new(size: usize) -> ThreadPool {
        assert!(size > 0);

        let (sender, receiver) = mpsc::channel();

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, receiver));
        }

        ThreadPool { workers, sender }
    }
    // --snip--
}

// --snip--

impl Worker {
    fn new(id: usize, receiver: mpsc::Receiver<Job>) -> Worker {
        let thread = thread::spawn(|| {
            receiver;
        });

        Worker { id, thread }
    }
}
```

程式碼清單 21-17：將 receiver 傳遞給每個 `Worker`

我們做了一些小而直接的改變：我們將 receiver 傳入 `Worker::new`，然後在閉包內部使用它。

當我們試圖檢查這段程式碼時，我們得到這個錯誤：

```
$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0382]: use of moved value: `receiver`
  --> src/lib.rs:26:42
   |
21 |         let (sender, receiver) = mpsc::channel();
   |                      -------- move occurs because `receiver` has type `std::sync::mpsc::Receiver<Job>`, which does not implement the `Copy` trait
...
25 |         for id in 0..size {
   |         ----------------- inside of this loop
26 |             workers.push(Worker::new(id, receiver));
   |                                          ^^^^^^^^ value moved here, in previous iteration of loop
   |
note: consider changing this parameter type in method `new` to borrow instead if owning the value isn't necessary
  --> src/lib.rs:47:33
   |
47 |     fn new(id: usize, receiver: mpsc::Receiver<Job>) -> Worker {
   |        --- in this method       ^^^^^^^^^^^^^^^^^^^ this parameter takes ownership of the value
help: consider moving the expression out of the loop so it is only moved once
   |
25 ~         let mut value = Worker::new(id, receiver);
26 ~         for id in 0..size {
27 ~             workers.push(value);
   |

For more information about this error, try `rustc --explain E0382`.
error: could not compile `hello` (lib) due to 1 previous error
```

程式碼試圖將 `receiver` 傳遞給多個 `Worker` 實例。這將無法運作，正如你從第 16 章中回憶的：Rust 提供的 channel 實作是多個_生產者_，單一_消費者_。這意味著我們不能僅僅複製 channel 的消費端來修復這段程式碼。我們也不想將一則訊息多次發送給多個消費者；我們想要一個訊息列表，讓多個 `Worker` 實例處理，使得每則訊息只被處理一次。

此外，從 channel 佇列中取走一個工作涉及改變 `receiver`，所以執行緒需要一種安全的方式來共享和修改 `receiver`；否則，我們可能會遇到競爭條件（如第 16 章所述）。

回想一下第 16 章討論的執行緒安全智慧指標：為了在多個執行緒之間共享所有權並允許執行緒改變值，我們需要使用 `Arc<Mutex<T>>`。`Arc` 型別將允許多個 `Worker` 實例擁有 receiver，而 `Mutex` 將確保一次只有一個 `Worker` 從 receiver 獲取工作。程式碼清單 21-18 顯示了我們需要做的更改。

src/lib.rs

```rust
use std::{
    sync::{mpsc, Arc, Mutex},
    thread,
};
// --snip--

impl ThreadPool {
    // --snip--
    pub fn new(size: usize) -> ThreadPool {
        assert!(size > 0);

        let (sender, receiver) = mpsc::channel();

        let receiver = Arc::new(Mutex::new(receiver));

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&receiver)));
        }

        ThreadPool { workers, sender }
    }

    // --snip--
}

// --snip--

impl Worker {
    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker {
        // --snip--
    }
}
```

程式碼清單 21-18：使用 `Arc` 和 `Mutex` 在 `Worker` 實例之間共享 receiver

在 `ThreadPool::new` 中，我們將 receiver 放入一個 `Arc` 和一個 `Mutex` 中。對於每個新的 `Worker`，我們複製 `Arc` 來增加引用計數，這樣 `Worker` 實例就可以共享 receiver 的所有權。

有了這些更改，程式碼可以編譯了！我們快成功了！

<h4>實作 execute 方法</h4>

讓我們終於在 `ThreadPool` 上實作 `execute` 方法。我們也會將 `Job` 從一個 struct 更改為一個型別別名，它是一個 trait object，持有 `execute` 接收的閉包型別。正如第 20 章「使用型別別名建立型別同義詞」中所討論的，型別別名讓我們可以將長的型別縮短以便於使用。請看程式碼清單 21-19。

src/lib.rs

```rust
// --snip--

type Job = Box<dyn FnOnce() + Send + 'static>;

impl ThreadPool {
    // --snip--

    pub fn execute<F>(&self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);

        self.sender.send(job).unwrap();
    }
}

// --snip--
```

程式碼清單 21-19：為一個持有每個閉包的 `Box` 建立一個 `Job` 型別別名，然後將工作透過 channel 發送出去

在使用 `execute` 中得到的閉包建立一個新的 `Job` 實例後，我們將該工作透過 channel 的發送端發送出去。我們在 `send` 上呼叫 `unwrap` 是為了處理發送失敗的情況。這種情況可能發生，例如，如果我們停止所有執行緒的執行，這意味著接收端已經停止接收新訊息。目前，我們無法停止我們的執行緒執行：我們的執行緒只要池存在就會繼續執行。我們使用 `unwrap` 的原因是我們知道失敗的情況不會發生，但編譯器不知道。

但我們還沒完成！在 `Worker` 中，我們傳遞給 `thread::spawn` 的閉包仍然只*引用*了 channel 的接收端。相反，我們需要閉包永遠迴圈，向 channel 的接收端請求工作，並在得到工作時運行它。讓我們對 `Worker::new` 進行程式碼清單 21-20 中顯示的更改。

src/lib.rs

```rust
// --snip--

impl Worker {
    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker {
        let thread = thread::spawn(move || loop {
            let job = receiver.lock().unwrap().recv().unwrap();

            println!("Worker {id} got a job; executing.");

            job();
        });

        Worker { id, thread }
    }
}
```

程式碼清單 21-20：在 `Worker` 實例的執行緒中接收並執行工作

在這裡，我們首先在 `receiver` 上呼叫 `lock` 來獲取 mutex，然後我們呼叫 `unwrap` 來對任何錯誤進行 panic。獲取鎖可能會失敗，如果 mutex 處於_中毒_（_poisoned_）狀態，這可能發生在某個其他執行緒在持有鎖時 panic 而不是釋放鎖的情況下。在這種情況下，呼叫 `unwrap` 讓這個執行緒 panic 是正確的行動。你可以隨意將這個 `unwrap` 改為帶有對你有意義的錯誤訊息的 `expect`。

如果我們獲得了 mutex 的鎖，我們就呼叫 `recv` 來從 channel 接收一個 `Job`。最後一個 `unwrap` 也會跳過這裡的任何錯誤，這可能發生在持有 sender 的執行緒已經關閉的情況下，類似於如果 receiver 關閉，`send` 方法會回傳 `Err`。

`recv` 的呼叫會阻塞，所以如果還沒有工作，目前的執行緒會等待直到有工作可用。`Mutex<T>` 確保一次只有一個 `Worker` 執行緒在嘗試請求工作。

我們的 thread pool 現在處於可運作狀態！給它一個 `cargo run` 並發出一些請求：

<!-- manual-regeneration
cd listings/ch21-web-server/listing-21-20
cargo run
make some requests to 127.0.0.1:7878
Can't automate because the output depends on making requests
-->

```
$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
warning: field `workers` is never read
 --> src/lib.rs:7:5
  |
6 | pub struct ThreadPool {
  |            ---------- field in this struct
7 |     workers: Vec<Worker>,
  |     ^^^^^^^
  |
  = note: `#[warn(dead_code)]` on by default

warning: fields `id` and `thread` are never read
  --> src/lib.rs:48:5
   |
47 | struct Worker {
   |        ------ fields in this struct
48 |     id: usize,
   |     ^^
49 |     thread: thread::JoinHandle<()>,
   |     ^^^^^^

warning: `hello` (lib) generated 2 warnings
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 4.91s
     Running `target/debug/hello`
Worker 0 got a job; executing.
Worker 2 got a job; executing.
Worker 1 got a job; executing.
Worker 3 got a job; executing.
Worker 0 got a job; executing.
Worker 2 got a job; executing.
Worker 1 got a job; executing.
Worker 3 got a job; executing.
Worker 0 got a job; executing.
Worker 2 got a job; executing.
```

成功了！我們現在有一個可以非同步執行連線的 thread pool。從來不會建立超過四個執行緒，所以如果伺服器收到大量請求，我們的系統也不會超載。如果我們向 `*/sleep*` 發出請求，伺服器將能夠透過讓另一個執行緒運行其他請求來服務它們。

> 注意：如果你同時在多個瀏覽器視窗中打開 `*/sleep*`，它們可能會以五秒的間隔逐一載入。一些網頁瀏覽器出於快取原因會順序執行同一個請求的多個實例。這個限制不是由我們的網頁伺服器造成的。

這是一個很好的時機，可以停下來思考一下，如果我們使用 future 而不是閉包來完成工作，程式碼清單 21-18、21-19 和 21-20 中的程式碼會有什麼不同。哪些型別會改變？方法簽名會有何不同，如果有的話？程式碼的哪些部分會保持不變？

在第 17 章和第 19 章學習了 `while let` 迴圈之後，你可能會想知道為什麼我們沒有像程式碼清單 21-21 那樣編寫 `Worker` 執行緒的程式碼。

src/lib.rs

```rust
// --snip--

impl Worker {
    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker {
        let thread = thread::spawn(move || {
            while let Ok(job) = receiver.lock().unwrap().recv() {
                println!("Worker {id} got a job; executing.");

                job();
            }
        });

        Worker { id, thread }
    }
}
```

程式碼清單 21-21：使用 `while let` 的 `Worker::new` 替代實作

這段程式碼可以編譯和運行，但不會產生期望的執行緒行為：一個慢速的請求仍然會導致其他請求等待處理。原因有些微妙：`Mutex` struct 沒有公開的 `unlock` 方法，因為鎖的所有權是基於 `lock` 方法回傳的 `LockResult<MutexGuard<T>>` 中的 `MutexGuard<T>` 的生命週期。在編譯時，借用檢查器可以強制執行一個規則，即除非我們持有鎖，否則不能存取由 `Mutex` 保護的資源。然而，如果我們不注意 `MutexGuard<T>` 的生命週期，這種實作也可能導致鎖被持有的時間比預期的要長。

程式碼清單 21-20 中使用 `let job = receiver.lock().unwrap().recv().unwrap();` 的程式碼之所以能運作，是因為使用 `let` 時，等號右側表達式中使用的任何臨時值在 `let` 語句結束時會立即被 drop。然而，`while let`（以及 `if let` 和 `match`）在相關區塊結束之前不會 drop 臨時值。在程式碼清單 21-21 中，鎖在 `job()` 呼叫的整個過程中都保持著，這意味著其他 `Worker` 實例無法接收工作。

## 優雅地關閉與清理

程式碼清單 21-20 中的程式碼正如我們所預期的，透過使用 thread pool 來非同步回應請求。我們得到了一些關於 `workers`、`id` 和 `thread` 欄位的警告，因為我們沒有以一種直接的方式使用它們，這提醒我們我們沒有清理任何東西。當我們使用不那麼優雅的 <kbd>ctrl</kbd>-<kbd>C</kbd> 方法來停止主執行緒時，所有其他執行緒也會立即停止，即使它們正在服務請求的中途。

接下來，我們將實作 `Drop` trait 來對池中的每個執行緒呼叫 `join`，這樣它們就可以在關閉前完成它們正在處理的請求。然後我們將實作一種方式來告訴執行緒它們應該停止接受新的請求並關閉。為了看到這段程式碼的實際效果，我們將修改我們的伺服器，使其只接受兩個請求，然後優雅地關閉其 thread pool。

在我們進行的過程中，有一件事值得注意：這一切都不會影響處理執行閉包的程式碼部分，所以如果我們為一個 async runtime 使用 thread pool，這裡的一切都會完全相同。

### 在 ThreadPool 上實作 Drop trait

讓我們從在我們的 thread pool 上實作 `Drop` 開始。當池被 drop 時，我們的執行緒應該都 join 以確保它們完成它們的工作。程式碼清單 21-22 顯示了 `Drop` 實作的第一次嘗試；這段程式碼還不能完全運作。

src/lib.rs

```rust
impl Drop for ThreadPool {
    fn drop(&mut self) {
        for worker in &mut self.workers {
            println!("Shutting down worker {}", worker.id);

            worker.thread.join().unwrap();
        }
    }
}
```

程式碼清單 21-22：當 thread pool 離開作用域時，join 每個執行緒

首先，我們遍歷每個 thread pool 的 `workers`。我們為此使用 `&mut`，因為 `self` 是一個可變引用，而且我們也需要能夠改變 `worker`。對於每個 `worker`，我們印出一條訊息，說明這個特定的 `Worker` 實例正在關閉，然後我們在該 `Worker` 實例的執行緒上呼叫 `join`。如果對 `join` 的呼叫失敗，我們使用 `unwrap` 讓 Rust panic 並進入一個不優雅的關閉過程。

這是我們編譯這段程式碼時得到的錯誤：

```
$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0507]: cannot move out of `worker.thread` which is behind a mutable reference
  --> src/lib.rs:52:13
   |
52 |             worker.thread.join().unwrap();
   |             ^^^^^^^^^^^^^ ------ `worker.thread` moved due to this method call
   |             |
   |             move occurs because `worker.thread` has type `JoinHandle<()>`, which does not implement the `Copy` trait
   |
note: `JoinHandle::<T>::join` takes ownership of the receiver `self`, which moves `worker.thread`
  --> /rustc/4eb161250e340c8f48f66e2b929ef4a5bed7c181/library/std/src/thread/mod.rs:1876:17

For more information about this error, try `rustc --explain E0507`.
error: could not compile `hello` (lib) due to 1 previous error
```

錯誤告訴我們我們不能呼叫 `join`，因為我們只有每個 `worker` 的可變借用，而 `join` 取得其引數的所有權。為了解決這個問題，我們需要將執行緒移出擁有 `thread` 的 `Worker` 實例，這樣 `join` 才能消費該執行緒。一種解決方法是採取我們在程式碼清單 18-15 中使用的方法。如果 `Worker` 持有一個 `Option<thread::JoinHandle<()>>`，我們可以對 `Option` 呼叫 `take` 方法，將值移出 `Some` variant 並在原地留下一個 `None` variant。換句話說，一個正在運行的 `Worker` 在 `thread` 中會有一個 `Some` variant，當我們想要清理一個 `Worker` 時，我們會用 `None` 替換 `Some`，這樣 `Worker` 就不會有一個執行緒可以運行。

然而，*只有*在 drop `Worker` 時才會出現這種情況。作為交換，我們將不得不在任何我們存取 `worker.thread` 的地方處理一個 `Option<thread::JoinHandle<()>>`。慣用的 Rust 程式碼大量使用 `Option`，但當你發現自己為了像這樣的權宜之計而將一個你知道將永遠存在的東西包裝在 `Option` 中時，最好尋找替代方法，使你的程式碼更清晰、更不容易出錯。

在這種情況下，存在一個更好的替代方案：`Vec::drain` 方法。它接受一個範圍參數來指定要從 vector 中移除哪些項目，並回傳這些項目的迭代器。傳遞 `..` 範圍語法將從 vector 中移除*每個*值。

所以我們需要像這樣更新 `ThreadPool` 的 `drop` 實作：

src/lib.rs

```rust
impl Drop for ThreadPool {
    fn drop(&mut self) {
        for worker in self.workers.drain(..) {
            println!("Shutting down worker {}", worker.id);

            worker.thread.join().unwrap();
        }
    }
}
```

這解決了編譯器錯誤，並且不需要對我們的程式碼進行任何其他更改。請注意，因為 `drop` 可能在 panic 時被呼叫，`unwrap` 也可能 panic 並導致雙重 panic，這會立即使程式崩潰並結束任何正在進行的清理工作。這對於一個範例程式來說是可以的，但不建議用於生產程式碼。

### 通知執行緒停止監聽工作

經過我們所做的所有更改，我們的程式碼可以無警告地編譯。然而，壞消息是這段程式碼還沒有按照我們想要的方式運作。關鍵在於 `Worker` 實例的執行緒運行的閉包中的邏輯：目前，我們呼叫 `join`，但這不會關閉執行緒，因為它們永遠 `loop` 尋找工作。如果我們試圖用我們目前的 `drop` 實作來 drop 我們的 `ThreadPool`，主執行緒將永遠阻塞，等待第一個執行緒完成。

為了解決這個問題，我們需要在 `ThreadPool` 的 `drop` 實作中做一個改變，然後在 `Worker` 迴圈中做一個改變。

首先，我們將更改 `ThreadPool` 的 `drop` 實作，以在等待執行緒完成之前明確地 drop `sender`。程式碼清單 21-23 顯示了 `ThreadPool` 的更改，以明確地 drop `sender`。與執行緒不同，這裡我們*確實*需要使用一個 `Option`，以便能夠使用 `Option::take` 將 `sender` 移出 `ThreadPool`。

src/lib.rs

```rust
pub struct ThreadPool {
    workers: Vec<Worker>,
    sender: Option<mpsc::Sender<Job>>,
}
// --snip--
impl ThreadPool {
    pub fn new(size: usize) -> ThreadPool {
        // --snip--

        ThreadPool {
            workers,
            sender: Some(sender),
        }
    }

    pub fn execute<F>(&self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);

        self.sender.as_ref().unwrap().send(job).unwrap();
    }
}

impl Drop for ThreadPool {
    fn drop(&mut self) {
        drop(self.sender.take());

        for worker in self.workers.drain(..) {
            println!("Shutting down worker {}", worker.id);

            worker.thread.join().unwrap();
        }
    }
}
```

程式碼清單 21-23：在 join `Worker` 執行緒之前明確地 drop `sender`

Drop `sender` 會關閉 channel，這表示不會再有訊息被發送。當這種情況發生時，`Worker` 實例在無限迴圈中所做的所有 `recv` 呼叫都將回傳一個錯誤。在程式碼清單 21-24 中，我們更改 `Worker` 迴圈，在這種情況下優雅地退出迴圈，這意味著當 `ThreadPool` 的 `drop` 實作對它們呼叫 `join` 時，執行緒將會完成。

src/lib.rs

```rust
impl Worker {
    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker {
        let thread = thread::spawn(move || loop {
            let message = receiver.lock().unwrap().recv();

            match message {
                Ok(job) => {
                    println!("Worker {id} got a job; executing.");

                    job();
                }
                Err(_) => {
                    println!("Worker {id} disconnected; shutting down.");
                    break;
                }
            }
        });

        Worker { id, thread }
    }
}
```

程式碼清單 21-24：當 `recv` 回傳錯誤時，明確地跳出迴圈

為了看到這段程式碼的實際效果，讓我們修改 `main`，使其在優雅地關閉伺服器之前只接受兩個請求，如程式碼清單 21-25 所示。

src/main.rs

```rust
fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming().take(2) {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }

    println!("Shutting down.");
}
```

程式碼清單 21-25：在服務兩個請求後透過退出迴圈來關閉伺服器

你不會希望一個真實世界的網頁伺服器在只服務了兩個請求後就關閉。這段程式碼只是為了展示優雅關閉和清理的功能是正常的。

`take` 方法定義在 `Iterator` trait 中，它將迭代限制為最多前兩個項目。`ThreadPool` 將在 `main` 結束時離開作用域，`drop` 實作將會運行。

用 `cargo run` 啟動伺服器，並發出三個請求。第三個請求應該會出錯，在你的終端機中，你應該會看到類似這樣的輸出：

<!-- manual-regeneration
cd listings/ch21-web-server/listing-21-25
cargo run
curl http://127.0.0.1:7878
curl http://127.0.0.1:7878
curl http://127.0.0.1:7878
third request will error because server will have shut down
copy output below
Can't automate because the output depends on making requests
-->

```
$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.41s
     Running `target/debug/hello`
Worker 0 got a job; executing.
Shutting down.
Shutting down worker 0
Worker 3 got a job; executing.
Worker 1 disconnected; shutting down.
Worker 2 disconnected; shutting down.
Worker 3 disconnected; shutting down.
Worker 0 disconnected; shutting down.
Shutting down worker 1
Shutting down worker 2
Shutting down worker 3
```

你可能會看到 `Worker` ID 和印出訊息的順序不同。我們可以從訊息中看出這段程式碼是如何運作的：`Worker` 實例 0 和 3 得到了前兩個請求。伺服器在第二次連線後停止接受連線，`ThreadPool` 上的 `Drop` 實作在 `Worker` 3 甚至開始其工作之前就開始執行了。Drop `sender` 會斷開所有 `Worker` 實例的連線並告訴它們關閉。`Worker` 實例在斷開連線時各自印出一條訊息，然後 thread pool 呼叫 `join` 來等待每個 `Worker` 執行緒完成。

注意這個特定執行的一個有趣方面：`ThreadPool` drop 了 `sender`，在任何 `Worker` 收到錯誤之前，我們試圖 join `Worker` 0。`Worker` 0 還沒有從 `recv` 得到錯誤，所以主執行緒阻塞，等待 `Worker` 0 完成。與此同時，`Worker` 3 收到了一個工作，然後所有執行緒都收到了錯誤。當 `Worker` 0 完成後，主執行緒等待其餘的 `Worker` 實例完成。在那時，它們都已經退出了它們的迴圈並停止了。

恭喜！我們現在已經完成了我們的專案；我們有一個基本的網頁伺服器，它使用一個 thread pool 來非同步回應。我們能夠對伺服器進行優雅的關閉，這會清理池中的所有執行緒。

這是完整的程式碼以供參考：

src/main.rs

```rust
use hello::ThreadPool;
use std::{
    fs,
    io::{prelude::*, BufReader},
    net::{TcpListener, TcpStream},
    thread,
    time::Duration,
};

fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming().take(2) {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }

    println!("Shutting down.");
}

fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&mut stream);
    let request_line = buf_reader.lines().next().unwrap().unwrap();

    let (status_line, filename) = match &request_line[..] {
        "GET / HTTP/1.1" => ("HTTP/1.1 200 OK", "hello.html"),
        "GET /sleep HTTP/1.1" => {
            thread::sleep(Duration::from_secs(5));
            ("HTTP/1.1 200 OK", "hello.html")
        }
        _ => ("HTTP/1.1 404 NOT FOUND", "404.html"),
    };

    let contents = fs::read_to_string(filename).unwrap();
    let length = contents.len();

    let response =
        format!("{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}");

    stream.write_all(response.as_bytes()).unwrap();
}
```

src/lib.rs

```rust
use std::{
    sync::{mpsc, Arc, Mutex},
    thread,
};

pub struct ThreadPool {
    workers: Vec<Worker>,
    sender: Option<mpsc::Sender<Job>>,
}

type Job = Box<dyn FnOnce() + Send + 'static>;

impl ThreadPool {
    /// Create a new ThreadPool.
    ///
    /// The size is the number of threads in the pool.
    ///
    /// # Panics
    ///
    /// The `new` function will panic if the size is zero.
    pub fn new(size: usize) -> ThreadPool {
        assert!(size > 0);

        let (sender, receiver) = mpsc::channel();

        let receiver = Arc::new(Mutex::new(receiver));

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&receiver)));
        }

        ThreadPool {
            workers,
            sender: Some(sender),
        }
    }

    pub fn execute<F>(&self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);

        self.sender.as_ref().unwrap().send(job).unwrap();
    }
}

impl Drop for ThreadPool {
    fn drop(&mut self) {
        drop(self.sender.take());

        for worker in &mut self.workers {
            println!("Shutting down worker {}", worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}

struct Worker {
    id: usize,
    thread: Option<thread::JoinHandle<()>>,
}

impl Worker {
    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker {
        let thread = thread::spawn(move || loop {
            let message = receiver.lock().unwrap().recv();

            match message {
                Ok(job) => {
                    println!("Worker {id} got a job; executing.");

                    job();
                }
                Err(_) => {
                    println!("Worker {id} disconnected; shutting down.");
                    break;
                }
            }
        });

        Worker {
            id,
            thread: Some(thread),
        }
    }
}
```

我們在這裡還可以做更多事！如果你想繼續增強這個專案，這裡有一些想法：

- 為 `ThreadPool` 及其公共方法添加更多文件。
- 為函式庫的功能添加測試。
- 將 `unwrap` 的呼叫改為更穩健的錯誤處理。
- 使用 `ThreadPool` 來執行除了服務網頁請求之外的一些任務。
- 在 crates.io（_https://crates.io/_）上找到一個 thread pool crate，並使用該 crate 來實作一個類似的網頁伺服器。然後將其 API 和穩健性與我們實作的 thread pool 進行比較。

## 總結

做得好！你已經讀完了本書的結尾！我們想感謝你與我們一起完成這次 Rust 之旅。你現在已經準備好實作自己的 Rust 專案，並幫助其他人的專案。請記住，有一個熱情友好的 Rustacean 社群，他們很樂意在你 Rust 旅程中遇到的任何挑戰上幫助你。
