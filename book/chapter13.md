<!-- DO NOT EDIT THIS FILE.

This file is periodically generated from the content in the `/src/`
directory, so all fixes need to be made in `/src/`.
-->

[TOC]

# 函數式語言特性：Iterators 與 Closures

Rust 的設計從許多現有的語言和技術中汲取了靈感，其中一個重要的影響是_函數式程式設計_（functional programming）。以函數式風格編程通常包括將函數作為值來使用，例如將它們作為參數傳遞、從其他函數中返回它們、將它們賦值給變數以供稍後執行等等。

在本章中，我們將不討論 functional programming 是什麼或不是什麼的問題，而是討論 Rust 中與許多常被稱為函數式語言的特性相似的一些功能。

更具體地說，我們將涵蓋：

- _Closures_：一種可以儲存在變數中的類函數結構
- _Iterators_：一種處理一系列元素的方式
- 如何使用 closures 和 iterators 來改進第 12 章的 I/O project
- closures 和 iterators 的 performance（劇透：它們比你想像的還要快！）

我們已經涵蓋了 Rust 的其他一些功能，例如 pattern matching 和 enums，這些也受到函數式風格的影響。由於掌握 closures 和 iterators 是編寫慣用且快速的 Rust 程式碼的重要部分，我們將整個章節專注於它們。

<!-- Old heading. Do not remove or links may break. -->

<a id="closures-anonymous-functions-that-can-capture-their-environment"></a>

## Closures：能夠捕捉其環境的匿名函數

Rust 的 closures 是匿名函數，你可以將它們儲存到變數中，或作為引數傳遞給其他函數。你可以在一個地方建立 closure，然後在其他地方呼叫該 closure 以在不同的 context 中評估它。與 functions 不同，closures 可以從它們定義的作用域中捕捉值。我們將展示這些 closure 特性如何實現程式碼重用和行為自定義。

<!-- Old headings. Do not remove or links may break. -->

<a id="creating-an-abstraction-of-behavior-with-closures"></a>
<a id="refactoring-using-functions"></a>
<a id="refactoring-with-closures-to-store-code"></a>

### 使用 Closures 捕捉環境

我們將首先探討如何使用 closures 來捕捉它們定義的環境中的值，以供稍後使用。場景是這樣的：我們的 T 恤公司每隔一段時間就會向我們的 mailing list 中的某人贈送一件獨家限量版 T 恤作為促銷活動。mailing list 上的人可以選擇在他們的個人資料中添加他們最喜歡的顏色。如果被選中獲得免費襯衫的人設定了他們最喜歡的顏色，他們就會得到那種顏色的襯衫。如果該人沒有指定最喜歡的顏色，他們就會得到公司目前庫存最多的顏色。

有很多方法可以實現這一點。對於這個範例，我們將使用一個名為 `ShirtColor` 的 enum，它有 `Red` 和 `Blue` 變體（為求簡潔，限制了可用顏色的數量）。我們用一個 `Inventory` struct 來表示公司的庫存，該 struct 有一個名為 `shirts` 的欄位，其中包含一個 `Vec<ShirtColor>`，表示目前庫存中的襯衫顏色。定義在 `Inventory` 上的 `giveaway` 方法會獲取免費襯衫中獎者的可選襯衫顏色偏好，並返回該人將獲得的襯衫顏色。此設定如 Listing 13-1 所示。

src/main.rs

```rust
#[derive(Debug, PartialEq, Copy, Clone)]
enum ShirtColor {
    Red,
    Blue,
}

struct Inventory {
    shirts: Vec<ShirtColor>,
}

impl Inventory {
    fn giveaway(&self, user_preference: Option<ShirtColor>) -> ShirtColor {
        user_preference.unwrap_or_else(|| self.most_stocked())
    }

    fn most_stocked(&self) -> ShirtColor {
        let mut num_red = 0;
        let mut num_blue = 0;

        for color in &self.shirts {
            match color {
                ShirtColor::Red => num_red += 1,
                ShirtColor::Blue => num_blue += 1,
            }
        }
        if num_red > num_blue {
            ShirtColor::Red
        } else {
            ShirtColor::Blue
        }
    }
}

fn main() {
    let store = Inventory {
        shirts: vec![ShirtColor::Blue, ShirtColor::Red, ShirtColor::Blue],
    };

    let user_pref1 = Some(ShirtColor::Red);
    let giveaway1 = store.giveaway(user_pref1);
    println!(
        "The user with preference {:?} gets {:?}",
        user_pref1, giveaway1
    );

    let user_pref2 = None;
    let giveaway2 = store.giveaway(user_pref2);
    println!(
        "The user with preference {:?} gets {:?}",
        user_pref2, giveaway2
    );
}
```

Listing 13-1：T 恤公司贈品情境

`main` 中定義的 `store` 還有兩件藍色襯衫和一件紅色襯衫要分發給這次限量版促銷活動。我們為一個偏好紅色襯衫的使用者和一個沒有任何偏好的使用者呼叫了 `giveaway` 方法。

同樣，這段程式碼可以用多種方式實現，在這裡，為了專注於 closures，我們堅持使用你已經學過的概念，除了 `giveaway` 方法的主體使用了 closure。在 `giveaway` 方法中，我們將使用者偏好作為 `Option<ShirtColor>` 類型的參數獲取，並在 `user_preference` 上呼叫 `unwrap_or_else` 方法。`Option<T>` 上的 `unwrap_or_else` 方法由標準函式庫定義。它接受一個參數：一個不帶任何引數但返回 `T` 值（在這種情況下，`Option<T>` 的 `Some` 變體中儲存的相同類型 `ShirtColor`）的 closure。如果 `Option<T>` 是 `Some` 變體，`unwrap_or_else` 會返回 `Some` 內的值。如果 `Option<T>` 是 `None` 變體，`unwrap_or_else` 會呼叫該 closure 並返回由 closure 返回的值。

我們將 closure 表達式 `|| self.most_stocked()` 指定為 `unwrap_or_else` 的引數。這是一個不接受任何參數的 closure（如果 closure 有參數，它們會出現在兩個垂直線之間）。closure 的主體呼叫了 `self.most_stocked()`。我們在這裡定義 closure，而 `unwrap_or_else` 的實作將在稍後需要結果時評估這個 closure。

執行這段程式碼會印出以下內容：

```
$ cargo run
   Compiling shirt-company v0.1.0 (file:///projects/shirt-company)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.27s
     Running `target/debug/shirt-company`
The user with preference Some(Red) gets Red
The user with preference None gets Blue
```

這裡一個有趣的方面是，我們傳遞了一個 closure，它在目前的 `Inventory` 實例上呼叫了 `self.most_stocked()`。標準函式庫不需要知道我們定義的 `Inventory` 或 `ShirtColor` 類型，也不需要知道我們在這個情境中想要使用的邏輯。closure 捕捉了對 `self` `Inventory` 實例的 immutable reference，並將其與我們指定的程式碼一起傳遞給 `unwrap_or_else` 方法。另一方面，Functions 無法以這種方式捕捉其環境。

### Closure 類型推斷與註解

functions 和 closures 之間還有更多不同之處。Closures 通常不需要你像 `fn` functions 那樣註解參數或回傳值的類型。Functions 之所以需要類型註解，是因為類型是暴露給使用者明確 interface 的一部分。嚴格定義這個 interface 對於確保每個人都同意 function 使用和返回什麼類型的值非常重要。另一方面，Closures 不會像這樣用於公開 interface：它們被儲存在變數中，無需命名並暴露給函式庫的使用者即可使用。

Closures 通常很簡短，並且只在狹窄的 context 中相關，而不是在任何任意情境下。在這些有限的 context 中，compiler 可以推斷參數和回傳值的類型，類似於它能夠推斷大多數變數的類型（在極少數情況下，compiler 也需要 closure 類型註解）。

與變數一樣，如果我們想增加明確性和清晰度，我們可以添加類型註解，代價是比嚴格必要的更冗長。為 closure 註解類型看起來會像 Listing 13-2 中所示的定義。在這個範例中，我們定義了一個 closure 並將其儲存到變數中，而不是像 Listing 13-1 中那樣在我們傳遞它作為引數的位置定義 closure。

src/main.rs

```rust
let expensive_closure = |num: u32| -> u32 {
    println!("calculating slowly...");
    thread::sleep(Duration::from_secs(2));
    num
};
```

Listing 13-2：在 closure 中新增參數和回傳值類型的可選類型註解

添加類型註解後，closures 的語法看起來更像是 functions 的語法。在這裡，我們定義了一個將其參數加 1 的 function，以及一個具有相同行為的 closure，以供比較。我們添加了一些空格來對齊相關部分。這說明了 closure 語法與 function 語法相似，除了使用管道符號和可選語法量之外：

```rust
fn  add_one_v1   (x: u32) -> u32 { x + 1 }
let add_one_v2 = |x: u32| -> u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;
```

第一行顯示一個 function 定義，第二行顯示一個完全註解的 closure 定義。在第三行中，我們從 closure 定義中移除了類型註解。在第四行中，我們移除了括號，這是可選的，因為 closure 主體只有一個表達式。這些都是有效的定義，當它們被呼叫時將產生相同的行為。`add_one_v3` 和 `add_one_v4` 行要求 closures 被評估才能編譯，因為類型將從其用法中推斷出來。這類似於 `let v = Vec::new();` 需要類型註解或某種類型的值插入到 `Vec` 中，Rust 才能推斷其類型。

對於 closure 定義，compiler 將為其每個參數和其回傳值推斷一個具體類型。例如，Listing 13-3 顯示了一個簡短 closure 的定義，它只返回它作為參數接收的值。這個 closure 除了用於本範例之外，並沒有太大的用處。請注意，我們沒有向定義添加任何類型註解。由於沒有類型註解，我們可以呼叫這個 closure，並傳遞任何類型，我們在這裡第一次使用 `String` 這樣做了。如果我們隨後嘗試用一個 integer 呼叫 `example_closure`，我們將會得到一個錯誤。

src/main.rs

```rust
    let example_closure = |x| x;

    let s = example_closure(String::from("hello"));
    let n = example_closure(5);
```

Listing 13-3：嘗試用兩種不同類型呼叫其類型被推斷的 closure

compiler 給出了這個錯誤：

```
$ cargo run
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
error[E0308]: mismatched types
 --> src/main.rs:5:29
  |
5 |     let n = example_closure(5);
  |             --------------- ^- help: try using a conversion method: `.to_string()`
  |             |               |
  |             |               expected `String`, found integer
  |             arguments to this function are incorrect
  |
note: expected because the closure was earlier called with an argument of type `String`
 --> src/main.rs:4:29
  |
4 |     let s = example_closure(String::from("hello"));
  |             --------------- ^^^^^^^^^^^^^^^^^^^^^ expected because this argument is of type `String`
  |             |
  |             in this closure call
note: closure parameter defined here
 --> src/main.rs:2:28
  |
2 |     let example_closure = |x| x;
  |                            ^

For more information about this error, try `rustc --explain E0308`.
error: could not compile `closure-example` (bin "closure-example") due to 1 previous error
```

當我們第一次用 `String` 值呼叫 `example_closure` 時，compiler 會推斷 `x` 的類型和 closure 的回傳類型為 `String`。這些類型隨後被鎖定在 `example_closure` 中的 closure 裡，當我們下次嘗試對同一個 closure 使用不同的類型時，我們就會得到一個類型錯誤。

### 捕捉參考或移動所有權

Closures 可以用三種方式從其環境中捕捉值，這直接對應了 function 接受參數的三種方式：immutable borrowing、mutable borrowing 和 taking ownership。Closure 將根據 function 主體對捕捉到的值所做的事情來決定使用哪種方式。

在 Listing 13-4 中，我們定義了一個 closure，它捕捉了對名為 `list` 的 vector 的 immutable reference，因為它只需要一個 immutable reference 即可印出值。

src/main.rs

```rust
fn main() {
    let list = vec![1, 2, 3];
    println!("Before defining closure: {list:?}");

    let only_borrows = || println!("From closure: {list:?}");

    println!("Before calling closure: {list:?}");
    only_borrows();
    println!("After calling closure: {list:?}");
}
```

Listing 13-4：定義並呼叫一個捕捉 immutable reference 的 closure

這個範例也說明了變數可以綁定到 closure 定義，而我們稍後可以透過使用變數名稱和括號來呼叫 closure，就好像變數名稱是一個 function 名稱一樣。

因為我們可以同時擁有對 `list` 的多個 immutable reference，所以 `list` 在 closure 定義之前的程式碼中、closure 定義之後但在 closure 被呼叫之前，以及 closure 被呼叫之後仍然可以存取。這段程式碼編譯、執行並印出：

```
$ cargo run
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/closure-example`
Before defining closure: [1, 2, 3]
Before calling closure: [1, 2, 3]
From closure: [1, 2, 3]
After calling closure: [1, 2, 3]
```

接著，在 Listing 13-5 中，我們改變了 closure 主體，使其向 `list` vector 添加一個元素。現在 closure 捕捉了一個 mutable reference。

src/main.rs

```rust
fn main() {
    let mut list = vec![1, 2, 3];
    println!("Before defining closure: {list:?}");

    let mut borrows_mutably = || list.push(7);

    borrows_mutably();
    println!("After calling closure: {list:?}");
}
```

Listing 13-5：定義並呼叫一個捕捉 mutable reference 的 closure

這段程式碼編譯、執行並印出：

```
$ cargo run
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/closure-example`
Before defining closure: [1, 2, 3]
After calling closure: [1, 2, 3, 7]
```

請注意，在 `borrows_mutably` closure 的定義和呼叫之間不再有 `println!`：當 `borrows_mutably` 被定義時，它捕捉了對 `list` 的 mutable reference。在 closure 被呼叫之後我們沒有再次使用 closure，所以 mutable borrow 結束了。在 closure 定義和 closure 呼叫之間，不允許 immutable borrow 以便印出，因為當存在 mutable borrow 時不允許其他 borrow。試著在那裡添加一個 `println!` 來看看你會得到什麼錯誤訊息！

如果你想強制 closure 取得它在環境中使用的值的所有權，即使 closure 的主體不嚴格需要所有權，你可以在參數列表前使用 `move` 關鍵字。

這種技術主要在將 closure 傳遞給新 thread 時很有用，以便移動資料使其由新 thread 擁有。我們將在第 16 章討論 concurrency 時詳細討論 threads 以及為什麼會想要使用它們，但現在，讓我們簡要地探討一下使用需要 `move` 關鍵字的 closure 來產生新 thread。Listing 13-6 顯示了 Listing 13-4 的修改版本，在新 thread 中而不是在 main thread 中印出 vector。

src/main.rs

```rust
use std::thread;

fn main() {
    let list = vec![1, 2, 3];
    println!("Before defining closure: {list:?}");

    thread::spawn(move || println!("From thread: {list:?}"))
        .join()
        .unwrap();
}
```

Listing 13-6：使用 `move` 強制 thread 的 closure 取得 `list` 的所有權

我們產生一個新 thread，將一個 closure 作為引數傳遞給該 thread 執行。closure 主體印出 `list`。在 Listing 13-4 中，closure 只使用一個 immutable reference 捕捉了 `list`，因為那是印出 `list` 所需的最小存取權限。在這個範例中，儘管 closure 主體仍然只需要一個 immutable reference，我們仍需要透過在 closure 定義的開頭放置 `move` 關鍵字來指定 `list` 應該被移動到 closure 中。如果 main thread 在呼叫新 thread 上的 `join` 之前執行了更多操作，新 thread 可能會在 main thread 的其餘部分完成之前結束，或者 main thread 可能會先結束。如果 main thread 維護 `list` 的所有權，但在新 thread 結束並釋放 `list` 之前結束，則 thread 中的 immutable reference 將無效。因此，compiler 要求將 `list` 移動到傳遞給新 thread 的 closure 中，這樣 reference 才會有效。嘗試移除 `move` 關鍵字或在 closure 定義後在 main thread 中使用 `list`，看看你會得到什麼 compiler errors！

<!-- Old headings. Do not remove or links may break. -->

<a id="storing-closures-using-generic-parameters-and-the-fn-traits"></a>
<a id="limitations-of-the-cacher-implementation"></a>
<a id="moving-captured-values-out-of-the-closure-and-the-fn-traits"></a>

### 將捕捉到的值移出 Closures 與 Fn Trait

一旦 closure 從定義 closure 的環境中捕捉到一個 reference 或捕捉到值的所有權（因此影響了什麼，如果有的話，被移_入_ closure），closure 主體中的程式碼定義了當 closure 稍後被評估時 reference 或值的去向（因此影響了什麼，如果有的話，被移_出_ closure）。

closure 主體可以執行以下任何操作：將捕捉到的值移出 closure、變更捕捉到的值、既不移動也不變更值，或者一開始就沒有從環境中捕捉任何東西。

closure 捕捉和處理環境中值的方式會影響 closure 實作哪些 traits，而 traits 是 functions 和 structs 用來指定它們可以使用哪種 closures 的方式。Closures 將自動實現這三個 `Fn` traits 中的一個、兩個或全部，以累加的方式，具體取決於 closure 的主體如何處理這些值：

- `FnOnce` 適用於可以被呼叫一次的 closures。所有 closures 至少都實現這個 trait，因為所有 closures 都可以被呼叫。一個將捕捉到的值從其主體移出的 closure 將只實作 `FnOnce`，而不實作其他 `Fn` traits，因為它只能被呼叫一次。
- `FnMut` 適用於不將捕捉到的值移出其主體，但可能會變更捕捉到的值的 closures。這些 closures 可以被呼叫多次。
- `Fn` 適用於不將捕捉到的值移出其主體且不變更捕捉到的值的 closures，以及不從其環境中捕捉任何東西的 closures。這些 closures 可以被呼叫多次而不會變更其環境，這在多個 closure 同時被呼叫的情況下很重要。

讓我們看看 `Option<T>` 上 `unwrap_or_else` 方法的定義，我們在 Listing 13-1 中使用了它：

```rust
impl<T> Option<T> {
    pub fn unwrap_or_else<F>(self, f: F) -> T
    where
        F: FnOnce() -> T
    {
        match self {
            Some(x) => x,
            None => f(),
        }
    }
}
```

回想一下，`T` 是代表 `Option` 的 `Some` 變體中值的類型的 generic type。這個類型 `T` 也是 `unwrap_or_else` function 的回傳類型：例如，在 `Option<String>` 上呼叫 `unwrap_or_else` 的程式碼將會得到一個 `String`。

接下來，請注意 `unwrap_or_else` function 還有額外的 generic type parameter `F`。`F` 類型是名為 `f` 的參數的類型，它就是我們在呼叫 `unwrap_or_else` 時提供的 closure。

在 generic type `F` 上指定的 trait bound 是 `FnOnce() -> T`，這表示 `F` 必須能夠被呼叫一次，不接受任何引數，並回傳一個 `T`。在 trait bound 中使用 `FnOnce` 表達了 `unwrap_or_else` 最多只會呼叫 `f` 一次的限制。在 `unwrap_or_else` 的主體中，我們可以看到如果 `Option` 是 `Some`，`f` 將不會被呼叫。如果 `Option` 是 `None`，`f` 將被呼叫一次。因為所有 closures 都實作 `FnOnce`，所以 `unwrap_or_else` 接受所有三種 closures，並且盡可能地靈活。

> 注意：如果我們想要做的事情不需要從環境中捕捉值，我們可以使用 function 的名稱而不是 closure，在我們需要實作其中一個 `Fn` traits 的地方。例如，在 `Option<Vec<T>>` 值上，我們可以呼叫 `unwrap_or_else(Vec::new)`，如果值是 `None`，則會得到一個新的空 vector。compiler 會自動為 function 定義實作適用於哪個 `Fn` trait。

現在讓我們看看標準函式庫中定義在 slices 上的 `sort_by_key` 方法，以了解它與 `unwrap_or_else` 的不同之處，以及為什麼 `sort_by_key` 使用 `FnMut` 而不是 `FnOnce` 作為 trait bound。closure 接收一個參數，形式為對 slice 中目前被考慮的項目的 reference，並返回一個類型為 `K` 的值，該值可以被排序。當你想要根據每個項目的特定 attribute 來排序 slice 時，這個 function 非常有用。在 Listing 13-7 中，我們有一個 `Rectangle` 實例的列表，我們使用 `sort_by_key` 根據它們的 `width` attribute 從低到高排序。

src/main.rs

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    list.sort_by_key(|r| r.width);
    println!("{list:#?}");
}
```

Listing 13-7：使用 `sort_by_key` 根據 `width` 排序矩形

這段程式碼印出：

```
$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.41s
     Running `target/debug/rectangles`
[
    Rectangle {
        width: 3,
        height: 5,
    },
    Rectangle {
        width: 7,
        height: 12,
    },
    Rectangle {
        width: 10,
        height: 1,
    },
]
```

`sort_by_key` 被定義為接受一個 `FnMut` closure 的原因是它會多次呼叫該 closure：對 slice 中的每個項目呼叫一次。closure `|r| r.width` 不會從其環境中捕捉、變更或移出任何東西，因此它符合 trait bound 的要求。

相比之下，Listing 13-8 顯示了一個只實作 `FnOnce` trait 的 closure 範例，因為它會將一個值移出環境。compiler 不允許我們將這個 closure 與 `sort_by_key` 一起使用。

src/main.rs

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    let mut sort_operations = vec![];
    let value = String::from("closure called");

    list.sort_by_key(|r| {
        sort_operations.push(value);
        r.width
    });
    println!("{list:#?}");
}
```

Listing 13-8：嘗試將 `FnOnce` closure 與 `sort_by_key` 一起使用

這是一種牽強附會、複雜的方式（不起作用），試圖在排序 `list` 時計算 `sort_by_key` 呼叫 closure 的次數。這段程式碼嘗試透過將 `value`——一個來自 closure 環境的 `String`——推入 `sort_operations` vector 來執行此計數。closure 捕捉 `value`，然後透過將 `value` 的所有權轉移到 `sort_operations` vector，將 `value` 移出 closure。這個 closure 只能被呼叫一次；嘗試第二次呼叫它將不起作用，因為 `value` 將不再存在於環境中以再次被推入 `sort_operations`！因此，這個 closure 只實作 `FnOnce`。當我們嘗試編譯這段程式碼時，我們得到了這個錯誤，指出 `value` 不能從 closure 中移出，因為 closure 必須實作 `FnMut`：

```
$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
error[E0507]: cannot move out of `value`, a captured variable in an `FnMut` closure
  --> src/main.rs:18:30
   |
15 |     let value = String::from("closure called");
   |         ----- captured outer variable
16 |
17 |     list.sort_by_key(|r| {
   |                      --- captured by this `FnMut` closure
18 |         sort_operations.push(value);
   |                              ^^^^^ move occurs because `value` has type `String`, which does not implement the `Copy` trait
   |
help: consider cloning the value if the performance cost is acceptable
   |
18 |         sort_operations.push(value.clone());
   |                                   ++++++++

For more information about this error, try `rustc --explain E0507`.
error: could not compile `rectangles` (bin "rectangles") due to 1 previous error
```

錯誤指向 closure 主體中將 `value` 移出環境的那一行。為了修復這個問題，我們需要修改 closure 主體，使其不將值移出環境。在環境中保留一個計數器並在 closure 主體中增加其值是一種更直接的計數 closure 被呼叫次數的方法。Listing 13-9 中的 closure 可以與 `sort_by_key` 一起使用，因為它只捕捉了對 `num_sort_operations` 計數器的 mutable reference，因此可以被呼叫多次：

src/main.rs

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    let mut num_sort_operations = 0;
    list.sort_by_key(|r| {
        num_sort_operations += 1;
        r.width
    });
    println!("{list:#?}, sorted in {num_sort_operations} operations");
}
```

Listing 13-9：允許使用 `FnMut` closure 與 `sort_by_key`

`Fn` traits 在定義或使用利用 closures 的 functions 或類型時非常重要。在下一節中，我們將討論 iterators。許多 iterator 方法接受 closure 引數，因此請在我們繼續學習時記住這些 closure 細節！

## 使用 Iterators 處理一系列項目

iterator pattern 允許你依序對一系列項目執行某些任務。iterator 負責迭代每個項目並確定序列何時結束的邏輯。當你使用 iterators 時，你不必自己重新實作該邏輯。

在 Rust 中，iterators 是_惰性的_（lazy），這意味著它們在你呼叫消耗 iterator 的方法以使用它之前不會產生任何效果。例如，Listing 13-10 中的程式碼透過呼叫定義在 `Vec<T>` 上的 `iter` 方法，為 vector `v1` 中的項目建立了一個 iterator。這段程式碼本身沒有做任何有用的事情。

src/main.rs

```rust
    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();
```

Listing 13-10：建立一個 iterator

該 iterator 被儲存在 `v1_iter` 變數中。一旦我們建立了一個 iterator，我們就可以以多種方式使用它。在 Listing 3-5 中，我們使用 `for` 迴圈迭代了一個 array，以對其每個項目執行一些程式碼。在內部，這隱式地建立並消耗了一個 iterator，但我們直到現在才詳細說明它的工作原理。

在 Listing 13-11 的範例中，我們將 iterator 的建立與 `for` 迴圈中 iterator 的使用分開。當使用 `v1_iter` 中的 iterator 呼叫 `for` 迴圈時，iterator 中的每個元素都在迴圈的一次迭代中使用，這會印出每個值。

src/main.rs

```rust
    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();

    for val in v1_iter {
        println!("Got: {val}");
    }
```

Listing 13-11：在 `for` 迴圈中使用 iterator

在那些標準函式庫不提供 iterators 的語言中，你很可能會透過將變數起始索引設為 0，然後使用該變數索引到 vector 中以取得值，並在迴圈中遞增變數值直到它達到 vector 中項目總數來編寫相同的功能。

Iterators 為你處理所有這些邏輯，減少了你可能搞砸的重複程式碼。Iterators 讓你更靈活地將相同的邏輯用於許多不同類型的序列，而不僅僅是你可以用索引存取的資料結構，例如 vectors。讓我們來看看 iterators 是如何做到這一點的。

### Iterator Trait 與 next 方法

所有 iterators 都實作了標準函式庫中定義的一個名為 `Iterator` 的 trait。這個 trait 的定義如下：

```rust
pub trait Iterator {
    type Item;

    fn next(&mut self) -> Option<Self::Item>;

    // methods with default implementations elided
}
```

請注意，這個定義使用了一些新的語法：`type Item` 和 `Self::Item`，它們正在為這個 trait 定義一個_關聯類型_（associated type）。我們將在第 20 章深入討論 associated types。目前，你只需要知道這段程式碼表示實作 `Iterator` trait 要求你同時定義一個 `Item` 類型，並且這個 `Item` 類型用於 `next` 方法的回傳類型。換句話說，`Item` 類型將是從 iterator 返回的類型。

`Iterator` trait 只要求實作方定義一個方法：`next` 方法，它一次返回 iterator 的一個項目，包裝在 `Some` 中，當迭代結束時，返回 `None`。

我們可以直接在 iterators 上呼叫 `next` 方法；Listing 13-12 展示了從 vector 建立的 iterator 上重複呼叫 `next` 所返回的值。

src/lib.rs

```rust
    #[test]
    fn iterator_demonstration() {
        let v1 = vec![1, 2, 3];

        let mut v1_iter = v1.iter();

        assert_eq!(v1_iter.next(), Some(&1));
        assert_eq!(v1_iter.next(), Some(&2));
        assert_eq!(v1_iter.next(), Some(&3));
        assert_eq!(v1_iter.next(), None);
    }
```

Listing 13-12：在 iterator 上呼叫 `next` 方法

請注意，我們需要將 `v1_iter` 設為 mutable：在 iterator 上呼叫 `next` 方法會改變 iterator 用來追蹤其在序列中位置的內部狀態。換句話說，這段程式碼*消耗*或用盡了 iterator。每次呼叫 `next` 都會從 iterator 中消耗一個項目。當我們使用 `for` 迴圈時，我們不需要將 `v1_iter` 設為 mutable，因為迴圈接管了 `v1_iter` 的所有權並在幕後將其設為 mutable。

另請注意，我們從 `next` 呼叫中獲得的值是對 vector 中值的 immutable references。`iter` 方法產生一個基於 immutable references 的 iterator。如果我們想要建立一個取得 `v1` 所有權並返回擁有值的 iterator，我們可以呼叫 `into_iter` 而不是 `iter`。同樣地，如果我們想要迭代 mutable references，我們可以呼叫 `iter_mut` 而不是 `iter`。

### 消耗 Iterator 的方法

`Iterator` trait 有許多不同的方法，並由標準函式庫提供預設實作；你可以透過查閱標準函式庫 `Iterator` trait 的 API documentation 來了解這些方法。其中一些方法在它們的定義中呼叫了 `next` 方法，這就是為什麼在實作 `Iterator` trait 時需要實作 `next` 方法。

呼叫 `next` 的方法稱為_消耗性轉接器_（consuming adapters），因為呼叫它們會用盡 iterator。一個例子是 `sum` 方法，它取得 iterator 的所有權，並透過重複呼叫 `next` 來迭代項目，從而消耗 iterator。當它迭代時，它將每個項目加到一個累計總數中，並在迭代完成時返回總數。Listing 13-13 有一個測試說明了 `sum` 方法的用法。

src/lib.rs

```rust
    #[test]
    fn iterator_sum() {
        let v1 = vec![1, 2, 3];

        let v1_iter = v1.iter();

        let total: i32 = v1_iter.sum();

        assert_eq!(total, 6);
    }
```

Listing 13-13：呼叫 `sum` 方法以取得 iterator 中所有項目的總和

在呼叫 `sum` 之後，我們不允許使用 `v1_iter`，因為 `sum` 取得我們呼叫它的 iterator 的所有權。

### 產生其他 Iterators 的方法

_Iterator adapters_ 是定義在 `Iterator` trait 上的方法，它們不會消耗 iterator。相反，它們透過改變原始 iterator 的某些方面來產生不同的 iterators。

Listing 13-14 顯示了呼叫 iterator adapter 方法 `map` 的範例，該方法接受一個 closure，在項目被迭代時對每個項目呼叫。`map` 方法返回一個新的 iterator，它產生修改後的項目。這裡的 closure 建立了一個新的 iterator，其中 vector 中的每個項目都將遞增 1。

src/main.rs

```rust
    let v1: Vec<i32> = vec![1, 2, 3];

    v1.iter().map(|x| x + 1);
```

Listing 13-14：呼叫 iterator adapter `map` 來建立一個新的 iterator

然而，這段程式碼會產生一個警告：

```
$ cargo run
   Compiling iterators v0.1.0 (file:///projects/iterators)
warning: unused `Map` that must be used
 --> src/main.rs:4:5
  |
4 |     v1.iter().map(|x| x + 1);
  |     ^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: iterators are lazy and do nothing unless consumed
  = note: `#[warn(unused_must_use)]` on by default
help: use `let _ = ...` to ignore the resulting value
  |
4 |     let _ = v1.iter().map(|x| x + 1);
  |     +++++++

warning: `iterators` (bin "iterators") generated 1 warning
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.47s
     Running `target/debug/iterators`
```

Listing 13-14 中的程式碼沒有做任何事情；我們指定的 closure 從未被呼叫。這個警告提醒我們原因：iterator adapters 是惰性的，我們需要在這裡消耗 iterator。

為了解決這個警告並消耗 iterator，我們將使用 `collect` 方法，我們在 Listing 12-1 中與 `env::args` 一起使用了它。這個方法會消耗 iterator 並將結果值收集到 collection data type 中。

在 Listing 13-15 中，我們將呼叫 `map` 返回的 iterator 迭代結果收集到一個 vector 中。這個 vector 最終將包含原始 vector 中的每個項目，並遞增 1。

src/main.rs

```rust
    let v1: Vec<i32> = vec![1, 2, 3];

    let v2: Vec<_> = v1.iter().map(|x| x + 1).collect();

    assert_eq!(v2, vec![2, 3, 4]);
```

Listing 13-15：呼叫 `map` 方法建立一個新的 iterator，然後呼叫 `collect` 方法消耗新的 iterator 並建立一個 vector

因為 `map` 接受一個 closure，我們可以指定我們想要對每個項目執行的任何操作。這是一個很好的範例，說明了 closures 如何讓你自定義某些行為，同時重用 `Iterator` trait 提供的迭代行為。

你可以串聯多次呼叫 iterator adapters，以可讀的方式執行複雜的操作。但由於所有 iterators 都是惰性的，你必須呼叫其中一個消耗性 adapter 方法才能從呼叫 iterator adapters 中獲得結果。

### 使用捕捉其環境的 Closures

許多 iterator adapters 接受 closures 作為引數，通常我們指定給 iterator adapters 的 closures 將是捕捉其環境的 closures。

對於這個範例，我們將使用接受 closure 的 `filter` 方法。這個 closure 從 iterator 中取得一個項目並返回一個 `bool` 值。如果 closure 返回 `true`，該值將包含在由 `filter` 產生的迭代中。如果 closure 返回 `false`，該值將不會被包含。

在 Listing 13-16 中，我們使用 `filter` 和一個捕捉其環境中 `shoe_size` 變數的 closure，來迭代 `Shoe` struct 實例的集合。它將只返回指定大小的鞋子。

src/lib.rs

```rust
#[derive(PartialEq, Debug)]
struct Shoe {
    size: u32,
    style: String,
}

fn shoes_in_size(shoes: Vec<Shoe>, shoe_size: u32) -> Vec<Shoe> {
    shoes.into_iter().filter(|s| s.size == shoe_size).collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn filters_by_size() {
        let shoes = vec![
            Shoe {
                size: 10,
                style: String::from("sneaker"),
            },
            Shoe {
                size: 13,
                style: String::from("sandal"),
            },
            Shoe {
                size: 10,
                style: String::from("boot"),
            },
        ];

        let in_my_size = shoes_in_size(shoes, 10);

        assert_eq!(
            in_my_size,
            vec![
                Shoe {
                    size: 10,
                    style: String::from("sneaker")
                },
                Shoe {
                    size: 10,
                    style: String::from("boot")
                },
            ]
        );
    }
}
```

Listing 13-16：使用 `filter` 方法與捕捉 `shoe_size` 的 closure

`shoes_in_size` function 接受一個鞋子 vector 和一個鞋碼作為參數的所有權。它返回一個只包含指定鞋碼的鞋子的 vector。

在 `shoes_in_size` 的主體中，我們呼叫 `into_iter` 以建立一個取得 vector 所有權的 iterator。然後我們呼叫 `filter` 以將該 iterator 轉接為一個新的 iterator，該 iterator 只包含 closure 返回 `true` 的元素。

這個 closure 從環境中捕捉 `shoe_size` 參數，並將該值與每雙鞋子的尺寸進行比較，只保留指定尺寸的鞋子。最後，呼叫 `collect` 將由轉接後的 iterator 返回的值收集到一個 vector 中，該 vector 由 function 返回。

測試顯示，當我們呼叫 `shoes_in_size` 時，我們只會得到與我們指定的值相同尺寸的鞋子。

## 改進我們的 I/O Project

有了這些關於 iterators 的新知識，我們可以透過使用 iterators 使程式碼更清晰和更簡潔，從而改進第 12 章的 I/O project。讓我們看看 iterators 如何改進我們 `Config::build` function 和 `search` function 的實作。

### 使用 Iterator 移除 clone

在 Listing 12-6 中，我們添加了程式碼，它接受一個 `String` 值的 slice，並透過索引 slice 並複製這些值來建立 `Config` struct 的實例，從而讓 `Config` struct 擁有這些值。在 Listing 13-17 中，我們重現了 `Config::build` function 的實作，它與 Listing 12-23 中的實作相同。

src/main.rs

```rust
impl Config {
    fn build(args: &[String]) -> Result<Config, &'static str> {
        if args.len() < 3 {
            return Err("not enough arguments");
        }

        let query = args[1].clone();
        let file_path = args[2].clone();

        let ignore_case = env::var("IGNORE_CASE").is_ok();

        Ok(Config {
            query,
            file_path,
            ignore_case,
        })
    }
}
```

Listing 13-17：重現 Listing 12-23 中 `Config::build` function 的實作

當時，我們說不必擔心效率低下的 `clone` 呼叫，因為我們將來會將其移除。現在，時候到了！

這裡我們需要 `clone`，因為參數 `args` 中有一個包含 `String` 元素的 slice，但是 `build` function 不擁有 `args`。為了返回 `Config` 實例的所有權，我們必須複製 `Config` 的 `query` 和 `file_path` 欄位中的值，以便 `Config` 實例能夠擁有其值。

有了我們關於 iterators 的新知識，我們可以將 `build` function 更改為將 iterator 的所有權作為其引數，而不是借用一個 slice。我們將使用 iterator 功能，而不是檢查 slice 長度並索引到特定位置的程式碼。這將使 `Config::build` function 所做的事情更清晰，因為 iterator 將存取這些值。

一旦 `Config::build` 取得 iterator 的所有權並停止使用借用的索引操作，我們就可以將 `String` 值從 iterator 移入 `Config`，而不是呼叫 `clone` 並進行新的 allocation。

#### 直接使用返回的 Iterator

開啟你的 I/O project 的 _src/main.rs_ 檔案，它應該如下所示：

Filename: src/main.rs

```rust
fn main() {
    let args: Vec<String> = env::args().collect();

    let config = Config::build(&args).unwrap_or_else(|err| {
        eprintln!("Problem parsing arguments: {err}");
        process::exit(1);
    });

    // --snip--
}
```

我們將首先把 Listing 12-24 中 `main` function 的開頭改為 Listing 13-18 中的程式碼，這次它使用了一個 iterator。這在我們也更新 `Config::build` 之前不會編譯。

src/main.rs

```rust
fn main() {
    let config = Config::build(env::args()).unwrap_or_else(|err| {
        eprintln!("Problem parsing arguments: {err}");
        process::exit(1);
    });

    // --snip--
}
```

Listing 13-18：將 `env::args` 的回傳值傳遞給 `Config::build`

標準函式庫中 `env::args` function 的 documentation 顯示，它返回的 iterator 類型是 `std::env::Args`，並且該類型實作了 `Iterator` trait 並返回 `String` 值。

我們更新了 `Config::build` function 的 signature，這樣參數 `args` 就具有一個 generic type，其 trait bounds 為 `impl Iterator<Item = String>`，而不是 `&[String]`。這種 `impl Trait` 語法的使用，我們在第 10 章的「[將 Traits 作為參數](https://doc.rust-lang.org/book/ch10-02-traits.html#traits-as-parameters)」一節中討論過，表示 `args` 可以是任何實作 `Iterator` trait 並返回 `String` 項目的類型。

因為我們正在取得 `args` 的所有權，並且我們將透過迭代它來變更 `args`，所以我們可以在 `args` 參數的規範中添加 `mut` 關鍵字，使其成為 mutable。

#### 使用 Iterator Trait 方法而非索引

接下來，我們將修復 `Config::build` 的主體。因為 `args` 實作了 `Iterator` trait，我們知道我們可以在它上面呼叫 `next` 方法！Listing 13-20 將 Listing 12-23 的程式碼更新為使用 `next` 方法。

src/main.rs

```rust
impl Config {
    fn build(
        mut args: impl Iterator<Item = String>,
    ) -> Result<Config, &'static str> {
        args.next();

        let query = match args.next() {
            Some(arg) => arg,
            None => return Err("Didn't get a query string"),
        };

        let file_path = match args.next() {
            Some(arg) => arg,
            None => return Err("Didn't get a file path"),
        };

        let ignore_case = env::var("IGNORE_CASE").is_ok();

        Ok(Config {
            query,
            file_path,
            ignore_case,
        })
    }
}
```

Listing 13-20：更改 `Config::build` 的主體以使用 iterator 方法

請記住，`env::args` 回傳值中的第一個值是程式的名稱。我們想要忽略它並取得下一個值，所以我們首先呼叫 `next` 並且不處理回傳值。然後我們呼叫 `next` 來取得我們想要放入 `Config` 的 `query` 欄位中的值。如果 `next` 回傳 `Some`，我們使用 `match` 來提取值。如果它回傳 `None`，則表示提供的引數不足，我們將提前返回 `Err` 值。我們對 `file_path` 值也執行相同的操作。

### 使用 Iterator Adapters 使程式碼更清晰

我們也可以在 I/O project 中的 `search` function 中利用 iterators，這裡重現了 Listing 13-21，它與 Listing 12-19 中的版本相同。

src/lib.rs

```rust
pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.contains(query) {
            results.push(line);
        }
    }

    results
}
```

Listing 13-21：Listing 12-19 中 `search` function 的實作

我們可以利用 iterator adapter 方法以更簡潔的方式編寫這段程式碼。這樣做也讓我們避免擁有一個 mutable 的中間 `results` vector。functional programming 風格偏好將 mutable state 的數量降到最低，以使程式碼更清晰。移除 mutable state 可能會促成未來增強功能，使搜尋能夠 parallel 執行，因為我們將不必管理對 `results` vector 的 concurrent access。Listing 13-22 顯示了此更改。

src/lib.rs

```rust
pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
    contents
        .lines()
        .filter(|line| line.contains(query))
        .collect()
}
```

Listing 13-22：在 `search` function 的實作中使用 iterator adapter 方法

回想一下，`search` function 的目的是返回 `contents` 中包含 `query` 的所有行。類似於 Listing 13-16 中的 `filter` 範例，這段程式碼使用 `filter` adapter 只保留 `line.contains(query)` 返回 `true` 的行。然後我們使用 `collect` 將匹配的行收集到另一個 vector 中。簡單得多！你也可以隨意對 `search_case_insensitive` function 進行相同的更改以使用 iterator 方法。

為了進一步改進，從 `search` function 返回一個 iterator，方法是移除對 `collect` 的呼叫，並將回傳類型更改為 `impl Iterator<Item = &'a str>`，這樣 function 就會成為一個 iterator adapter。請注意，你還需要更新測試！在進行此更改之前和之後，使用你的 `minigrep` 工具搜尋一個大檔案，以觀察行為差異。在此更改之前，程式將不會印出任何結果，直到它收集了所有結果，但在更改之後，結果將在找到每條匹配行時印出，因為 `run` function 中的 `for` 迴圈能夠利用 iterator 的惰性。

<!-- Old heading. Do not remove or links may break. -->

<a id="choosing-between-loops-or-iterators"></a>

### 在迴圈與 Iterators 之間做選擇

下一個合乎邏輯的問題是，在你的程式碼中應該選擇哪種風格以及原因：Listing 13-21 中的原始實作，還是 Listing 13-22 中使用 iterators 的版本（假設我們在返回結果之前收集所有結果，而不是直接返回 iterator）。大多數 Rust 程式設計師更喜歡使用 iterator 風格。一開始可能有點難掌握，但一旦你熟悉了各種 iterator adapters 及其功能，iterators 就會更容易理解。程式碼不再是處理各種迴圈和建立新 vectors 的細節，而是專注於迴圈的高層次目標。這將一些常見的程式碼抽象化，因此更容易看到此程式碼獨特的 concept，例如 iterator 中每個元素必須通過的 filtering 條件。

但這兩種實作真的等效嗎？直觀的假設可能是低層次的迴圈會更快。讓我們來談談 performance。

## 比較 Performance：迴圈與 Iterators

為了決定是使用迴圈還是 iterators，你需要知道哪種實作更快：使用顯式 `for` 迴圈的 `search` function 版本，還是使用 iterators 的版本。

我們透過將 Sir Arthur Conan Doyle 的 _The Adventures of Sherlock Holmes_ 的全部內容載入到一個 `String` 中，並在內容中尋找單字 _the_ 來運行了一項基準測試。以下是使用 `for` 迴圈的 `search` 版本和使用 iterators 的版本的基準測試結果：

```
test bench_search_for  ... bench:  19,620,300 ns/iter (+/- 915,700)
test bench_search_iter ... bench:  19,234,900 ns/iter (+/- 657,200)
```

這兩種實作具有相似的 performance！我們在這裡不解釋基準測試程式碼，因為重點不是證明這兩個版本是等效的，而是為了大致了解這兩種實作在 performance 方面的比較。

對於更全面的基準測試，你應該使用各種大小的文本作為 `contents`，不同的單字和不同長度的單字作為 `query`，以及各種其他變體進行檢查。重點是：iterators 儘管是一種高層次的 abstraction，但它們被編譯成大致相同的程式碼，就好像你自己手寫了低層次程式碼一樣。Iterators 是 Rust 的_零成本抽象_（zero-cost abstractions）之一，我們的意思是，使用這種 abstraction 不會產生額外的 runtime overhead。這與 C++ 的原始設計者和實作者 Bjarne Stroustrup 在《Foundations of C++》（2012）中定義_零開銷_（zero-overhead）的方式類似：

> 總體而言，C++ 實作遵守零開銷原則：你沒有使用的，你無需支付。更進一步：你所使用的，你無法手寫出更好的程式碼。

在許多情況下，使用 iterators 的 Rust 程式碼會編譯成你手寫的相同組合語言。諸如 loop unrolling 和消除 array 存取時的 bounds checking 等 optimization 都適用，並使產生的程式碼極其高效。現在你知道了這一點，你可以放心地使用 iterators 和 closures！它們使程式碼看起來更高級，但不會因此產生 runtime performance 上的損失。

## 總結

Closures 和 iterators 是受 functional programming 語言思想啟發的 Rust 功能。它們有助於 Rust 以低層次 performance 清晰表達高層次概念的能力。closures 和 iterators 的實作使得 runtime performance 不受影響。這是 Rust 努力提供 zero-cost abstractions 的目標之一。

現在我們已經改進了 I/O project 的表達性，讓我們看看 `cargo` 的更多功能，這將幫助我們將 project 與世界分享。
