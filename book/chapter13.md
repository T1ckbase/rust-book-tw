<!-- DO NOT EDIT THIS FILE.

This file is periodically generated from the content in the `/src/`
directory, so all fixes need to be made in `/src/`.
-->

[TOC]

# 函式語言程式設計功能：迭代器與閉包

Rust 的設計靈感來自許多現有的語言和技術，其中一個重要的影響是_函式程式設計 (functional programming)_。函式風格的程式設計通常包括將函式作為值使用，例如將它們傳入參數、從其他函式中回傳、將它們賦值給變數以供稍後執行等等。

在本章中，我們不會爭論什麼是或不是函式程式設計，而是會討論 Rust 的一些功能，這些功能與許多通常被稱為函式語言的功能相似。

更具體地說，我們將涵蓋：

- _閉包 (Closures)_，一種可以儲存在變數中的類函式建構
- _迭代器 (Iterators)_，一種處理一系列元素的方式
- 如何使用閉包和迭代器來改進第 12 章的 I/O 專案
- 閉包和迭代器的效能（劇透：它們比你想像的要快！）

我們已經涵蓋了 Rust 的其他一些功能，例如模式匹配 (pattern matching) 和 `enum`，它們也受到函式風格的影響。由於掌握閉包和迭代器是編寫慣用、快速的 Rust 程式碼的重要部分，我們將用整整一章來討論它們。

<!-- Old heading. Do not remove or links may break. -->

<a id="closures-anonymous-functions-that-can-capture-their-environment"></a>

## 閉包：能捕捉其環境的匿名函式

Rust 的閉包是匿名函式，你可以將它們儲存在變數中或作為參數傳遞給其他函式。你可以在一個地方建立閉包，然後在其他地方呼叫它，以在不同的上下文中對其進行求值。與函式不同，閉包可以從它們被定義的作用域中捕捉值。我們將展示這些閉包功能如何實現程式碼重用和行為自訂。

<!-- Old headings. Do not remove or links may break. -->

<a id="creating-an-abstraction-of-behavior-with-closures"></a>
<a id="refactoring-using-functions"></a>
<a id="refactoring-with-closures-to-store-code"></a>

### 使用閉包捕捉環境

我們將首先研究如何使用閉包來捕捉它們被定義的環境中的值，以供稍後使用。情境如下：我們的 T 恤公司每隔一段時間會向郵件列表中的某個人贈送一件獨家限量版 T 恤作為促銷活動。郵件列表中的人可以選擇性地將他們最喜歡的顏色添加到他們的個人資料中。如果被選中獲得免費 T 恤的人設定了他們最喜歡的顏色，他們就會得到該顏色的 T 恤。如果這個人沒有指定最喜歡的顏色，他們會得到公司目前庫存最多的顏色。

有很多方法可以實現這一點。在這個例子中，我們將使用一個名為 `ShirtColor` 的 `enum`，它有 `Red` 和 `Blue` 兩個變體（為了簡單起見，限制了可用顏色的數量）。我們用一個 `Inventory` 結構體來表示公司的庫存，該結構體有一個名為 `shirts` 的欄位，其中包含一個 `Vec<ShirtColor>`，表示目前庫存中的 T 恤顏色。在 `Inventory` 上定義的 `giveaway` 方法會獲取免費 T 恤中獎者可選的襯衫顏色偏好，並回傳該人將獲得的襯衫顏色。這個設定如列表 13-1 所示。

src/main.rs

```rust
#[derive(Debug, PartialEq, Copy, Clone)]
enum ShirtColor {
    Red,
    Blue,
}

struct Inventory {
    shirts: Vec<ShirtColor>,
}

impl Inventory {
    fn giveaway(&self, user_preference: Option<ShirtColor>) -> ShirtColor {
        user_preference.unwrap_or_else(|| self.most_stocked())
    }

    fn most_stocked(&self) -> ShirtColor {
        let mut num_red = 0;
        let mut num_blue = 0;

        for color in &self.shirts {
            match color {
                ShirtColor::Red => num_red += 1,
                ShirtColor::Blue => num_blue += 1,
            }
        }
        if num_red > num_blue {
            ShirtColor::Red
        } else {
            ShirtColor::Blue
        }
    }
}

fn main() {
    let store = Inventory {
        shirts: vec![ShirtColor::Blue, ShirtColor::Red, ShirtColor::Blue],
    };

    let user_pref1 = Some(ShirtColor::Red);
    let giveaway1 = store.giveaway(user_pref1);
    println!(
        "The user with preference {:?} gets {:?}",
        user_pref1, giveaway1
    );

    let user_pref2 = None;
    let giveaway2 = store.giveaway(user_pref2);
    println!(
        "The user with preference {:?} gets {:?}",
        user_pref2, giveaway2
    );
}
```

列表 13-1：T 恤公司贈品活動情境

在 `main` 中定義的 `store` 還有兩件藍色 T 恤和一件紅色 T 恤可供這次限量版促銷活動分發。我們為一個偏好紅色 T 恤的使用者和一個沒有任何偏好的使用者呼叫 `giveaway` 方法。

再次強調，這段程式碼可以用許多方式實現，而在這裡，為了專注於閉包，我們堅持使用你已經學過的概念，除了 `giveaway` 方法的主體使用了一個閉包。在 `giveaway` 方法中，我們將使用者偏好作為 `Option<ShirtColor>` 型別的參數，並在 `user_preference` 上呼叫 `unwrap_or_else` 方法。`Option<T>` 上的 `unwrap_or_else` 方法是由標準函式庫定義的。它接受一個參數：一個沒有任何參數且回傳值 `T`（與儲存在 `Option<T>` 的 `Some` 變體中的型別相同，在這裡是 `ShirtColor`）的閉包。如果 `Option<T>` 是 `Some` 變體，`unwrap_or_else` 會回傳 `Some` 內部的值。如果 `Option<T>` 是 `None` 變體，`unwrap_or_else` 會呼叫閉包並回傳閉包回傳的值。

我們將閉包運算式 `|| self.most_stocked()` 指定為 `unwrap_or_else` 的參數。這是一個不接受任何參數的閉包（如果閉包有參數，它們會出現在兩個垂直管道符號之間）。閉包的主體呼叫 `self.most_stocked()`。我們在這裡定義閉包，如果需要結果，`unwrap_or_else` 的實作稍後會對閉包進行求值。

執行這段程式碼會印出：

```
$ cargo run
   Compiling shirt-company v0.1.0 (file:///projects/shirt-company)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.27s
     Running `target/debug/shirt-company`
The user with preference Some(Red) gets Red
The user with preference None gets Blue
```

這裡一個有趣的方面是，我們傳遞了一個在當前 `Inventory` 實例上呼叫 `self.most_stocked()` 的閉包。標準函式庫不需要知道任何關於我們定義的 `Inventory` 或 `ShirtColor` 型別，也不需要知道我們在這種情況下想要使用的邏輯。閉包捕捉了對 `self` `Inventory` 實例的不可變引用，並將其與我們指定的程式碼一起傳遞給 `unwrap_or_else` 方法。另一方面，函式無法以這種方式捕捉它們的環境。

### 閉包的型別推斷與註記

函式和閉包之間還有更多的區別。閉包通常不需要像 `fn` 函式那樣註記參數或回傳值的型別。函式需要型別註記，因為型別是向使用者公開的明確介面的一部分。嚴格定義這個介面對於確保每個人都同意函式使用和回傳的值的型別非常重要。另一方面，閉包不像這樣用在公開的介面中：它們儲存在變數中，使用時不命名，也不會向我們函式庫的使用者公開。

閉包通常很短，且只在狹窄的上下文中相關，而不是在任何任意情境中。在這些有限的上下文中，編譯器可以推斷參數的型別和回傳型別，類似於它能夠推斷大多數變數的型別（在極少數情況下，編譯器也需要閉包的型別註記）。

與變數一樣，如果我們想增加明確性和清晰度，可以添加型別註記，但代價是比絕對必要的更冗長。為閉包註記型別看起來像列表 13-2 中顯示的定義。在這個例子中，我們定義了一個閉包並將其儲存在一個變數中，而不是像在列表 13-1 中那樣，在將其作為參數傳遞的地方定義閉包。

src/main.rs

```rust
let expensive_closure = |num: u32| -> u32 {
    println!("calculating slowly...");
    thread::sleep(Duration::from_secs(2));
    num
};
```

列表 13-2：在閉包中添加可選的參數和回傳值型別註記

加上型別註記後，閉包的語法看起來更像函式的語法。在這裡，我們定義一個將其參數加 1 的函式，以及一個具有相同行為的閉包，以供比較。我們添加了一些空格以對齊相關部分。這說明了閉包語法與函式語法相似，除了使用管道符號和可選語法的數量：

```rust
fn  add_one_v1   (x: u32) -> u32 { x + 1 }
let add_one_v2 = |x: u32| -> u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;
```

第一行顯示了一個函式定義，第二行顯示了一個完全註記的閉包定義。在第三行，我們從閉包定義中移除了型別註記。在第四行，我們移除了大括號，因為閉包主體只有一個運算式，所以這是可選的。這些都是有效的定義，在被呼叫時會產生相同的行為。`add_one_v3` 和 `add_one_v4` 這兩行需要對閉包進行求值才能編譯，因為型別將從它們的用法中推斷出來。這類似於 `let v = Vec::new();` 需要型別註記或將某種類型的值插入到 `Vec` 中，Rust 才能推斷出型別。

對於閉包定義，編譯器會為它們的每個參數和回傳值推斷一個具體的型別。例如，列表 13-3 顯示了一個簡短閉包的定義，它只回傳它作為參數接收到的值。除了這個例子的目的之外，這個閉包並不是很實用。請注意，我們沒有在定義中添加任何型別註記。因為沒有型別註記，我們可以用任何型別來呼叫閉包，我們在這裡第一次用 `String` 來呼叫。如果我們接著嘗試用一個整數來呼叫 `example_closure`，我們會得到一個錯誤。

src/main.rs

```rust
    let example_closure = |x| x;

    let s = example_closure(String::from("hello"));
    let n = example_closure(5);
```

列表 13-3：嘗試用兩種不同型別呼叫一個型別被推斷的閉包

編譯器給我們這個錯誤：

```
$ cargo run
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
error[E0308]: mismatched types
 --> src/main.rs:5:29
  |
5 |     let n = example_closure(5);
  |             --------------- ^- help: try using a conversion method: `.to_string()`
  |             |               |
  |             |               expected `String`, found integer
  |             arguments to this function are incorrect
  |
note: expected because the closure was earlier called with an argument of type `String`
 --> src/main.rs:4:29
  |
4 |     let s = example_closure(String::from("hello"));
  |             --------------- ^^^^^^^^^^^^^^^^^^^^^ expected because this argument is of type `String`
  |             |
  |             in this closure call
note: closure parameter defined here
 --> src/main.rs:2:28
  |
2 |     let example_closure = |x| x;
  |                            ^

For more information about this error, try `rustc --explain E0308`.
error: could not compile `closure-example` (bin "closure-example") due to 1 previous error
```

我們第一次用 `String` 值呼叫 `example_closure` 時，編譯器推斷 `x` 的型別和閉包的回傳型別為 `String`。這些型別隨後被鎖定在 `example_closure` 的閉包中，當我們下次嘗試用不同型別與同一個閉包一起使用時，就會得到一個型別錯誤。

### 捕捉引用或移動所有權

閉包可以通過三種方式從其環境中捕捉值，這三種方式直接對應函式接受參數的三種方式：不可變地借用 (borrowing immutably)、可變地借用 (borrowing mutably)，以及取得所有權 (taking ownership)。閉包將根據函式主體對捕捉到的值的操作來決定使用哪一種。

在列表 13-4 中，我們定義了一個閉包，它捕捉了對名為 `list` 的 vector 的不可變引用，因為它只需要一個不可變引用來印出值。

src/main.rs

```rust
fn main() {
    let list = vec![1, 2, 3];
    println!("Before defining closure: {list:?}");

    let only_borrows = || println!("From closure: {list:?}");

    println!("Before calling closure: {list:?}");
    only_borrows();
    println!("After calling closure: {list:?}");
}
```

列表 13-4：定義並呼叫一個捕捉不可變引用的閉包

這個例子也說明了一個變數可以綁定到一個閉包定義，我們之後可以使用變數名稱和括號來呼叫閉包，就好像變數名稱是一個函式名稱一樣。

因為我們可以同時擁有多個對 `list` 的不可變引用，所以在閉包定義之前、閉包定義之後但在閉包被呼叫之前，以及閉包被呼叫之後，`list` 仍然可以從程式碼中存取。這段程式碼可以編譯、執行並印出：

```
$ cargo run
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/closure-example`
Before defining closure: [1, 2, 3]
Before calling closure: [1, 2, 3]
From closure: [1, 2, 3]
After calling closure: [1, 2, 3]
```

接下來，在列表 13-5 中，我們更改閉包主體，使其向 `list` vector 中添加一個元素。閉包現在捕捉一個可變引用。

src/main.rs

```rust
fn main() {
    let mut list = vec![1, 2, 3];
    println!("Before defining closure: {list:?}");

    let mut borrows_mutably = || list.push(7);

    borrows_mutably();
    println!("After calling closure: {list:?}");
}
```

列表 13-5：定義並呼叫一個捕捉可變引用的閉包

這段程式碼可以編譯、執行並印出：

```
$ cargo run
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/closure-example`
Before defining closure: [1, 2, 3]
After calling closure: [1, 2, 3, 7]
```

請注意，在 `borrows_mutably` 閉包的定義和呼叫之間不再有 `println!`：當 `borrows_mutably` 被定義時，它捕捉了對 `list` 的可變引用。在閉包被呼叫之後，我們不再使用這個閉包，所以可變借用結束。在閉包定義和閉包呼叫之間，不允許使用不可變借用來印出，因為當存在可變借用時，不允許有其他借用。試著在那裡添加一個 `println!`，看看你會得到什麼錯誤訊息！

如果你想強制閉包取得它在環境中使用的值的所有權，即使閉包的主體嚴格來說並不需要所有權，你可以在參數列表前使用 `move` 關鍵字。

這個技巧主要在將閉包傳遞給新執行緒時很有用，以便移動資料，使其由新執行緒擁有。我們將在第 16 章討論並行性時詳細討論執行緒以及為什麼你會想使用它們，但現在，讓我們簡要地探討一下如何使用一個需要 `move` 關鍵字的閉包來產生一個新執行緒。列表 13-6 顯示了修改後的列表 13-4，它在一個新執行緒中印出 vector，而不是在主執行緒中。

src/main.rs

```rust
use std::thread;

fn main() {
    let list = vec![1, 2, 3];
    println!("Before defining closure: {list:?}");

    thread::spawn(move || println!("From thread: {list:?}"))
        .join()
        .unwrap();
}
```

列表 13-6：使用 `move` 強制執行緒的閉包取得 `list` 的所有權

我們產生一個新執行緒，給這個執行緒一個閉包作為參數來執行。閉包的主體會印出這個列表。在列表 13-4 中，閉包只用不可變引用捕捉了 `list`，因為這是印出 `list` 所需的最小存取權限。在這個例子中，即使閉包主體仍然只需要一個不可變引用，我們也需要透過在閉包定義的開頭加上 `move` 關鍵字來指定 `list` 應該被移動到閉包中。如果主執行緒在呼叫新執行緒的 `join` 之前執行了更多操作，新執行緒可能會在主執行緒的其餘部分完成之前完成，或者主執行緒可能會先完成。如果主執行緒保留了 `list` 的所有權，但在新執行緒結束之前結束並 `drop` 了 `list`，那麼執行緒中的不可變引用就會失效。因此，編譯器要求將 `list` 移動到給新執行緒的閉包中，這樣引用才會有效。試著移除 `move` 關鍵字，或者在閉包定義後在主執行緒中使用 `list`，看看你會得到什麼編譯錯誤！

<!-- Old headings. Do not remove or links may break. -->

<a id="storing-closures-using-generic-parameters-and-the-fn-traits"></a>
<a id="limitations-of-the-cacher-implementation"></a>
<a id="moving-captured-values-out-of-the-closure-and-the-fn-traits"></a>

### 將捕捉的值移出閉包與 Fn Trait

一旦閉包從其定義的環境中捕捉了一個引用或一個值的所有權（這會影響什麼東西，如果有的話，被移動*到*閉包中），閉包主體中的程式碼就定義了當閉包稍後被求值時，這些引用或值會發生什麼（這會影響什麼東西，如果有的話，被移動*出*閉包）。

閉包主體可以做以下任何一件事：將捕捉的值移出閉包、改變捕捉的值、既不移動也不改變值，或者一開始就沒有從環境中捕捉任何東西。

閉包捕捉和處理來自環境的值的方式，會影響閉包實作了哪些 trait，而 trait 則是函式和結構體用來指定它們可以使用哪種閉包的方式。閉包會根據其主體如何處理值，以一種累加的方式自動實作這三個 `Fn` trait 中的一個、兩個或全部：

- `FnOnce` 適用於可以被呼叫一次的閉包。所有閉包都至少實作了這個 trait，因為所有閉包都可以被呼叫。一個將捕捉的值移出其主體的閉包只會實作 `FnOnce`，而不會實作其他 `Fn` trait，因為它只能被呼叫一次。
- `FnMut` 適用於不將捕捉的值移出其主體，但可能會改變捕捉值的閉包。這些閉包可以被呼叫多次。
- `Fn` 適用於不將捕捉的值移出其主體，且不改變捕捉值的閉包，以及那些沒有從環境中捕捉任何東西的閉包。這些閉包可以被呼叫多次而不會改變它們的環境，這在像是並行地多次呼叫一個閉包的情況下很重要。

讓我們看看我們在列表 13-1 中使用的 `Option<T>` 上的 `unwrap_or_else` 方法的定義：

```rust
impl<T> Option<T> {
    pub fn unwrap_or_else<F>(self, f: F) -> T
    where
        F: FnOnce() -> T
    {
        match self {
            Some(x) => x,
            None => f(),
        }
    }
}
```

回想一下，`T` 是泛型型別，代表 `Option` 的 `Some` 變體中值的型別。該型別 `T` 也是 `unwrap_or_else` 函式的回傳型別：例如，在 `Option<String>` 上呼叫 `unwrap_or_else` 的程式碼將會得到一個 `String`。

接下來，請注意 `unwrap_or_else` 函式有一個額外的泛型型別參數 `F`。`F` 型別是名為 `f` 的參數的型別，也就是我們在呼叫 `unwrap_or_else` 時提供的閉包。

在泛型型別 `F` 上指定的 trait bound 是 `FnOnce() -> T`，這表示 `F` 必須能夠被呼叫一次，不接受任何參數，並回傳一個 `T`。在 trait bound 中使用 `FnOnce` 表達了 `unwrap_or_else` 最多只會呼叫 `f` 一次的約束。在 `unwrap_or_else` 的主體中，我們可以看到如果 `Option` 是 `Some`，`f` 將不會被呼叫。如果 `Option` 是 `None`，`f` 將被呼叫一次。因為所有閉包都實作了 `FnOnce`，所以 `unwrap_or_else` 接受所有三種類型的閉包，並且盡可能地靈活。

> 注意：如果我們要做的事情不需要從環境中捕捉值，我們可以使用函式名稱而不是閉包，在需要實作 `Fn` trait 之一的地方。例如，對於一個 `Option<Vec<T>>` 值，我們可以呼叫 `unwrap_or_else(Vec::new)` 來在值為 `None` 時獲得一個新的空 vector。編譯器會自動為函式定義實作任何適用的 `Fn` trait。

現在讓我們來看看標準函式庫中定義在 slice 上的 `sort_by_key` 方法，看看它與 `unwrap_or_else` 有何不同，以及為什麼 `sort_by_key` 使用 `FnMut` 而不是 `FnOnce` 作為 trait bound。閉包會得到一個參數，形式是正在考慮的 slice 中當前項目的引用，並回傳一個可排序的 `K` 型別的值。當你想要根據每個項目的特定屬性對 slice 進行排序時，這個函式很有用。在列表 13-7 中，我們有一個 `Rectangle` 實例的列表，我們使用 `sort_by_key` 根據它們的 `width` 屬性從低到高排序。

src/main.rs

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    list.sort_by_key(|r| r.width);
    println!("{list:#?}");
}
```

列表 13-7：使用 `sort_by_key` 依寬度排序矩形

這段程式碼會印出：

```
$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.41s
     Running `target/debug/rectangles`
[
    Rectangle {
        width: 3,
        height: 5,
    },
    Rectangle {
        width: 7,
        height: 12,
    },
    Rectangle {
        width: 10,
        height: 1,
    },
]
```

`sort_by_key` 之所以被定義為接受一個 `FnMut` 閉包，是因為它會多次呼叫該閉包：對 slice 中的每個項目呼叫一次。閉包 `|r| r.width` 不會從其環境中捕捉、改變或移動任何東西，因此它符合 trait bound 的要求。

相比之下，列表 13-8 展示了一個只實作 `FnOnce` trait 的閉包範例，因為它從環境中移出了一個值。編譯器不允許我們將這個閉包與 `sort_by_key` 一起使用。

src/main.rs

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    let mut sort_operations = vec![];
    let value = String::from("closure called");

    list.sort_by_key(|r| {
        sort_operations.push(value);
        r.width
    });
    println!("{list:#?}");
}
```

列表 13-8：嘗試將 `FnOnce` 閉包與 `sort_by_key` 一起使用

這是一種（行不通的）刻意且複雜的方式，試圖計算 `sort_by_key` 在排序 `list` 時呼叫閉包的次數。這段程式碼試圖通過將 `value`——一個來自閉包環境的 `String`——推入 `sort_operations` vector 來進行計數。閉包捕捉了 `value`，然後通過將 `value` 的所有權轉移給 `sort_operations` vector，將 `value` 移出閉包。這個閉包可以被呼叫一次；嘗試第二次呼叫它將行不通，因為 `value` 將不再在環境中，無法再次被推入 `sort_operations`！因此，這個閉包只實作了 `FnOnce`。當我們試圖編譯這段程式碼時，我們會得到這個錯誤，說 `value` 不能被移出閉包，因為閉包必須實作 `FnMut`：

```
$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
error[E0507]: cannot move out of `value`, a captured variable in an `FnMut` closure
  --> src/main.rs:18:30
   |
15 |     let value = String::from("closure called");
   |         ----- captured outer variable
16 |
17 |     list.sort_by_key(|r| {
   |                      --- captured by this `FnMut` closure
18 |         sort_operations.push(value);
   |                              ^^^^^ move occurs because `value` has type `String`, which does not implement the `Copy` trait
   |
help: consider cloning the value if the performance cost is acceptable
   |
18 |         sort_operations.push(value.clone());
   |                                   ++++++++

For more information about this error, try `rustc --explain E0507`.
error: could not compile `rectangles` (bin "rectangles") due to 1 previous error
```

錯誤指向閉包主體中將 `value` 移出環境的那一行。要修正這個問題，我們需要更改閉包主體，使其不將值移出環境。在環境中保留一個計數器，並在閉包主體中增加其值，是計算閉包被呼叫次數的更直接方法。列表 13-9 中的閉包可以與 `sort_by_key` 一起使用，因為它只捕捉了對 `num_sort_operations` 計數器的可變引用，因此可以被呼叫多次：

src/main.rs

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    let mut num_sort_operations = 0;
    list.sort_by_key(|r| {
        num_sort_operations += 1;
        r.width
    });
    println!("{list:#?}, sorted in {num_sort_operations} operations");
}
```

列表 13-9：允許將 `FnMut` 閉包與 `sort_by_key` 一起使用

在定義或使用利用閉包的函式或型別時，`Fn` trait 非常重要。在下一節中，我們將討論迭代器。許多迭代器方法都接受閉包參數，所以在我們繼續的時候，請記住這些關於閉包的細節！

## 使用迭代器處理一系列項目

迭代器模式允許你依序對一個序列的項目執行某些任務。迭代器負責遍歷每個項目的邏輯，並確定序列何時結束。當你使用迭代器時，你不必自己重新實作那個邏輯。

在 Rust 中，迭代器是_惰性的 (lazy)_，這意味著在你呼叫消耗迭代器的方法來用完它之前，它們沒有任何效果。例如，列表 13-10 中的程式碼透過呼叫在 `Vec<T>` 上定義的 `iter` 方法，為 vector `v1` 中的項目建立了一個迭代器。這段程式碼本身並不會做任何有用的事情。

src/main.rs

```rust
    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();
```

列表 13-10：建立一個迭代器

迭代器儲存在 `v1_iter` 變數中。一旦我們建立了一個迭代器，我們可以用各種方式使用它。在列表 3-5 中，我們使用 `for` 迴圈遍歷一個陣列，以便對其每個項目執行一些程式碼。在底層，這隱式地建立並消耗了一個迭代器，但直到現在我們都忽略了這究竟是如何運作的。

在列表 13-11 的例子中，我們將迭代器的建立與在 `for` 迴圈中使用迭代器分開。當使用 `v1_iter` 中的迭代器呼叫 `for` 迴圈時，迭代器中的每個元素都會在迴圈的一次迭代中使用，這會印出每個值。

src/main.rs

```rust
    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();

    for val in v1_iter {
        println!("Got: {val}");
    }
```

列表 13-11：在 `for` 迴圈中使用迭代器

在那些標準函式庫不提供迭代器的語言中，你可能會這樣寫相同的功能：從索引 0 開始一個變數，使用該變數來索引 vector 以獲取值，並在迴圈中遞增變數值，直到它達到 vector 中的項目總數。

迭代器為你處理了所有這些邏輯，減少了你可能搞砸的重複性程式碼。迭代器讓你更有彈性地將相同的邏輯應用於許多不同種類的序列，而不僅僅是像 vector 這樣可以索引的資料結構。讓我們來看看迭代器是如何做到這一點的。

### Iterator Trait 與 next 方法

所有迭代器都實作了一個名為 `Iterator` 的 trait，它在標準函式庫中定義。該 trait 的定義如下：

```rust
pub trait Iterator {
    type Item;

    fn next(&mut self) -> Option<Self::Item>;

    // methods with default implementations elided
}
```

請注意，這個定義使用了一些新的語法：`type Item` 和 `Self::Item`，它們正在為這個 trait 定義一個_關聯型別 (associated type)_。我們將在第 20 章深入討論關聯型別。現在，你只需要知道這段程式碼表示實作 `Iterator` trait 需要你同時定義一個 `Item` 型別，而這個 `Item` 型別被用在 `next` 方法的回傳型別中。換句話說，`Item` 型別將是從迭代器回傳的型別。

`Iterator` trait 只要求實作者定義一個方法：`next` 方法，它一次回傳迭代器的一個項目，包裹在 `Some` 中，當迭代結束時，回傳 `None`。

我們可以直接在迭代器上呼叫 `next` 方法；列表 13-12 展示了從 vector 建立的迭代器重複呼叫 `next` 所回傳的值。

src/lib.rs

```rust
    #[test]
    fn iterator_demonstration() {
        let v1 = vec![1, 2, 3];

        let mut v1_iter = v1.iter();

        assert_eq!(v1_iter.next(), Some(&1));
        assert_eq!(v1_iter.next(), Some(&2));
        assert_eq!(v1_iter.next(), Some(&3));
        assert_eq!(v1_iter.next(), None);
    }
```

列表 13-12：在迭代器上呼叫 `next` 方法

請注意，我們需要讓 `v1_iter` 變成可變的：在迭代器上呼叫 `next` 方法會改變迭代器用來追蹤其在序列中位置的內部狀態。換句話說，這段程式碼*消耗 (consumes)*或用盡了迭代器。每次呼叫 `next` 都會消耗掉迭代器中的一個項目。當我們使用 `for` 迴圈時，我們不需要讓 `v1_iter` 變成可變的，因為迴圈取得了 `v1_iter` 的所有權並在幕後使其變成可變的。

另外請注意，我們從 `next` 呼叫中得到的值是對 vector 中值的不可變引用。`iter` 方法產生一個遍歷不可變引用的迭代器。如果我們想建立一個取得 `v1` 所有權並回傳擁有值的迭代器，我們可以呼叫 `into_iter` 而不是 `iter`。同樣地，如果我們想遍歷可變引用，我們可以呼叫 `iter_mut` 而不是 `iter`。

### 消耗迭代器的方法

`Iterator` trait 有許多不同的方法，標準函式庫提供了它們的預設實作；你可以透過查閱標準函式庫 API 文件中關於 `Iterator` trait 的部分來了解這些方法。其中一些方法在它們的定義中呼叫了 `next` 方法，這就是為什麼在實作 `Iterator` trait 時需要實作 `next` 方法的原因。

呼叫 `next` 的方法被稱為_消耗性配接器 (consuming adapters)_，因為呼叫它們會用盡迭代器。一個例子是 `sum` 方法，它會取得迭代器的所有權，並通過重複呼叫 `next` 來遍歷項目，從而消耗掉迭代器。在遍歷過程中，它會將每個項目加到一個執行中的總和中，並在迭代完成時回傳總和。列表 13-13 有一個測試，說明了 `sum` 方法的用法。

src/lib.rs

```rust
    #[test]
    fn iterator_sum() {
        let v1 = vec![1, 2, 3];

        let v1_iter = v1.iter();

        let total: i32 = v1_iter.sum();

        assert_eq!(total, 6);
    }
```

列表 13-13：呼叫 `sum` 方法以獲取迭代器中所有項目的總和

在呼叫 `sum` 之後，我們不被允許使用 `v1_iter`，因為 `sum` 會取得我們在其上呼叫的迭代器的所有權。

### 產生其他迭代器的方法

_迭代器配接器 (Iterator adapters)_ 是定義在 `Iterator` trait 上的方法，它們不會消耗迭代器。相反，它們通過改變原始迭代器的某些方面來產生不同的迭代器。

列表 13-14 展示了一個呼叫迭代器配接器方法 `map` 的例子，它接受一個閉包，在項目被迭代時對每個項目呼叫。`map` 方法回傳一個新的迭代器，該迭代器產生修改後的項目。這裡的閉包會建立一個新的迭代器，其中來自 vector 的每個項目都會加 1。

src/main.rs

```rust
    let v1: Vec<i32> = vec![1, 2, 3];

    v1.iter().map(|x| x + 1);
```

列表 13-14：呼叫迭代器配接器 `map` 來建立一個新的迭代器

然而，這段程式碼會產生一個警告：

```
$ cargo run
   Compiling iterators v0.1.0 (file:///projects/iterators)
warning: unused `Map` that must be used
 --> src/main.rs:4:5
  |
4 |     v1.iter().map(|x| x + 1);
  |     ^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: iterators are lazy and do nothing unless consumed
  = note: `#[warn(unused_must_use)]` on by default
help: use `let _ = ...` to ignore the resulting value
  |
4 |     let _ = v1.iter().map(|x| x + 1);
  |     +++++++

warning: `iterators` (bin "iterators") generated 1 warning
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.47s
     Running `target/debug/iterators`
```

列表 13-14 中的程式碼什麼也沒做；我們指定的閉包從未被呼叫。警告提醒我們原因：迭代器配接器是惰性的，我們需要在這裡消耗迭代器。

要修正這個警告並消耗迭代器，我們將使用 `collect` 方法，我們在列表 12-1 中與 `env::args` 一起使用過。這個方法會消耗迭代器並將結果值收集到一個集合資料型別中。

在列表 13-15 中，我們將遍歷 `map` 呼叫回傳的迭代器的結果收集到一個 vector 中。這個 vector 最終將包含原始 vector 中的每個項目，每個項目都加了 1。

src/main.rs

```rust
    let v1: Vec<i32> = vec![1, 2, 3];

    let v2: Vec<_> = v1.iter().map(|x| x + 1).collect();

    assert_eq!(v2, vec![2, 3, 4]);
```

列表 13-15：呼叫 `map` 方法建立一個新的迭代器，然後呼叫 `collect` 方法消耗新的迭代器並建立一個 vector

因為 `map` 接受一個閉包，我們可以指定任何我們想對每個項目執行的操作。這是一個很好的例子，說明閉包如何讓你自訂某些行為，同時重用 `Iterator` trait 提供的迭代行為。

你可以將多個迭代器配接器的呼叫串連起來，以一種可讀的方式執行複雜的操作。但因為所有迭代器都是惰性的，你必須呼叫其中一個消耗性配接器方法，才能從迭代器配接器的呼叫中獲得結果。

### 使用捕捉其環境的閉包

許多迭代器配接器都接受閉包作為參數，而我們通常指定給迭代器配接器的閉包會是捕捉其環境的閉包。

在這個例子中，我們將使用 `filter` 方法，它接受一個閉包。該閉包會從迭代器中獲取一個項目並回傳一個 `bool`。如果閉包回傳 `true`，該值將被包含在 `filter` 產生的迭代中。如果閉包回傳 `false`，該值將不會被包含。

在列表 13-16 中，我們使用 `filter` 和一個從其環境中捕捉 `shoe_size` 變數的閉包，來遍歷一個 `Shoe` 結構體實例的集合。它將只回傳指定尺寸的鞋子。

src/lib.rs

```rust
#[derive(PartialEq, Debug)]
struct Shoe {
    size: u32,
    style: String,
}

fn shoes_in_size(shoes: Vec<Shoe>, shoe_size: u32) -> Vec<Shoe> {
    shoes.into_iter().filter(|s| s.size == shoe_size).collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn filters_by_size() {
        let shoes = vec![
            Shoe {
                size: 10,
                style: String::from("sneaker"),
            },
            Shoe {
                size: 13,
                style: String::from("sandal"),
            },
            Shoe {
                size: 10,
                style: String::from("boot"),
            },
        ];

        let in_my_size = shoes_in_size(shoes, 10);

        assert_eq!(
            in_my_size,
            vec![
                Shoe {
                    size: 10,
                    style: String::from("sneaker")
                },
                Shoe {
                    size: 10,
                    style: String::from("boot")
                },
            ]
        );
    }
}
```

列表 13-16：使用 `filter` 方法和一個捕捉 `shoe_size` 的閉包

`shoes_in_size` 函式接受一個鞋子 vector 的所有權和一個鞋子尺寸作為參數。它回傳一個只包含指定尺寸鞋子的 vector。

在 `shoes_in_size` 的主體中，我們呼叫 `into_iter` 來建立一個取得 vector 所有權的迭代器。然後我們呼叫 `filter` 來將該迭代器配接成一個新的迭代器，只包含閉包回傳 `true` 的元素。

閉包從環境中捕捉 `shoe_size` 參數，並將該值與每雙鞋的尺寸進行比較，只保留指定尺寸的鞋子。最後，呼叫 `collect` 將配接後迭代器回傳的值收集到一個 vector 中，這個 vector 由函式回傳。

測試顯示，當我們呼叫 `shoes_in_size` 時，我們只會得到與我們指定的值具有相同尺寸的鞋子。

## 改進我們的 I/O 專案

有了關於迭代器的這些新知識，我們可以透過使用迭代器來讓程式碼中的某些地方更清晰、更簡潔，從而改進第 12 章的 I/O 專案。讓我們來看看迭代器如何改進我們對 `Config::build` 函式和 `search` 函式的實作。

### 使用迭代器移除 clone

在列表 12-6 中，我們添加了程式碼，它接受一個 `String` 值的 slice，並通過索引到 slice 中並複製 (cloning) 值來建立 `Config` 結構體的實例，從而讓 `Config` 結構體擁有這些值。在列表 13-17 中，我們重現了列表 12-23 中 `Config::build` 函式的實作。

src/main.rs

```rust
impl Config {
    fn build(args: &[String]) -> Result<Config, &'static str> {
        if args.len() < 3 {
            return Err("not enough arguments");
        }

        let query = args[1].clone();
        let file_path = args[2].clone();

        let ignore_case = env::var("IGNORE_CASE").is_ok();

        Ok(Config {
            query,
            file_path,
            ignore_case,
        })
    }
}
```

列表 13-17：重現自列表 12-23 的 `Config::build` 函式

當時，我們說過不要擔心效率低下的 `clone` 呼叫，因為我們將來會移除它們。嗯，那個時候就是現在！

我們在這裡需要 `clone`，因為我們在參數 `args` 中有一個帶有 `String` 元素的 slice，但 `build` 函式並不擁有 `args`。為了回傳 `Config` 實例的所有權，我們必須複製 `Config` 的 `query` 和 `file_path` 欄位的值，這樣 `Config` 實例才能擁有它的值。

有了我們關於迭代器的新知識，我們可以改變 `build` 函式，使其接受一個迭代器的所有權作為參數，而不是借用一個 slice。我們將使用迭代器功能，而不是檢查 slice 長度和索引到特定位置的程式碼。這將闡明 `Config::build` 函式在做什麼，因為迭代器將會存取這些值。

一旦 `Config::build` 取得了迭代器的所有權，並停止使用借用操作的索引，我們就可以將 `String` 值從迭代器移動到 `Config` 中，而不是呼叫 `clone` 並進行新的配置。

#### 直接使用回傳的迭代器

打開你的 I/O 專案的 _src/main.rs_ 檔案，它應該看起來像這樣：

檔名：src/main.rs

```rust
fn main() {
    let args: Vec<String> = env::args().collect();

    let config = Config::build(&args).unwrap_or_else(|err| {
        eprintln!("Problem parsing arguments: {err}");
        process::exit(1);
    });

    // --snip--
}
```

我們將首先將我們在列表 12-24 中的 `main` 函式的開頭，改成列表 13-18 中的程式碼，這次使用了一個迭代器。在我們更新 `Config::build` 之前，這段程式碼無法編譯。

src/main.rs

```rust
fn main() {
    let config = Config::build(env::args()).unwrap_or_else(|err| {
        eprintln!("Problem parsing arguments: {err}");
        process::exit(1);
    });

    // --snip--
}
```

列表 13-18：將 `env::args` 的回傳值傳遞給 `Config::build`

`env::args` 函式回傳一個迭代器！現在我們不再將迭代器值收集到一個 vector 中，然後將 slice 傳遞給 `Config::build`，而是直接將從 `env::args` 回傳的迭代器的所有權傳遞給 `Config::build`。

接下來，我們需要更新 `Config::build` 的定義。讓我們將 `Config::build` 的簽名更改為列表 13-19 的樣子。這仍然無法編譯，因為我們需要更新函式主體。

src/main.rs

```rust
impl Config {
    fn build(
        mut args: impl Iterator<Item = String>,
    ) -> Result<Config, &'static str> {
        // --snip--
```

列表 13-19：更新 `Config::build` 的簽名以期望一個迭代器

標準函式庫中關於 `env::args` 函式的文件顯示，它回傳的迭代器型別是 `std::env::Args`，該型別實作了 `Iterator` trait 並回傳 `String` 值。

我們更新了 `Config::build` 函式的簽名，使參數 `args` 具有帶有 `impl Iterator<Item = String>` trait bound 的泛型型別，而不是 `&[String]`。我們在第 10 章「Traits as Parameters」一節中討論過的這種 `impl Trait` 語法的使用，意味著 `args` 可以是任何實作 `Iterator` trait 並回傳 `String` 項目的型別。

因為我們取得了 `args` 的所有權，並且我們將通過迭代來改變 `args`，所以我們可以在 `args` 參數的規格中添加 `mut` 關鍵字，使其成為可變的。

#### 使用 Iterator Trait 方法而非索引

接下來，我們將修正 `Config::build` 的主體。因為 `args` 實作了 `Iterator` trait，我們知道我們可以在它上面呼叫 `next` 方法！列表 13-20 更新了列表 12-23 的程式碼，以使用 `next` 方法。

src/main.rs

```rust
impl Config {
    fn build(
        mut args: impl Iterator<Item = String>,
    ) -> Result<Config, &'static str> {
        args.next();

        let query = match args.next() {
            Some(arg) => arg,
            None => return Err("Didn't get a query string"),
        };

        let file_path = match args.next() {
            Some(arg) => arg,
            None => return Err("Didn't get a file path"),
        };

        let ignore_case = env::var("IGNORE_CASE").is_ok();

        Ok(Config {
            query,
            file_path,
            ignore_case,
        })
    }
}
```

列表 13-20：更改 `Config::build` 的主體以使用迭代器方法

請記住，`env::args` 回傳值中的第一個值是程式的名稱。我們想要忽略它並取得下一個值，所以我們先呼叫 `next` 並且不對回傳值做任何處理。然後我們呼叫 `next` 來取得我們想要放入 `Config` 的 `query` 欄位的值。如果 `next` 回傳 `Some`，我們使用 `match` 來提取值。如果它回傳 `None`，表示沒有提供足夠的參數，我們就提早用 `Err` 值回傳。我們對 `file_path` 值也做同樣的事情。

### 使用迭代器配接器讓程式碼更清晰

我們也可以在我們的 I/O 專案的 `search` 函式中利用迭代器，該函式在列表 13-21 中重現，與列表 12-19 中的一樣。

src/lib.rs

```rust
pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.contains(query) {
            results.push(line);
        }
    }

    results
}
```

列表 13-21：來自列表 12-19 的 `search` 函式實作

我們可以使用迭代器配接器方法以更簡潔的方式編寫這段程式碼。這樣做也讓我們避免了有一個可變的中間 `results` vector。函式程式設計風格偏好最小化可變狀態的數量，以使程式碼更清晰。移除可變狀態可能會為未來實現並行搜尋的增強功能鋪路，因為我們將不必管理對 `results` vector 的並行存取。列表 13-22 顯示了這個改變。

src/lib.rs

```rust
pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
    contents
        .lines()
        .filter(|line| line.contains(query))
        .collect()
}
```

列表 13-22：在 `search` 函式的實作中使用迭代器配接器方法

回想一下，`search` 函式的目的是回傳 `contents` 中所有包含 `query` 的行。與列表 13-16 中的 `filter` 範例類似，這段程式碼使用 `filter` 配接器來只保留那些 `line.contains(query)` 回傳 `true` 的行。然後我們用 `collect` 將匹配的行收集到另一個 vector 中。簡單多了！你也可以在 `search_case_insensitive` 函式中做同樣的改變，使用迭代器方法。

為了進一步改進，可以透過移除 `collect` 的呼叫並將回傳型別更改為 `impl Iterator<Item = &'a str>`，從 `search` 函式回傳一個迭代器，這樣函式就變成了一個迭代器配接器。請注意，你也需要更新測試！在進行此更改前後，使用你的 `minigrep` 工具搜尋一個大檔案，以觀察行為上的差異。在更改之前，程式在收集到所有結果之前不會印出任何結果，但在更改之後，由於 `run` 函式中的 `for` 迴圈能夠利用迭代器的惰性，結果將在找到每個匹配行時立即印出。

<!-- Old heading. Do not remove or links may break. -->

<a id="choosing-between-loops-or-iterators"></a>

### 在迴圈和迭代器之間做選擇

下一個合乎邏輯的問題是，在你自己的程式碼中應該選擇哪種風格以及為什麼：列表 13-21 中的原始實作，還是列表 13-22 中使用迭代器的版本（假設我們在回傳之前收集所有結果，而不是回傳迭代器）。大多數 Rust 程式設計師偏好使用迭代器風格。一開始可能有點難上手，但一旦你對各種迭代器配接器以及它們的功能有了感覺，迭代器可能更容易理解。程式碼不再是擺弄迴圈和建立新 vector 的各種細節，而是專注於迴圈的高階目標。這抽象化了一些常見的程式碼，使得更容易看到這段程式碼獨有的概念，例如迭代器中每個元素必須通過的過濾條件。

但這兩種實作真的等效嗎？直觀的假設可能是，較低階的迴圈會更快。讓我們來談談效能。

## 效能比較：迴圈 vs. 迭代器

要決定是使用迴圈還是迭代器，你需要知道哪種實作更快：帶有明確 `for` 迴圈的 `search` 函式版本，還是帶有迭代器的版本。

我們進行了一個基準測試，將阿瑟·柯南·道爾爵士的《福爾摩斯探案集》的全部內容載入到一個 `String` 中，並在內容中尋找單詞 _the_。以下是使用 `for` 迴圈的 `search` 版本和使用迭代器的版本的基準測試結果：

```
test bench_search_for  ... bench:  19,620,300 ns/iter (+/- 915,700)
test bench_search_iter ... bench:  19,234,900 ns/iter (+/- 657,200)
```

兩種實作的效能相似！我們在這裡不會解釋基準測試的程式碼，因為重點不是要證明這兩個版本是等效的，而是要對這兩種實作在效能上的比較有一個大概的了解。

為了進行更全面的基準測試，你應該使用各種大小不同的文本作為 `contents`，使用不同的單詞和不同長度的單詞作為 `query`，以及各種其他的變化來進行檢查。重點是：迭代器，儘管是一個高階抽象，但會被編譯成與你自己編寫較低階程式碼大致相同的程式碼。迭代器是 Rust 的_零成本抽象 (zero-cost abstractions)*之一，我們的意思是使用抽象不會帶來額外的執行時期開銷。這類似於 C++ 的原始設計者和實作者 Bjarne Stroustrup 在《Foundations of C++》（2012）中定義的*零開銷 (zero-overhead)_：

> 總的來說，C++ 的實作遵循零開銷原則：你沒用到的東西，你不用為它付費。而且更進一步：你用到的東西，你自己手寫也寫不出更好的程式碼。

在許多情況下，使用迭代器的 Rust 程式碼會編譯成與你手寫的相同的組譯碼。像是迴圈展開 (loop unrolling) 和消除陣列存取的邊界檢查等最佳化都會應用，使得最終的程式碼效率極高。既然你現在知道了這一點，你就可以放心地使用迭代器和閉包了！它們讓程式碼看起來更高階，但不會因此帶來執行時期的效能損失。

## 總結

閉包和迭代器是 Rust 中受函式程式設計語言思想啟發的功能。它們有助於 Rust 能夠以低階效能清晰地表達高階思想。閉包和迭代器的實作方式使得執行時期效能不受影響。這是 Rust 致力於提供零成本抽象的目標的一部分。

現在我們已經提高了我們的 I/O 專案的表達能力，讓我們來看看 `cargo` 的更多功能，這些功能將幫助我們與世界分享這個專案。
