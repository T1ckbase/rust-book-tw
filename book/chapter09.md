<!-- DO NOT EDIT THIS FILE.

This file is periodically generated from the content in the `/src/`
directory, so all fixes need to be made in `/src/`.
-->

[TOC]

# 錯誤處理

錯誤在軟體中是無可避免的，因此 Rust 提供了許多功能來處理發生錯誤的情況。在許多情況下，Rust 會要求你在程式碼編譯之前，確認錯誤的可能性並採取一些措施。這個要求讓你的程式更加健壯，確保你能在部署程式碼到 production 之前發現並適當地處理錯誤！

Rust 將錯誤分為兩大類：_可復原 (recoverable)_ 錯誤和 _不可復原 (unrecoverable)_ 錯誤。對於可復原的錯誤，例如「_找不到檔案 (file not found)_」錯誤，我們很可能只是想向使用者報告問題並重試操作。不可復原的錯誤總是程式碼 bug 的徵兆，例如試圖存取超出陣列末端的位置，因此我們想立即停止程式。

大多數語言不區分這兩種錯誤，並使用例外 (exceptions) 等機制以相同的方式處理它們。Rust 沒有 exceptions。相反地，它為可復原的錯誤提供了 `Result<T, E>` 型別，以及當程式遇到不可復原的錯誤時會停止執行的 `panic!` macro。本章首先會介紹呼叫 `panic!`，然後討論回傳 `Result<T, E>` 值。此外，我們還會探討在決定是嘗試從錯誤中復原還是停止執行時的考量因素。

## 使用 panic! 處理不可復原的錯誤

有時你的程式碼會發生一些糟糕的事情，而且你無能為力。在這些情況下，Rust 有 `panic!` macro。在實務上有兩種方式可以導致 panic：採取會導致程式碼 panic 的動作（例如存取超出陣列末端的位置），或明確地呼叫 `panic!` macro。在這兩種情況下，我們都會讓程式發生 panic。預設情況下，這些 panic 會列印失敗訊息，unwind、清理 stack，然後退出。透過一個 environment variable，你還可以讓 Rust 在 panic 發生時顯示 call stack，以便更容易追蹤 panic 的來源。

> ### 應對 Panic 時 unwind stack 或 abort
>
> 預設情況下，當 panic 發生時，程式會開始 _unwinding_，這表示 Rust 會回溯 stack 並清理它遇到的每個 function 的資料。然而，回溯並清理是非常耗費工作的。因此，Rust 允許你選擇立即 _abort_ 的替代方案，這會在不清理的情況下結束程式。
>
> 程式使用的記憶體之後會由 operating system 清理。如果你的專案需要讓產生的 binary 盡可能小，你可以透過在 _Cargo.toml_ 檔案中相應的 `[profile]` 部分加入 `panic = 'abort'`，將 panic 時的行為從 unwinding 切換到 aborting。例如，如果你想在 release mode 下發生 panic 時 abort，請加入以下內容：
>
> ```toml
> [profile.release]
> panic = 'abort'
> ```

讓我們試著在一個簡單的程式中呼叫 `panic!`：

src/main.rs

```rust
fn main() {
    panic!("crash and burn");
}
```

當你執行程式時，會看到類似這樣的內容：

```
$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.25s
     Running `target/debug/panic`

thread 'main' panicked at src/main.rs:2:5:
crash and burn
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```

`panic!` 的呼叫導致了最後兩行中包含的錯誤訊息。第一行顯示了我們的 panic 訊息以及 panic 發生在原始碼中的位置：_src/main.rs:2:5_ 表示它位於我們 _src/main.rs_ 檔案的第二行第五個字元。

在這個例子中，指示的行是我們程式碼的一部分，如果我們到那一行，會看到 `panic!` macro 的呼叫。在其他情況下，`panic!` 的呼叫可能是在我們程式碼呼叫的程式碼中，錯誤訊息報告的檔案名稱和行號會是別人的程式碼中呼叫 `panic!` macro 的位置，而不是最終導致 `panic!` 呼叫的我們的程式碼行。

<!-- Old heading. Do not remove or links may break. -->

我們可以利用 `panic!` 呼叫來源的 function 的 backtrace 來找出造成問題的程式碼部分。要了解如何使用 `panic!` backtrace，讓我們看另一個範例，看看當 `panic!` 呼叫是因為我們程式碼中的 bug 而來自 library，而不是我們的程式碼直接呼叫 macro 時會是什麼樣子。Listing 9-1 有一段程式碼，試圖存取 vector 中超出有效索引範圍的索引。

src/main.rs

```rust
fn main() {
    let v = vec![1, 2, 3];

    v[99];
}
```

Listing 9-1: 試圖存取超出 vector 尾端的元素，這會導致呼叫 `panic!`

在這裡，我們試圖存取 vector 的第 100 個元素（因為索引從零開始，所以是 index 99），但 vector 只有三個元素。在這種情況下，Rust 會 panic。使用 `[]` 應該會回傳一個元素，但如果你傳遞了一個無效的索引，Rust 在這裡沒有任何正確的元素可以回傳。

在 C 語言中，試圖讀取超出 data structure 尾端的位置是 undefined behavior。你可能會得到 memory 中對應於該 data structure 中該元素的位置的任何值，即使該 memory 不屬於該 structure。這被稱為 _buffer overread_，如果攻擊者能夠以某種方式操作索引來讀取不應該被允許的、儲存在 data structure 之後的資料，這可能會導致 security vulnerabilities。

為了保護你的程式免受這類 vulnerability 的影響，如果你嘗試讀取一個不存在的索引上的元素，Rust 將停止執行並拒絕繼續。讓我們試試看：

```
$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.27s
     Running `target/debug/panic`

thread 'main' panicked at src/main.rs:4:6:
index out of bounds: the len is 3 but the index is 99
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```

這個錯誤指向我們的 _main.rs_ 第 4 行，我們試圖存取 `v` 中 vector 的索引 `99`。

`note:` 行告訴我們可以設定 `RUST_BACKTRACE` environment variable 來獲取導致錯誤發生的確切 backtrace。_backtrace_ 是所有已呼叫的 function 的列表，用於到達這一點。Rust 中的 backtrace 與其他語言中相同：閱讀 backtrace 的關鍵是從頂部開始閱讀，直到你看到你寫的檔案。那就是問題的起源點。該點上方的行是你程式碼呼叫的程式碼；下方的行是呼叫你程式碼的程式碼。這些前後的行可能包括 Rust core 程式碼、standard library 程式碼，或你正在使用的 crates。讓我們試著將 `RUST_BACKTRACE` environment variable 設定為除了 `0` 以外的任何值來獲取 backtrace。Listing 9-2 顯示了你將看到的類似輸出。

<!-- manual-regeneration
cd listings/ch09-error-handling/listing-09-01
RUST_BACKTRACE=1 cargo run
copy the backtrace output below
check the backtrace number mentioned in the text below the listing
-->

```
$ RUST_BACKTRACE=1 cargo run
thread 'main' panicked at src/main.rs:4:6:
index out of bounds: the len is 3 but the index is 99
stack backtrace:
   0: rust_begin_unwind
             at /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/std/src/panicking.rs:692:5
   1: core::panicking::panic_fmt
             at /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/core/src/panicking.rs:75:14
   2: core::panicking::panic_bounds_check
             at /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/core/src/panicking.rs:273:5
   3: <usize as core::slice::index::SliceIndex<[T]>>::index
             at file:///home/.rustup/toolchains/1.85/lib/rustlib/src/rust/library/core/src/slice/index.rs:274:10
   4: core::slice::index::<impl core::ops::index::Index<I> for [T]>::index
             at file:///home/.rustup/toolchains/1.85/lib/rustlib/src/rust/library/core/src/slice/index.rs:16:9
   5: <alloc::vec::Vec<T,A> as core::ops::index::Index<I>>::index
             at file:///home/.rustup/toolchains/1.85/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:3361:9
   6: panic::main
             at ./src/main.rs:4:6
   7: core::ops::function::FnOnce::call_once
             at file:///home/.rustup/toolchains/1.85/lib/rustlib/src/rust/library/core/src/ops/function.rs:250:5
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.
```

Listing 9-2: 當 environment variable `RUST_BACKTRACE` 設定時，由呼叫 `panic!` 產生的 backtrace 顯示

這有很多輸出！你看到的確切輸出可能會因你的 operating system 和 Rust 版本而異。為了獲得包含此資訊的 backtrace，必須啟用 debug symbols。預設情況下，當我們像這裡一樣使用 `cargo build` 或 `cargo run` 而不帶 `--release` flag 時，debug symbols 是啟用的。

在 Listing 9-2 的輸出中，backtrace 的第 6 行指向我們專案中導致問題的行：_src/main.rs_ 的第 4 行。如果我們不想讓程式 panic，我們應該從第一行提到我們寫的檔案的位置開始調查。在 Listing 9-1 中，我們刻意寫了會 panic 的程式碼，修復 panic 的方法是不請求超出 vector 索引範圍的元素。當你的程式未來發生 panic 時，你需要找出程式正在用什麼值執行什麼動作導致 panic，以及程式應該做什麼來替代。

我們稍後會在「[要 `panic!` 還是不要 `panic!`](https://doc.rust-lang.org/book/ch09-00-error-handling.html#to-panic-or-not-to-panic)」一節中再次討論 `panic!` 以及何時應該和不應該使用 `panic!` 來處理錯誤狀況。接下來，我們將看看如何使用 `Result` 從錯誤中復原。

## 使用 Result 處理可復原的錯誤

大多數錯誤都不嚴重到需要程式完全停止。有時 function 失敗的原因是你很容易理解並回應的。例如，如果你試圖開啟一個檔案，而該操作因檔案不存在而失敗，你可能會想建立該檔案而不是終止程序。

回想一下 Chapter 2 中的「[處理可能失敗的 `Result`](https://doc.rust-lang.org/book/ch02-00-guessing-game.html#handling-potential-failure-with-result)」，`Result` enum 被定義為有兩個 variants，`Ok` 和 `Err`，如下所示：

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

`T` 和 `E` 是 generic type parameters：我們將在 Chapter 10 中更詳細地討論 generics。你現在需要知道的是，`T` 代表在 `Ok` variant 中成功情況下將回傳的值的型別，而 `E` 代表在 `Err` variant 中失敗情況下將回傳的錯誤的型別。因為 `Result` 具有這些 generic type parameters，我們可以在許多不同的情況下使用 `Result` 型別和其上定義的 functions，其中我們想要回傳的成功值和錯誤值可能不同。

讓我們呼叫一個回傳 `Result` 值的 function，因為該 function 可能會失敗。在 Listing 9-3 中，我們試圖開啟一個檔案。

src/main.rs

```rust
use std::fs::File;

fn main() {
    let greeting_file_result = File::open("hello.txt");
}
```

Listing 9-3: 開啟檔案

`File::open` 的回傳型別是 `Result<T, E>`。generic parameter `T` 已被 `File::open` 的實作填入成功值的型別 `std::fs::File`，它是一個 file handle。錯誤值中使用的 `E` 型別是 `std::io::Error`。這個回傳型別表示呼叫 `File::open` 可能會成功並回傳一個我們可以讀取或寫入的 file handle。該 function 呼叫也可能會失敗：例如，檔案可能不存在，或者我們可能沒有權限存取該檔案。`File::open` function 需要有一種方式告訴我們它是成功還是失敗，同時提供我們 file handle 或錯誤資訊。這些資訊正是 `Result` enum 所傳達的。

在 `File::open` 成功的情況下，變數 `greeting_file_result` 中的值將是一個包含 file handle 的 `Ok` 實例。在失敗的情況下，`greeting_file_result` 中的值將是一個包含有關發生錯誤型別的更多資訊的 `Err` 實例。

我們需要擴充 Listing 9-3 中的程式碼，根據 `File::open` 回傳的值採取不同的動作。Listing 9-4 顯示了使用基本工具 `match` expression 處理 `Result` 的一種方式，我們已在 Chapter 6 中討論過 `match` expression。

src/main.rs

```rust
use std::fs::File;

fn main() {
    let greeting_file_result = File::open("hello.txt");

    let greeting_file = match greeting_file_result {
        Ok(file) => file,
        Err(error) => panic!("Problem opening the file: {error:?}"),
    };
}
```

Listing 9-4: 使用 `match` expression 來處理可能回傳的 `Result` variants

請注意，與 `Option` enum 一樣，`Result` enum 及其 variants 已由 prelude 引入 scope，因此我們在 `match` arms 中的 `Ok` 和 `Err` variants 之前不需要指定 `Result::`。

當結果是 `Ok` 時，這段程式碼會從 `Ok` variant 中回傳內部的 `file` 值，然後我們將該 file handle 值賦給變數 `greeting_file`。在 `match` 之後，我們可以將 file handle 用於讀取或寫入。

`match` 的另一個 arm 處理我們從 `File::open` 得到 `Err` 值的情況。在這個範例中，我們選擇呼叫 `panic!` macro。如果我們目前的目錄中沒有名為 _hello.txt_ 的檔案，並且我們執行這段程式碼，我們將會看到來自 `panic!` macro 的以下輸出：

```
$ cargo run
   Compiling error-handling v0.1.0 (file:///projects/error-handling)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.73s
     Running `target/debug/error-handling`

thread 'main' panicked at src/main.rs:8:23:
Problem opening the file: Os { code: 2, kind: NotFound, message: "No such file or directory" }
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```

一如往常，這個輸出確切地告訴我們發生了什麼問題。

### 根據不同的錯誤進行 match

Listing 9-4 中的程式碼無論 `File::open` 失敗的原因是什麼，都會 `panic!`。然而，我們希望針對不同的失敗原因採取不同的動作。如果 `File::open` 因為檔案不存在而失敗，我們希望建立檔案並回傳新檔案的 handle。如果 `File::open` 因為任何其他原因失敗——例如，因為我們沒有權限開啟檔案——我們仍然希望程式碼以與 Listing 9-4 相同的方式 `panic!`。為此，我們加入了一個內部 `match` expression，如 Listing 9-5 所示。

src/main.rs

<!-- ignore this test because otherwise it creates hello.txt which causes other
tests to fail lol -->

```rust
use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let greeting_file_result = File::open("hello.txt");

    let greeting_file = match greeting_file_result {
        Ok(file) => file,
        Err(error) => match error.kind() {
            ErrorKind::NotFound => match File::create("hello.txt") {
                Ok(fc) => fc,
                Err(e) => panic!("Problem creating the file: {e:?}"),
            },
            _ => {
                panic!("Problem opening the file: {error:?}");
            }
        },
    };
}
```

Listing 9-5: 以不同方式處理不同種類的錯誤

`File::open` 在 `Err` variant 內部回傳的值的型別是 `io::Error`，它是一個 standard library 提供的 struct。這個 struct 有一個 `kind` method，我們可以呼叫它來取得 `io::ErrorKind` 值。`io::ErrorKind` enum 由 standard library 提供，並具有代表可能由 `io` 操作導致的不同種類錯誤的 variants。我們想要使用的 variant 是 `ErrorKind::NotFound`，它表示我們試圖開啟的檔案尚不存在。因此，我們對 `greeting_file_result` 進行 match，但我們也對 `error.kind()` 進行了一個內部 match。

我們在內部 `match` 中想要檢查的條件是，`error.kind()` 回傳的值是否為 `ErrorKind` enum 的 `NotFound` variant。如果是，我們就嘗試用 `File::create` 建立檔案。然而，由於 `File::create` 也可能失敗，我們需要在內部 `match` expression 中有第二個 arm。當檔案無法建立時，會列印不同的錯誤訊息。外部 `match` 的第二個 arm 保持不變，因此程式會因為除檔案遺失錯誤以外的任何錯誤而 panic。

> #### 使用 match 處理 Result<T, E> 的替代方案
>
> 這有很多 `match`！`match` expression 非常有用，但也非常原始。在 Chapter 13 中，你將學習 closures，它們與 `Result<T, E>` 上定義的許多 methods 一起使用。這些 methods 在處理程式碼中的 `Result<T, E>` 值時，可以比使用 `match` 更簡潔。
>
> 例如，這裡有另一種方式來編寫與 Listing 9-5 中相同的邏輯，這次使用 closures 和 `unwrap_or_else` method：
>
> <!-- CAN'T EXTRACT SEE https://github.com/rust-lang/mdBook/issues/1127 -->
>
> ```rust,ignore
> use std::fs::File;
> use std::io::ErrorKind;
>
> fn main() {
>     let greeting_file = File::open("hello.txt").unwrap_or_else(|error| {
>         if error.kind() == ErrorKind::NotFound {
>             File::create("hello.txt").unwrap_or_else(|error| {
>                 panic!("Problem creating the file: {error:?}");
>             })
>         } else {
>             panic!("Problem opening the file: {error:?}");
>         }
>     });
> }
> ```
>
> 儘管這段程式碼與 Listing 9-5 具有相同的行為，但它不包含任何 `match` expressions，並且更易於閱讀。讀完 Chapter 13 後，請回頭看這個範例，並在 standard library documentation 中查找 `unwrap_or_else` method。還有許多這些 methods 可以在處理錯誤時清理大量的巢狀 `match` expressions。

#### 錯誤時 Panic 的捷徑：unwrap 和 expect

使用 `match` 效果不錯，但它可能有點冗長，並且不總能很好地傳達意圖。`Result<T, E>` 型別上定義了許多 helper methods，用於執行各種更具體的任務。`unwrap` method 是一個捷徑 method，其實作方式就像我們在 Listing 9-4 中編寫的 `match` expression。如果 `Result` 值是 `Ok` variant，`unwrap` 將回傳 `Ok` 內部的值。如果 `Result` 是 `Err` variant，`unwrap` 將會為我們呼叫 `panic!` macro。以下是 `unwrap` 的實際範例：

src/main.rs

```rust
use std::fs::File;

fn main() {
    let greeting_file = File::open("hello.txt").unwrap();
}
```

如果我們在沒有 _hello.txt_ 檔案的情況下執行這段程式碼，我們將會看到 `unwrap` method 所發出的 `panic!` 呼叫產生的錯誤訊息：

<!-- manual-regeneration
cd listings/ch09-error-handling/no-listing-04-unwrap
cargo run
copy and paste relevant text
-->

```
thread 'main' panicked at src/main.rs:4:49:
called `Result::unwrap()` on an `Err` value: Os { code: 2, kind: NotFound, message: "No such file or directory" }
```

同樣地，`expect` method 也讓我們可以選擇 `panic!` 錯誤訊息。使用 `expect` 而不是 `unwrap`，並提供良好的錯誤訊息，可以傳達你的意圖，並使追蹤 panic 的來源更容易。`expect` 的語法如下所示：

src/main.rs

```rust
use std::fs::File;

fn main() {
    let greeting_file = File::open("hello.txt")
        .expect("hello.txt should be included in this project");
}
```

我們使用 `expect` 的方式與 `unwrap` 相同：回傳 file handle 或呼叫 `panic!` macro。`expect` 在其呼叫 `panic!` 中使用的錯誤訊息將是我們傳遞給 `expect` 的參數，而不是 `unwrap` 使用的預設 `panic!` 訊息。它的樣子如下所示：

<!-- manual-regeneration
cd listings/ch09-error-handling/no-listing-05-expect
cargo run
copy and paste relevant text
-->

```
thread 'main' panicked at src/main.rs:5:10:
hello.txt should be included in this project: Os { code: 2, kind: NotFound, message: "No such file or directory" }
```

在 production 等級的程式碼中，大多數 Rustaceans 會選擇 `expect` 而不是 `unwrap`，並提供更多關於為什麼操作預期總是會成功的上下文資訊。這樣一來，如果你的假設被證明是錯誤的，你就有更多資訊可以用於 debugging。

### 錯誤傳播

當 function 的實作呼叫某個可能失敗的操作時，你可以將錯誤回傳給呼叫端程式碼，而不是在 function 本身內處理錯誤，這樣呼叫端程式碼就可以決定如何處理。這稱為錯誤的 _傳播 (propagating)_，並賦予呼叫端程式碼更多的控制權，因為在呼叫端可能會有更多資訊或邏輯來決定如何處理錯誤，而不是在你程式碼的上下文中所能取得的資訊。

例如，Listing 9-6 顯示了一個從檔案讀取 username 的 function。如果檔案不存在或無法讀取，此 function 將把這些錯誤回傳給呼叫該 function 的程式碼。

src/main.rs

<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->

```rust
use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -> Result<String, io::Error> {
    let username_file_result = File::open("hello.txt");

    let mut username_file = match username_file_result {
        Ok(file) => file,
        Err(e) => return Err(e),
    };

    let mut username = String::new();

    match username_file.read_to_string(&mut username) {
        Ok(_) => Ok(username),
        Err(e) => Err(e),
    }
}
```

Listing 9-6: 使用 `match` 將錯誤回傳給呼叫端程式碼的 function

這個 function 可以用更短的方式編寫，但我們將從手動執行許多部分開始，以探索錯誤處理；最後，我們將展示更短的方式。讓我們先看看 function 的回傳型別：`Result<String, io::Error>`。這表示該 function 回傳的型別是 `Result<T, E>`，其中 generic parameter `T` 已被具體型別 `String` 填入，而 generic type `E` 已被具體型別 `io::Error` 填入。

如果這個 function 成功且沒有任何問題，呼叫這個 function 的程式碼將會收到一個包含 `String` 的 `Ok` 值——這個 `String` 就是這個 function 從檔案中讀取的 `username`。如果這個 function 遇到任何問題，呼叫端程式碼將會收到一個包含 `io::Error` 實例的 `Err` 值，其中包含更多關於問題的資訊。我們選擇 `io::Error` 作為這個 function 的回傳型別，因為這恰好是這個 function 主體中我們呼叫的兩個可能失敗的操作所回傳的錯誤值的型別：`File::open` function 和 `read_to_string` method。

function 的主體從呼叫 `File::open` function 開始。然後我們使用與 Listing 9-4 中類似的 `match` 來處理 `Result` 值。如果 `File::open` 成功，pattern variable `file` 中的 file handle 將成為 mutable variable `username_file` 中的值，並且 function 繼續執行。在 `Err` 的情況下，我們不是呼叫 `panic!`，而是使用 `return` 關鍵字從 function 中提早回傳，並將來自 `File::open` 的錯誤值（現在在 pattern variable `e` 中）傳回給呼叫端程式碼作為此 function 的錯誤值。

因此，如果我們在 `username_file` 中有一個 file handle，該 function 會在變數 `username` 中建立一個新的 `String`，並呼叫 `username_file` 中 file handle 的 `read_to_string` method，將檔案內容讀取到 `username` 中。`read_to_string` method 也回傳一個 `Result`，因為它可能會失敗，即使 `File::open` 成功了。所以我們需要另一個 `match` 來處理那個 `Result`：如果 `read_to_string` 成功，那麼我們的 function 就成功了，我們將檔案中現在位於 `username` 中的 username 包裹在 `Ok` 中回傳。如果 `read_to_string` 失敗，我們以與處理 `File::open` 回傳值的 `match` 相同的方式回傳錯誤值。然而，我們不需要明確地說 `return`，因為這是 function 中的最後一個 expression。

呼叫此程式碼的程式碼隨後將處理接收一個包含 username 的 `Ok` 值，或一個包含 `io::Error` 的 `Err` 值。由呼叫端程式碼決定如何處理這些值。如果呼叫端程式碼收到 `Err` 值，它可能會呼叫 `panic!` 並使程式崩潰、使用預設 username，或者從檔案以外的地方查找 username 等。我們沒有足夠的資訊來了解呼叫端程式碼實際嘗試做什麼，因此我們將所有成功或錯誤資訊向上傳播，讓它適當地處理。

這種傳播錯誤的模式在 Rust 中非常常見，因此 Rust 提供了問號 operator `?` 來簡化這個過程。

#### 錯誤傳播的捷徑：問號 ? operator

Listing 9-7 顯示了 `read_username_from_file` 的實作，它具有與 Listing 9-6 相同的功能，但此實作使用了 `?` operator。

src/main.rs

<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->

```rust
use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -> Result<String, io::Error> {
    let mut username_file = File::open("hello.txt")?;
    let mut username = String::new();
    username_file.read_to_string(&mut username)?;
    Ok(username)
}
```

Listing 9-7: 使用 `?` operator 將錯誤回傳給呼叫端程式碼的 function

放在 `Result` 值之後的 `?` 被定義為幾乎與我們在 Listing 9-6 中定義的用於處理 `Result` 值的 `match` expressions 相同。如果 `Result` 的值是 `Ok`，那麼 `Ok` 內部的值將從這個 expression 回傳，程式將繼續執行。如果值是 `Err`，那麼 `Err` 將從整個 function 回傳，就像我們使用了 `return` 關鍵字一樣，這樣錯誤值就會傳播到呼叫端程式碼。

`match` expression 從 Listing 9-6 所做的事情與 `?` operator 所做的事情之間存在一個差異：被呼叫 `?` operator 的錯誤值會通過在 standard library 中的 `From` trait 中定義的 `from` function，該 function 用於將值從一種型別轉換為另一種型別。當 `?` operator 呼叫 `from` function 時，收到的錯誤型別會被轉換為目前 function 的回傳型別中定義的錯誤型別。當 function 回傳一個錯誤型別來表示 function 可能失敗的所有方式時，這很有用，即使部分原因可能是由於許多不同的原因而失敗。

例如，我們可以更改 Listing 9-7 中的 `read_username_from_file` function，使其回傳我們定義的自訂錯誤型別 `OurError`。如果我們還定義 `impl From<io::Error> for OurError` 以從 `io::Error` 建構 `OurError` 的實例，那麼 `read_username_from_file` 主體中的 `?` operator 呼叫將會呼叫 `from` 並轉換錯誤型別，而無需向 function 添加任何額外的程式碼。

在 Listing 9-7 的上下文中，`File::open` 呼叫末尾的 `?` 將 `Ok` 內部的值回傳給變數 `username_file`。如果發生錯誤，`?` operator 將從整個 function 中提早回傳，並將任何 `Err` 值傳遞給呼叫端程式碼。同樣的道理也適用於 `read_to_string` 呼叫末尾的 `?`。

`?` operator 消除了大量的 boilerplate，並使這個 function 的實作更簡單。我們甚至可以透過在 `?` 之後立即鏈接 method 呼叫來進一步縮短這段程式碼，如 Listing 9-8 所示。

src/main.rs

<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->

```rust
use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -> Result<String, io::Error> {
    let mut username = String::new();

    File::open("hello.txt")?.read_to_string(&mut username)?;

    Ok(username)
}
```

Listing 9-8: 在 `?` operator 之後鏈接 method 呼叫

我們將 `username` 中新 `String` 的建立移到了 function 的開頭；那部分沒有改變。我們沒有建立變數 `username_file`，而是將 `read_to_string` 的呼叫直接鏈接到 `File::open("hello.txt")?` 的結果上。在 `read_to_string` 呼叫的末尾我們仍然有一個 `?`，並且當 `File::open` 和 `read_to_string` 都成功而不是回傳錯誤時，我們仍然回傳包含 `username` 的 `Ok` 值。功能性再次與 Listing 9-6 和 Listing 9-7 相同；這只是一種不同、更符合人體工學的寫法。

Listing 9-9 顯示了一種使用 `fs::read_to_string` 來使其更短的方式。

src/main.rs

<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->

```rust
use std::fs;
use std::io;

fn read_username_from_file() -> Result<String, io::Error> {
    fs::read_to_string("hello.txt")
}
```

Listing 9-9: 使用 `fs::read_to_string` 取代開啟然後讀取檔案

將檔案讀入 string 是一種相當常見的操作，因此 standard library 提供了方便的 `fs::read_to_string` function，它會開啟檔案、建立一個新的 `String`、讀取檔案內容、將內容放入該 `String`，然後回傳。當然，使用 `fs::read_to_string` 不會給我們機會解釋所有的錯誤處理，所以我們首先使用了更長的方式。

#### `?` operator 的使用時機

`?` operator 只能在回傳型別與其所使用的值相容的 functions 中使用。這是因為 `?` operator 被定義為在 function 中執行值的提早回傳，其方式與我們在 Listing 9-6 中定義的 `match` expression 相同。在 Listing 9-6 中，`match` 使用了一個 `Result` 值，並且提早回傳的 arm 回傳了一個 `Err(e)` 值。function 的回傳型別必須是 `Result`，以便與此 `return` 相容。

在 Listing 9-10 中，讓我們看看如果我們在 `main` function 中使用 `?` operator，而其回傳型別與我們使用 `?` 的值的型別不相容時，會得到什麼錯誤。

src/main.rs

```rust
use std::fs::File;

fn main() {
    let greeting_file = File::open("hello.txt")?;
}
```

Listing 9-10: 試圖在回傳 `()` 的 `main` function 中使用 `?` 將無法編譯。

這個程式碼開啟一個檔案，這可能會失敗。`?` operator 跟隨在 `File::open` 回傳的 `Result` 值之後，但這個 `main` function 的回傳型別是 `()`，而不是 `Result`。當我們編譯這段程式碼時，我們得到以下錯誤訊息：

```
$ cargo run
   Compiling error-handling v0.1.0 (file:///projects/error-handling)
error[E0277]: the `?` operator can only be used in a function that returns `Result` or `Option` (or another type that implements `FromResidual`)
 --> src/main.rs:4:48
  |
3 | fn main() {
  | --------- this function should return `Result` or `Option` to accept `?`
4 |     let greeting_file = File::open("hello.txt")?;
  |                                                ^ cannot use the `?` operator in a function that returns `()`
  |
  = help: the trait `FromResidual<Result<Infallible, std::io::Error>>` is not implemented for `()`
help: consider adding return type
  |
3 ~ fn main() -> Result<(), Box<dyn std::error::Error>> {
4 |     let greeting_file = File::open("hello.txt")?;
5 +     Ok(())
  |

For more information about this error, try `rustc --explain E0277`.
error: could not compile `error-handling` (bin "error-handling") due to 1 previous error
```

這個錯誤指出我們只能在回傳 `Result`、`Option` 或其他實作了 `FromResidual` trait 的 function 中使用 `?` operator。

要修復這個錯誤，你有兩個選擇。一個選擇是，只要你沒有任何限制阻止，就更改 function 的回傳型別，使其與你使用 `?` operator 的值相容。另一個選擇是使用 `match` 或 `Result<T, E>` 的其中一個 method，以適當的方式處理 `Result<T, E>`。

錯誤訊息還提到 `?` 也可以與 `Option<T>` 值一起使用。與在 `Result` 上使用 `?` 一樣，你只能在回傳 `Option` 的 function 中對 `Option` 使用 `?`。`?` operator 在呼叫 `Option<T>` 時的行為類似於其在呼叫 `Result<T, E>` 時的行為：如果值是 `None`，則 `None` 將在該點從 function 中提早回傳。如果值是 `Some`，則 `Some` 內的值是 expression 的結果值，並且 function 繼續執行。Listing 9-11 有一個 function 的範例，它會找出給定 text 中第一行的最後一個字元。

```rust
fn last_char_of_first_line(text: &str) -> Option<char> {
    text.lines().next()?.chars().last()
}
```

Listing 9-11: 在 `Option<T>` 值上使用 `?` operator

這個 function 回傳 `Option<char>`，因為那裡可能有一個字元，但也可能沒有。這段程式碼接受 `text` string slice 參數，並呼叫其 `lines` method，該 method 回傳一個關於字串中行的 iterator。由於這個 function 想要檢查第一行，它會呼叫 iterator 的 `next` 來獲取 iterator 中的第一個值。如果 `text` 是空字串，這個 `next` 呼叫將回傳 `None`，在這種情況下我們使用 `?` 停止並從 `last_char_of_first_line` 回傳 `None`。如果 `text` 不是空字串，`next` 將回傳一個 `Some` 值，其中包含 `text` 中第一行的 string slice。

`?` 提取 string slice，我們可以對該 string slice 呼叫 `chars` 以獲取其字元的 iterator。我們對第一行中的最後一個字元感興趣，所以我們呼叫 `last` 來回傳 iterator 中的最後一個項目。這是一個 `Option`，因為第一行可能是空字串；例如，如果 `text` 以一個空行開頭，但在其他行有字元，如 `"\nhi"`。然而，如果第一行有最後一個字元，它將在 `Some` variant 中回傳。中間的 `?` operator 提供了一種簡潔的方式來表達這種邏輯，讓我們可以用一行實作 function。如果我們不能在 `Option` 上使用 `?` operator，我們將不得不使用更多的 method 呼叫或 `match` expression 來實作這個邏輯。

請注意，你可以在回傳 `Result` 的 function 中對 `Result` 使用 `?` operator，並且可以在回傳 `Option` 的 function 中對 `Option` 使用 `?` operator，但你不能混用。`?` operator 不會自動將 `Result` 轉換為 `Option`，反之亦然；在這些情況下，你可以使用 `Result` 上的 `ok` method 或 `Option` 上的 `ok_or` method 來明確地進行轉換。

到目前為止，我們使用的所有 `main` functions 都回傳 `()`。`main` function 很特別，因為它是 executable program 的進入點和退出點，並且對其回傳型別有所限制，以便程式能夠按預期執行。

幸運的是，`main` 也可以回傳 `Result<(), E>`。Listing 9-12 包含了 Listing 9-10 中的程式碼，但我們已將 `main` 的回傳型別更改為 `Result<(), Box<dyn Error>>`，並在末尾添加了回傳值 `Ok(())`。這段程式碼現在將會編譯。

src/main.rs

```rust
use std::error::Error;
use std::fs::File;

fn main() -> Result<(), Box<dyn Error>> {
    let greeting_file = File::open("hello.txt")?;

    Ok(())
}
```

Listing 9-12: 將 `main` 更改為回傳 `Result<(), E>` 允許在 `Result` 值上使用 `?` operator。

`Box<dyn Error>` 型別是一個 _trait object_，我們將在 Chapter 18 的「[使用 trait 物件來允許不同型別的值](https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types)」中討論。目前，你可以將 `Box<dyn Error>` 理解為「任何類型的錯誤」。在 `main` function 中，對錯誤型別為 `Box<dyn Error>` 的 `Result` 值使用 `?` 是允許的，因為它允許任何 `Err` 值提早回傳。儘管這個 `main` function 的主體只會回傳 `std::io::Error` 型別的錯誤，但透過指定 `Box<dyn Error>`，即使在 `main` 的主體中添加了回傳其他錯誤的更多程式碼，這個 signature 仍然會保持正確。

當 `main` function 回傳 `Result<(), E>` 時，如果 `main` 回傳 `Ok(())`，則 executable 將以值 `0` 退出；如果 `main` 回傳 `Err` 值，則以非零值退出。以 C 語言編寫的 executable 在退出時會回傳整數：成功退出的程式回傳整數 `0`，而錯誤退出的程式回傳非 `0` 的整數。Rust 也從 executables 回傳整數以與此慣例相容。

`main` function 可以回傳任何實作 `std::process::Termination` trait 的型別，該 trait 包含一個回傳 `ExitCode` 的 function `report`。有關為你自己的型別實作 `Termination` trait 的更多資訊，請查閱 standard library documentation。

既然我們已經討論了呼叫 `panic!` 或回傳 `Result` 的細節，讓我們回到如何決定在哪些情況下適當使用的主題。

## 要 panic! 還是不要 panic!

那麼，你如何決定何時應該呼叫 `panic!` 以及何時應該回傳 `Result` 呢？當程式碼 panic 時，就沒有辦法復原了。你可以針對任何錯誤情況呼叫 `panic!`，無論是否有辦法復原，但這樣你就代表呼叫端程式碼決定了情況是不可復原的。當你選擇回傳 `Result` 值時，你給予呼叫端程式碼選項。呼叫端程式碼可以選擇以適合其情況的方式嘗試復原，或者它可以決定在這種情況下 `Err` 值是不可復原的，所以它可以呼叫 `panic!` 並將你的可復原錯誤變成不可復原的錯誤。因此，當你定義一個可能失敗的 function 時，回傳 `Result` 是一個很好的預設選擇。

在範例、prototype 程式碼和 tests 等情況下，編寫會 panic 的程式碼比回傳 `Result` 更為合適。讓我們探討原因，然後討論 compiler 無法判斷失敗是不可能的情況，但你身為人類卻可以判斷的情況。本章將以一些關於如何在 library 程式碼中決定是否 panic 的一般準則作結。

### 範例、Prototype 程式碼與 Tests

當你編寫一個範例來闡述某個概念時，同時包含強健的錯誤處理程式碼可能會使範例不那麼清晰。在範例中，對 `unwrap` 等可能 panic 的 method 的呼叫，被理解為你希望應用程式處理錯誤的方式的 placeholder，這可能因你程式碼的其餘部分所執行的操作而異。

同樣地，`unwrap` 和 `expect` methods 在 prototyping 時非常方便，在你準備好決定如何處理錯誤之前。它們在你的程式碼中留下了清晰的標記，以便你在準備好讓程式更健壯時進行處理。

如果 method 呼叫在 test 中失敗，你會希望整個 test 都失敗，即使該 method 不是正在測試的功能。由於 `panic!` 是 test 被標記為失敗的方式，因此呼叫 `unwrap` 或 `expect` 正是應該發生的情況。

### 你比 Compiler 擁有更多資訊的情況

當你有一些其他邏輯可以確保 `Result` 將會是 `Ok` 值，但 compiler 無法理解這些邏輯時，呼叫 `expect` 也是適當的。你仍然會有一個 `Result` 值需要處理：無論你呼叫什麼操作，它通常仍然可能失敗，即使在你特定情況下邏輯上不可能。如果你能透過手動檢查程式碼來確保你永遠不會有 `Err` variant，那麼呼叫 `expect` 並在參數文字中記錄你認為永遠不會有 `Err` variant 的原因，這是完全可以接受的。這是一個範例：

```rust
    use std::net::IpAddr;

    let home: IpAddr = "127.0.0.1"
        .parse()
        .expect("Hardcoded IP address should be valid");
```

我們透過解析一個 hardcoded 的 string 來建立一個 `IpAddr` 實例。我們可以看到 `127.0.0.1` 是一個有效的 IP address，所以在這裡使用 `expect` 是可以接受的。然而，擁有一個 hardcoded 的有效 string 並不會改變 `parse` method 的回傳型別：我們仍然會得到一個 `Result` 值，並且 compiler 仍然會要求我們處理 `Result`，就好像 `Err` variant 是一種可能性一樣，因為 compiler 不夠聰明，無法看到這個 string 總是有效的 IP address。如果 IP address string 是來自使用者而不是 hardcoded 在程式中，因此確實存在失敗的可能性，我們肯定會想要以更強健的方式處理 `Result`。提到這個 IP address 是 hardcoded 的假設，將會促使我們在未來需要從其他來源獲取 IP address 時，將 `expect` 更改為更好的錯誤處理程式碼。

### 錯誤處理的準則

建議讓你的程式碼在可能進入 _不健全狀態 (bad state)_ 時 panic。在這種情況下，_不健全狀態_ 是指某些假設、保證、契約或 invariant 被破壞，例如當無效值、矛盾值或缺失值被傳遞給你的程式碼時——加上以下一或多個情況：

- 不健全狀態是意料之外的情況，而不是偶爾會發生的情況，例如使用者輸入了錯誤格式的資料。
- 程式碼在此之後需要依賴於不處於這種不健全狀態，而不是在每個步驟都檢查問題。
- 沒有一個好的方法可以將這些資訊編碼到你使用的型別中。我們將在 Chapter 18 的「[將狀態與行為編碼為型別](https://doc.rust-lang.org/book/ch17-03-advanced-traits.html#encoding-states-and-behavior-as-types)」中透過範例解釋我們的意思。

如果有人呼叫你的程式碼並傳入沒有意義的值，如果可以的話，最好回傳一個錯誤，這樣 library 的使用者就可以決定在這種情況下他們想做什麼。然而，在繼續執行可能會不安全或有害的情況下，最好的選擇可能是呼叫 `panic!` 並提醒使用你 library 的人他們程式碼中的 bug，以便他們在開發過程中修復它。同樣地，如果你呼叫外部程式碼，而它超出了你的控制，並且它回傳了一個你無法修復的無效狀態，那麼 `panic!` 通常是適當的。

然而，當失敗是預期中的情況時，回傳 `Result` 比呼叫 `panic!` 更為合適。範例包括 parser 收到格式錯誤的資料，或者 HTTP request 回傳一個表示你已達到 rate limit 的 status。在這些情況下，回傳 `Result` 表示失敗是一種預期的可能性，呼叫端程式碼必須決定如何處理。

當你的程式碼執行一個操作，如果使用無效值呼叫它可能會使用戶處於風險之中時，你的程式碼應該首先驗證值的有效性，如果值無效則 panic。這主要是出於安全原因：嘗試對無效資料進行操作可能會使你的程式碼面臨 vulnerabilities。這是 standard library 會在你嘗試記憶體越界存取時呼叫 `panic!` 的主要原因：試圖存取不屬於目前 data structure 的記憶體是一個常見的 security problem。Functions 通常有 _contracts_：只有當輸入符合特定要求時，它們的行為才得到保證。當 contract 被違反時發生 panicking 是有道理的，因為 contract 違反總是表示呼叫端 bug，而且這不是你希望呼叫端程式碼必須明確處理的錯誤。事實上，呼叫端程式碼沒有合理的恢復方法；呼叫端 _programmer_ 需要修復程式碼。function 的 contracts，特別是當違反會導致 panic 時，應在 function 的 API documentation 中解釋。

然而，在所有 function 中進行大量的錯誤檢查會很冗長且令人煩惱。幸運的是，你可以使用 Rust 的型別系統（以及 compiler 完成的 type checking）為你完成許多檢查。如果你的 function 有一個特定型別作為 parameter，你可以繼續你的程式碼邏輯，因為你知道 compiler 已經確保你擁有一個有效值。例如，如果你有一個型別而不是 `Option`，你的程式預期會有_某個東西 (something)_ 而不是_沒有東西 (nothing)_。你的程式碼就不必處理 `Some` 和 `None` variants 的兩種情況：它只會有一種情況，即明確地擁有一個值。試圖向你的 function 傳遞 nothing 的程式碼甚至無法編譯，所以你的 function 不必在 runtime 檢查這種情況。另一個範例是使用 unsigned integer 型別，例如 `u32`，這確保 parameter 永遠不會是負數。

### 建立用於驗證的自訂型別

讓我們將使用 Rust 的型別系統來確保我們有一個有效值的想法再進一步，看看如何建立一個用於驗證的自訂型別。回想 Chapter 2 中的猜數字遊戲，我們的程式要求使用者猜測一個介於 1 到 100 之間的數字。我們在將其與我們的 secret number 進行比較之前，從未驗證使用者的猜測是否介於這些數字之間；我們只驗證了猜測是否為正數。在這種情況下，後果不是很嚴重：「太高 (Too high)」或「太低 (Too low)」的輸出仍然是正確的。但如果能引導使用者進行有效猜測，並在使用者猜測的數字超出範圍與使用者輸入字母等情況下有不同的行為，那將是一個有用的增強功能。

一種方法是將猜測解析為 `i32` 而不是只有 `u32`，以允許潛在的負數，然後添加一個檢查數字是否在範圍內的程式碼，像這樣：

src/main.rs

```rust
    loop {
        // --snip--

        let guess: i32 = match guess.trim().parse() {
            Ok(num) => num,
            Err(_) => continue,
        };

        if guess < 1 || guess > 100 {
            println!("The secret number will be between 1 and 100.");
            continue;
        }

        match guess.cmp(&secret_number) {
            // --snip--
    }
```

`if` expression 檢查我們的值是否超出範圍，告訴使用者問題，並呼叫 `continue` 來開始迴圈的下一次迭代並要求再次猜測。在 `if` expression 之後，我們可以繼續進行 `guess` 和 secret number 之間的比較，因為我們知道 `guess` 介於 1 到 100 之間。

然而，這不是一個理想的解決方案：如果程式絕對必須只對 1 到 100 之間的值進行操作，並且有許多 functions 具有此要求，那麼在每個 function 中都有這樣一個檢查將會很繁瑣（並且可能會影響 performance）。

相反地，我們可以在專用 module 中建立一個新型別，並將驗證放在一個 function 中來建立該型別的實例，而不是在各處重複驗證。這樣一來，function 就可以安全地在其 signatures 中使用新類型，並自信地使用它們接收到的值。Listing 9-13 顯示了定義 `Guess` 型別的一種方式，它只會在 `new` function 收到 1 到 100 之間的值時建立 `Guess` 的實例。

src/guessing_game.rs

```rust
pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -> Guess {
        if value < 1 || value > 100 {
            panic!("Guess value must be between 1 and 100, got {value}.");
        }

        Guess { value }
    }

    pub fn value(&self) -> i32 {
        self.value
    }
}
```

Listing 9-13: 一個只處理 1 到 100 之間的值的 `Guess` 型別

首先，我們建立一個名為 `guessing_game` 的新 module。接下來，我們在該 module 中定義一個名為 `Guess` 的 struct，它有一個名為 `value` 的 field，用於存放 `i32`。這就是數字儲存的地方。

然後我們在 `Guess` 上實作一個名為 `new` 的 associated function，它會建立 `Guess` 值的實例。`new` function 被定義為有一個名為 `value` 的 parameter，其型別為 `i32`，並回傳一個 `Guess`。`new` function 主體中的程式碼會測試 `value`，以確保它介於 1 到 100 之間。如果 `value` 未通過此測試，我們就會發出 `panic!` 呼叫，這會提醒編寫呼叫端程式碼的 programmer，他們有一個需要修復的 bug，因為建立一個 `value` 超出此範圍的 `Guess` 將會違反 `Guess::new` 所依賴的 contract。`Guess::new` 可能會 panic 的條件應該在其 public-facing API documentation 中討論；我們將在 Chapter 14 中涵蓋你在 API documentation 中建立表示可能 `panic!` 的文件慣例。如果 `value` 通過測試，我們就會建立一個新的 `Guess`，將其 `value` field 設定為 `value` parameter，並回傳 `Guess`。

接下來，我們實作一個名為 `value` 的 method，它借用 `self`，沒有任何其他 parameters，並回傳一個 `i32`。這種 method 有時被稱為 _getter_，因為其目的是從其 fields 中獲取一些 data 並回傳。這個 public method 是必要的，因為 `Guess` struct 的 `value` field 是 private 的。`value` field 必須是 private 的這一點很重要，這樣使用 `Guess` struct 的程式碼就不允許直接設定 `value`：`guessing_game` module 外部的程式碼*必須*使用 `Guess::new` function 來建立 `Guess` 的實例，從而確保 `Guess` 不會有未經 `Guess::new` function 中條件檢查的 `value`。

那麼，一個參數只接受或回傳介於 1 到 100 之間的數字的 function，可以在其 signature 中聲明它接受或回傳 `Guess` 而不是 `i32`，並且不需要在其主體中進行任何額外的檢查。

## 總結

Rust 的錯誤處理功能旨在幫助你編寫更健壯的程式碼。`panic!` macro 表示你的程式處於無法處理的狀態，並讓你告知程序停止，而不是試圖使用無效或不正確的值繼續執行。`Result` enum 使用 Rust 的型別系統來表明操作可能會以你的程式碼可以復原的方式失敗。你可以使用 `Result` 來告訴呼叫你程式碼的程式碼，它也需要處理潛在的成功或失敗。在適當情況下使用 `panic!` 和 `Result` 將使你的程式碼在面對不可避免的問題時更加可靠。

既然你已經看到了 standard library 如何利用 generics 搭配 `Option` 和 `Result` enums 的有用方式，接下來我們將討論 generics 的運作方式以及如何在你的程式碼中使用它們。
